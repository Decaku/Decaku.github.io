{"pages":[{"title":"","text":"Al1yf5cTUE","path":"baidu_verify_Al1yf5cTUE.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"about-me","text":"测试","path":"about-me/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"牛客练习赛22-C简单瞎搞题 bitset+dp","text":"描述: 给出nnn个区间，然后分别给出区间的左右边界，可以在每个区间中选择一个整数，问这nnn个整数的平方和有多少种不同的取值。 思路: $ f_i $表示一个bitset，bitset里有几个1，就表示这i个区间所能得到的平方和的取值种数。 转移方程为 f[i]=f[i] | f[i-1]&lt;&lt;k^k (k from l to r) 状态转移的复杂度是n，每次操作对应的复杂度是l-r。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;bitset&gt;using namespace std;bitset&lt;1000000+10&gt;f[105];int main()&#123; int n,l,r; cin&gt;&gt;n; f[0][0]=1; for (int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;l, &amp;r); for(int j=l; j&lt;=r; j++) &#123; f[i]=f[i]|f[i-1]&lt;&lt;j*j; &#125; &#125; printf(&quot;%d\\n&quot;, f[n].count()); return 0;&#125;","path":"2019/02/04/牛客练习赛22-C简单瞎搞题-bitset-dp/"},{"title":"Poj 3281 Dining 最大流","text":"描述: 有一些牛，食物，饮料，每头牛都有一个喜欢吃的食物和饮料集合，要求你找出一个最大匹配，能满足所有牛的需求。 思路: 拆点以后跑最大流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500;const int maxm=210000;const int inf=1e9;int cnt=-1,f,d,n,s,t;int head[maxn],dep[maxn],cur[maxn];struct Edge&#123; int nxt; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; edge[++cnt].nxt=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=f+2*n+d+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; for(int i=0; i&lt;maxm*2; i++) edge[i].nxt=-1; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;f,&amp;d); s=f+2*n+d+1; t=f+2*n+d+2; for(int i=1; i&lt;=n; i++) &#123; int a,b,tem; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); for(int j=1;j&lt;=a;j++) &#123; scanf(&quot;%d&quot;,&amp;tem); add_edge(tem,f+i,1); add_edge(f+i,tem,0); &#125; for(int j=1;j&lt;=b;j++) &#123; scanf(&quot;%d&quot;,&amp;tem); add_edge(f+n+i,f+2*n+tem,1); add_edge(f+2*n+tem,f+n+i,0); &#125; add_edge(f+i,f+n+i,1); add_edge(f+n+i,f+i,0); &#125; for(int i=1;i&lt;=f;i++) &#123; add_edge(s,i,1); add_edge(i,s,0); &#125; for(int i=1;i&lt;=d;i++) &#123; add_edge(f+2*n+i,t,1); add_edge(t,f+2*n+i,0); &#125; printf(&quot;%d\\n&quot;,Dinic());&#125;","path":"2019/02/04/Poj-3281-Dining-最大流/"},{"title":"Poj 3041 Asteroids 最小点覆盖","text":"描述: 有一个500*500的网格图，格点上有一些点，每次可以消除一行或者一列上所有的点，问消除所有的点最少需要几次。 思路: 因为要消除一个点,只有2种方式，并且一行或者一列多次消除是没有意义的。可以考虑构建一个二分图，左边是所有的行，右边是所有的列，把待消除的点作为边，一个点会唯一连一条边，那么题意转化为了，选择二分图上的点，把与这个点连的边加入一个集合，这个集合应该包含了所有边，最少选择的点的个数，问题转化为了最小点覆盖。 二分图里最小点覆盖等于最大匹配，跑一遍最大流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1100;const int maxm=260000;const int inf=1e9;int cnt=-1,n,k,s,t;int head[maxn],dep[maxn],cur[maxn];struct Edge&#123; int nxt; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; edge[++cnt].nxt=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=2*n+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; //建图 左边点1-N(行) 右边点N+1， 2N 源点2N+1,汇点2N+2; for(int i=0;i&lt;maxm*2;i++) edge[i].nxt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); memset(head,-1,sizeof(head)); cnt=-1; for(int i=1;i&lt;=k;i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); add_edge(x,y+n,1); add_edge(y+n,x,0); &#125; for(int i=1;i&lt;=n;i++) &#123; add_edge(2*n+1,i,1); add_edge(i,2*n+1,0); add_edge(i+n,2*n+2,1); add_edge(2*n+2,i+n,0); &#125; s=2*n+1; t=2*n+2; printf(&quot;%d\\n&quot;,Dinic());&#125;","path":"2019/02/04/Poj-3041-Asteroids-最小点覆盖/"},{"title":"Poj 2135 Farm Tour 费用流","text":"描述: 给出起点和终点，要求从起点走到终点，再从终点回来，走的路最短，且来回走的路中不能有相同的边。 思路: 不要考虑来回，其实本质就是选择两条路，边权和最小，所以我们可以跑一个最大流是2的费用流。(选n条路就跑最大流是n的费用流) 本题所有边都是无向边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;const int maxn=2000;const int maxm=11000;int n,m,s,t;int cnt=-1,tot,sum;int dis[maxn],b[maxn],xb[maxn],flow[maxn],fa[maxn];int head[maxm];struct Edge&#123; int from,to,dis,nxt,w;&#125;edge[maxm*4];void add_edge(int from,int to,int w,int dis)&#123; edge[++cnt].nxt=head[from]; edge[cnt].from=from; edge[cnt].to=to; edge[cnt].w=w; edge[cnt].dis=dis; head[from]=cnt;&#125;bool spfa()&#123; for(int i=0;i&lt;=maxn;i++) dis[i]=inf; memset(b,0,sizeof(b)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); memset(fa,-1,sizeof(fa)); b[s]=1; dis[s]=0; fa[s]=0; flow[s]=inf; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); b[u]=0; for(int i=head[u];i!=-1;i=edge[i].nxt) &#123; int v=edge[i].to; if(edge[i].w&amp;&amp;dis[v]&gt;dis[u]+edge[i].dis) &#123; dis[v]=dis[u]+edge[i].dis; fa[v]=u; xb[v]=i; flow[v]=min(flow[u],edge[i].w); if(!b[v]) &#123; b[v]=1; que.push(v); &#125; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;void max_flow()&#123; while(spfa()) &#123; int k=t; while(k!=s) &#123; edge[xb[k]].w-=flow[t]; edge[xb[k]^1].w+=flow[t]; k=fa[k]; &#125; tot+=flow[t]; sum+=flow[t]*dis[t]; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); s=n+1; t=n+2; for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,1,c); add_edge(b,a,0,-c); add_edge(b,a,1,c); add_edge(a,b,0,-c); &#125; add_edge(s,1,2,0); add_edge(1,s,0,0); add_edge(n,t,2,0); add_edge(t,n,0,0); max_flow(); printf(&quot;%d\\n&quot;,sum);&#125;","path":"2019/02/04/Poj-2135-Farm-Tour-费用流/"},{"title":"Hdu1569 洛谷P2774方格取数 状压dp or 最小割","text":"描述: 给一个n∗mn*mn∗m的方格，每个格子里有个正数，要求选择若干数，这些数所在方格不能有相邻的边，要求选择的数的和最大。 思路: 状压dp玄学爆过去了,然而复杂度算下来不对。 正解是网络流。对方格染色，把方格变成二分图，把所有点的权相加，去掉最小割就是我们所要的答案了，所以具体的建图方式为：源点与黑色点连，汇点与白色点连，容量都是点权。然后又因为选了一个点以后会影响它相邻的点，这些边是不会出现在割集中的，所以把这些边的容量置inf。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=15000;const int maxm=50000;const int inf=1e9;int cnt=-1,n,m,s,t,sum;int head[maxn],dep[maxn],cur[maxn];struct P&#123; int id,w;&#125;;vector&lt;P&gt;_1,_2;struct Edge&#123; int next=-1; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; //cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].next) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].next) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=n*m+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; //1-n*n n*n+1,n*n+2m while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; _1.clear(); _2.clear(); sum=0; memset(head,-1,sizeof(head)); cnt=-1; s=n*m+1; t=n*m+2; int _cnt=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; P tem; scanf(&quot;%d&quot;,&amp;tem.w); sum+=tem.w; _cnt++; tem.id=_cnt; if((i+j)&amp;1) _1.push_back(tem); else _2.push_back(tem); &#125; &#125; for(int i=0; i&lt;_1.size(); i++) &#123; add_edge(s,_1[i].id,_1[i].w); add_edge(_1[i].id,s,0); &#125; for(int i=0; i&lt;_2.size(); i++) &#123; add_edge(_2[i].id,t,_2[i].w); add_edge(t,_2[i].id,0); &#125; for(int i=0; i&lt;_1.size(); i++) &#123; if(_1[i].id%m!=0) add_edge(_1[i].id,_1[i].id+1,inf),add_edge(_1[i].id+1,_1[i].id,0); if(_1[i].id%m!=1) add_edge(_1[i].id,_1[i].id-1,inf),add_edge(_1[i].id-1,_1[i].id,0); if(_1[i].id+m&lt;=n*m) add_edge(_1[i].id,_1[i].id+m,inf),add_edge(_1[i].id+m,_1[i].id,0); if(_1[i].id-m&gt;=1) add_edge(_1[i].id,_1[i].id-m,inf),add_edge(_1[i].id-m,_1[i].id,0); &#125; printf(&quot;%d\\n&quot;,sum-Dinic()); &#125;&#125;","path":"2019/02/04/Hdu1569-洛谷P2774方格取数-状压dp-or-最小割/"},{"title":"Hdu 1116 Play on Words 并查集+有向图的欧拉路","text":"描述: 类似于成语接龙，给若干个单词，问能否组成一个排列，使得一个单词的尾字母和后面一个单词的首字母相同。例如acm，malform，mouse这三个单词就满足题意。 思路: 把每个单词看成一条边，取首字母和尾字母，作为起点和终点。建图，图上有26个点，每输入一个单词，就在对应的两点间建立一条有向边。要判断输入的单词是否满足题意，其实就是判断图中是否存在一条欧拉路径。如果这个图不只包含一个连通分量，那么一定不满足题意。连通分量用并查集维护。 下面的问题就是判断有向图的欧拉路径。如果不是回路，那么图中只有一个点的出度比入度大1（起点），一个点的出度比入度小1（终点），其它点出度等于入度。如果是欧拉回路，则所有的点出度等于入度。并且如果存在出度入度的差值大于1的点也一定不能形成欧拉路。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int p[30];int Find(int x)&#123; if(x!=p[x]) p[x]=Find(p[x]); return p[x];&#125;void join(int a,int b)&#123; if(Find(a)!=Find(b)) p[Find(a)]=Find(b);&#125;int main()&#123; //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int t,num,num1,num2; cin&gt;&gt;t; int indeg[30],outdeg[30]; bool vis[30],flag; while(t--) &#123; num=num1=num2=0; flag=true; int n; cin&gt;&gt;n; char str[1000]; for(int i=0; i&lt;26; i++) &#123; p[i]=i; vis[i]=false; outdeg[i]=indeg[i]=0; &#125; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;str; join(str[0]-&apos;a&apos;,str[strlen(str)-1]-&apos;a&apos;); indeg[str[0]-&apos;a&apos;]++; outdeg[str[strlen(str)-1]-&apos;a&apos;]++; vis[str[0]-&apos;a&apos;]=true; vis[str[strlen(str)-1]-&apos;a&apos;]=true; &#125; for(int i=0; i&lt;26; i++) &#123; if(p[i]==i&amp;&amp;vis[i]) num++; if(indeg[i]-outdeg[i]==1) num1++; if(outdeg[i]-indeg[i]==1) num2++; if(indeg[i]-outdeg[i]&gt;1||outdeg[i]-indeg[i]&gt;1) flag=false; &#125; if(flag==true&amp;&amp;num==1&amp;&amp;(num1==num2==0||num1==num2==1)) &#123; cout&lt;&lt;&quot;Ordering is possible.&quot;&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;The door cannot be opened.&quot;&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Hdu-1116-Play-on-Words-并查集-有向图的欧拉路/"},{"title":"bzoj 1036 树的统计 树链剖分","text":"描述: 三种操作，一是修改树上某结点的权，二是询问结点x到y路径上的最大点的权，三是询问结点x到y路径上所有点的权值和。 思路: 先对树进行重链剖分，然后用线段树维护连续区间的最大值和区间和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=30005;const int maxm=60005;const int inf=1e9;int cnt,tot,n,q;int head[maxn],siz[maxn],dep[maxn],pre[maxn],fa[maxn],wson[maxn],dfn[maxn],top[maxn];int value[maxn];struct Tree&#123; int l,r,sum,mx;&#125; tree[4*maxn];struct Edge&#123; int nex,to;&#125; edge[maxm];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs1(int u,int f)&#123; siz[u]=1; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==fa[u]) continue; dep[v]=dep[u]+1; fa[v]=u; dfs1(v,u); siz[u]+=siz[v]; if(siz[wson[u]]&lt;siz[v]) wson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++tot; pre[tot]=u; top[u]=tp; if(wson[u]) dfs2(wson[u],tp); for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v!=fa[u]&amp;&amp;v!=wson[u]) dfs2(v,v); &#125;&#125;void build(int k,int l,int r)&#123; tree[k].l=l,tree[k].r=r; if(l==r) return ; int mid=l+r&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r);&#125;void change(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==r) &#123; tree[k].sum=tree[k].mx=y; return ; &#125; if(x&lt;=mid) change(k&lt;&lt;1,x,y); else change(k&lt;&lt;1|1,x,y); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; tree[k].mx=max(tree[k&lt;&lt;1].mx,tree[k&lt;&lt;1|1].mx);&#125;int querysum(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].sum; if(y&lt;=mid) return querysum(k&lt;&lt;1,x,y); else if(x&gt;mid) return querysum(k&lt;&lt;1|1,x,y); else return querysum(k&lt;&lt;1,x,mid)+querysum(k&lt;&lt;1|1,mid+1,y);&#125;int querymax(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].mx; if(y&lt;=mid) return querymax(k&lt;&lt;1,x,y); else if(x&gt;mid) return querymax(k&lt;&lt;1|1,x,y); else return max(querymax(k&lt;&lt;1,x,mid),querymax(k&lt;&lt;1|1,mid+1,y));&#125;int solvesum(int x,int y)&#123; int sum=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); sum+=querysum(1,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); sum+=querysum(1,dfn[x],dfn[y]); return sum;&#125;int solvemax(int x,int y)&#123; int mx=-inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); mx=max(mx,querymax(1,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); mx=max(mx,querymax(1,dfn[x],dfn[y])); return mx;&#125;void solve()&#123; build(1,1,n); for(int i=1; i&lt;=n; i++) change(1,dfn[i],value[i]); scanf(&quot;%d&quot;,&amp;q); char ch[10]; for(int i=1; i&lt;=q; i++) &#123; int x,y; scanf(&quot;%s%d%d&quot;,ch,&amp;x,&amp;y); if(ch[0]==&apos;C&apos;) &#123; value[x]=y; change(1,dfn[x],y); &#125; else &#123; if(ch[1]==&apos;M&apos;) printf(&quot;%d\\n&quot;,solvemax(x,y)); else printf(&quot;%d\\n&quot;,solvesum(x,y)); &#125; &#125;&#125;int main()&#123; cnt=-1; tot=0; memset(head,-1,sizeof(head)); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); add_edge(a,b); add_edge(b,a); &#125; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;value[i]); dfs1(1,0); dfs2(1,1); solve(); return 0;&#125;","path":"2019/02/04/bzoj-1036-树的统计-树链剖分/"},{"title":"bzoj 1008 越狱","text":"描述: 有n个人排成一列，一共有m种势力，每个人可能属于一个势力，相邻的人势力相同则不合法，一共有多少种可能的不合法状态。 思路: 所有的状态是mnm^{n}mn,正面很难求不合法的状态，所以想到先求合法状态，第一个人有mmm种选择，剩下的人都只有m−1m-1m−1种选择，所以答案就是mn−m∗(m−1)n−1m^{n}-m*(m-1)^{n-1}mn−m∗(m−1)n−1。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=100003;ll m,n;ll quick_pow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=(res*a)%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; while(~scanf(&quot;%lld %lld&quot;,&amp;m,&amp;n)) &#123; ll ans=(quick_pow(m,n)-(m*quick_pow(m-1,n-1))%mod+mod)%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","path":"2019/02/04/bzoj-1008-越狱/"},{"title":"bzoj1003 预处理最短路+区间dp","text":"描述: 给一个图，让你跑n次最短路，第i次最短路有若干点是不能使用的，并且更改一次路线就又需要加k的额外花费，问跑完n次以后最小花费。 思路: 想到把n次最短路分割成多个区间最短路的和，一个区间内最短路是不变的，对于每种最短路，我们可以预处理，因为只有n方的区间，n最大100，点最多只有20个，先跑n方的spfa。设dp[i][j]表示第i次到第j次最短路的所有花费的最小值。那么答案就是dp[1][n]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200;const int maxm=1000;int cnt=-1,n,m,k,e;int head[maxn],use[110][110],dist[maxn],dp[110][110];bool inq[maxn];struct Edge&#123; int nex; int to,w;&#125; edge[maxm];void add_edge(int u,int v,int w)&#123; edge[++cnt].nex=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool check(int x,int s,int t)&#123; for(int i=s; i&lt;=t; i++) if(!use[x][i]) return false; return true;&#125;int spfa(int s,int t)&#123; memset(dist,0x3f,sizeof(dist)); memset(inq,false,sizeof(inq)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); que.push(1); dist[1]=0; inq[1]=true; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=false; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(check(v,s,t)&amp;&amp;dist[v]&gt;dist[u]+edge[i].w) &#123; dist[v]=dist[u]+edge[i].w; if(!inq[v]) inq[v]=true,que.push(v); &#125; &#125; &#125; return dist[m]==0x3f3f3f3f ? 0x3f3f3f3f:dist[m]*(t-s+1);&#125;void solve()&#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=i; j&lt;=n; j++) dp[i][j]=spfa(i,j); &#125; int e; for(int len=2; len&lt;=n; len++) for(int s=1; (e=s+len-1)&lt;=n; s++) for(int p=s; p&lt;s+len-1; p++) &#123; dp[s][e]=min(dp[s][e],dp[s][p]+dp[p+1][e]+k); &#125; printf(&quot;%d\\n&quot;,dp[1][n]);&#125;int main()&#123; while(~scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;k,&amp;e)) &#123; memset(head,-1,sizeof(head)); cnt=-1; for(int i=1; i&lt;maxm; i++) edge[i].nex=-1; for(int i=1; i&lt;=e; i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,c); add_edge(b,a,c); &#125; memset(use,1,sizeof(use)); int tem; scanf(&quot;%d&quot;,&amp;tem); for(int i=1; i&lt;=tem; i++) &#123; int p,a,b; scanf(&quot;%d %d %d&quot;,&amp;p,&amp;a,&amp;b); for(int j=a; j&lt;=b; j++) use[p][j]=0; &#125; solve(); &#125;&#125;","path":"2019/02/04/bzoj1003-预处理最短路-区间dp/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","path":"2019/01/31/hello-world/"}]}
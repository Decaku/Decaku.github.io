{"pages":[{"title":"","text":"Al1yf5cTUE","path":"baidu_verify_Al1yf5cTUE.html"},{"title":"about-me","text":"测试","path":"about-me/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"bzoj 1008 越狱","text":"描述: 有n个人排成一列，一共有m种势力，每个人可能属于一个势力，相邻的人势力相同则不合法，一共有多少种可能的不合法状态。 思路: 所有的状态是$ m^{n} ,正面很难求不合法的状态，所以想到先求合法状态，第一个人有,正面很难求不合法的状态，所以想到先求合法状态，第一个人有,正面很难求不合法的状态，所以想到先求合法状态，第一个人有 m 种选择，剩下的人都只有种选择，剩下的人都只有种选择，剩下的人都只有 m-1 种选择，所以答案就是种选择，所以答案就是种选择，所以答案就是 m^{n} -m*(m-1)^{n-1} $。","path":"2019/02/04/bzoj-1008-越狱/"},{"title":"bzoj1003 预处理最短路+区间dp","text":"描述:给一个图，让你跑n次最短路，第i次最短路有若干点是不能使用的，并且更改一次路线就又需要加k的额外花费，问跑完n次以后最小花费。 思路:想到把n次最短路分割成多个区间最短路的和，一个区间内最短路是不变的，对于每种最短路，我们可以预处理，因为只有n方的区间，n最大100，点最多只有20个，先跑n方的spfa。设dp[i][j]表示第i次到第j次最短路的所有花费的最小值。那么答案就是dp[1][n]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200;const int maxm=1000;int cnt=-1,n,m,k,e;int head[maxn],use[110][110],dist[maxn],dp[110][110];bool inq[maxn];struct Edge&#123; int nex; int to,w;&#125; edge[maxm];void add_edge(int u,int v,int w)&#123; edge[++cnt].nex=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool check(int x,int s,int t)&#123; for(int i=s; i&lt;=t; i++) if(!use[x][i]) return false; return true;&#125;int spfa(int s,int t)&#123; memset(dist,0x3f,sizeof(dist)); memset(inq,false,sizeof(inq)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); que.push(1); dist[1]=0; inq[1]=true; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=false; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(check(v,s,t)&amp;&amp;dist[v]&gt;dist[u]+edge[i].w) &#123; dist[v]=dist[u]+edge[i].w; if(!inq[v]) inq[v]=true,que.push(v); &#125; &#125; &#125; return dist[m]==0x3f3f3f3f ? 0x3f3f3f3f:dist[m]*(t-s+1);&#125;void solve()&#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=i; j&lt;=n; j++) dp[i][j]=spfa(i,j); &#125; int e; for(int len=2; len&lt;=n; len++) for(int s=1; (e=s+len-1)&lt;=n; s++) for(int p=s; p&lt;s+len-1; p++) &#123; dp[s][e]=min(dp[s][e],dp[s][p]+dp[p+1][e]+k); &#125; printf(&quot;%d\\n&quot;,dp[1][n]);&#125;int main()&#123; while(~scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;k,&amp;e)) &#123; memset(head,-1,sizeof(head)); cnt=-1; for(int i=1; i&lt;maxm; i++) edge[i].nex=-1; for(int i=1; i&lt;=e; i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,c); add_edge(b,a,c); &#125; memset(use,1,sizeof(use)); int tem; scanf(&quot;%d&quot;,&amp;tem); for(int i=1; i&lt;=tem; i++) &#123; int p,a,b; scanf(&quot;%d %d %d&quot;,&amp;p,&amp;a,&amp;b); for(int j=a; j&lt;=b; j++) use[p][j]=0; &#125; solve(); &#125;&#125;","path":"2019/02/04/bzoj1003-预处理最短路-区间dp/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/01/31/hello-world/"}]}
{"pages":[{"title":"","text":"Al1yf5cTUE","path":"baidu_verify_Al1yf5cTUE.html"},{"title":"about-me","text":"测试","path":"about-me/index.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"categories","text":"","path":"categories/index.html"}],"posts":[{"title":"Bzoj4919 [Lydsy1706月赛]大根堆","text":"描述:传送门 思路:$本质上就是求树上最长上升子序列,联想到序列LIS的nlogn做法, \\\\但是对于子树要进行合并,考虑到集合具有有序性,使用多重 \\\\集合来维护每个结点,在dfs回溯时合并子树,并采用启发式 \\\\合并来降低复杂度,总复杂度为nlognlogn。 $ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************** Problem: 4919 User: Decaku Language: C++ Result: Accepted Time:864 ms Memory:22472 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;int n,w[maxn],head[maxn],cnt;multiset&lt;int&gt;m[maxn]; struct Node&#123; int nex,to;&#125; e[maxn&lt;&lt;1]; void ini()&#123; memset(head,-1,sizeof(head)); cnt=-1;&#125;void add_edge(int u,int v)&#123; e[++cnt].nex=head[u]; e[cnt].to=v; head[u]=cnt; e[++cnt].nex=head[v]; e[cnt].to=u; head[v]=cnt;&#125; void Merge(int a,int b)&#123; if(m[a].size()&lt;m[b].size()) swap(m[a],m[b]); multiset&lt;int&gt;::iterator it=m[b].begin(); while(it!=m[b].end()) &#123; m[a].insert(*it); it++; &#125;&#125; void dfs(int u,int f)&#123; for(int i=head[u]; i!=-1; i=e[i].nex) &#123; int v=e[i].to; if(v==f) continue; dfs(v,u); Merge(u,v); &#125; multiset&lt;int&gt;::iterator it; it=m[u].lower_bound(w[u]); if(it!=m[u].end()) m[u].erase(it); m[u].insert(w[u]); &#125; int main()&#123; scanf(&quot;%d&quot;,&amp;n); ini(); for(int i=1; i&lt;=n; i++) &#123; int v; scanf(&quot;%d %d&quot;,&amp;w[i],&amp;v); add_edge(i,v); &#125; dfs(1,0); printf(&quot;%d\\n&quot;,m[1].size());&#125;","path":"2019/02/20/Bzoj4919-Lydsy1706月赛-大根堆/"},{"title":"关于最长上升子序列nlogn做法的证明","text":"$ 笔者最近做题时，又遇到了常见的的最长上升子序列问题,之前在学习 \\\\过程中对这个问题只是知道了做法,但是原理却一知半解,今天正好来 \\\\整理一下。 $ $ LIS的定义：一段序列中最长的单调递增或单调不减的子序列。 $ $有关LIS的n^{2}的dp做法，网上已有相当多的解释，并且这种做法也比 \\\\较直观，这里就不再赘述了。 $ $但是对于nlogn的优化算法,许多blog只给出了算法阐述,但是并未解释 \\\\清楚原因,以下笔者将给出严格证明。 $ $先定义一下数组d,d[i]代表长度为i的上升子序列中最后一个元素的值, \\\\若有多个长度为i的上升子序列，则d[i]取所有子序列最后一个元素的 \\\\最小值。 $ $举个例子,对于序列1,4,3来说，长度为2的上升子序列有两个，分别 \\\\是1,3和1,4;由于3比4小,根据定义,d[2]=3。 $ $那么很明显数组d的大小就是LIS的长度,只要维护d数组即可。 $ $以下证明d数组是单调不减的,即对于i \\lt j,则有d[i] \\leq d[j]。 $ $使用反证法证明: \\\\ 假设存在i \\lt j,d[i] \\gt d[j]; \\\\ 设长度为i的上升子序列为x_1,x_2 \\cdots x_i; \\\\ 设长度为j的上升子序列为y_1,y_2 \\cdots y_i \\cdots y_j; \\\\ 则有y_i \\leq y_j \\lt x_i; \\\\ 那么以子序列y_1 \\cdots y_i的结尾y_i作为d[i]比x_i小。 \\\\ 这不符合d数组的定义,所以假设不成立,证毕。 $ $具体维护d数组的过程为: 设a为要求LIS的序列,若a[i]比d[i-1]大, \\\\更新d[i]为a[i]即可。否则,在d数组里寻找一个位置k,使得 \\\\d[k-1] \\lt a[i] \\leq d[k],根据d数组的定义,所有长度为k的上升 \\\\子序列最后一个元素的最小值应是a[i],使用a[i]更新d[k]即可。 $ $寻找k的过程可以二分,所以总复杂度为nlogn。$","path":"2019/02/20/关于最长上升子序列nlogn做法的证明/"},{"title":"2018 ICPC 南京站","text":"传送门$A.对称博弈,坑点是细节特别多。$ 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n,k;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); if(n==0) &#123; puts(&quot;Austin&quot;); return 0; &#125; if(k&gt;=n) &#123; puts(&quot;Adrien&quot;); return 0; &#125; if(k&gt;=2) &#123; puts(&quot;Adrien&quot;); return 0; &#125; if(k==1) &#123; if(n&amp;1) puts(&quot;Adrien&quot;); else puts(&quot;Austin&quot;); &#125;&#125; $J. 先做质因子分解,然后枚举每个质因子 \\\\对答案的贡献 $ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e6+5;bool no_prime[maxn];int minfac[maxn];int prime[maxn/10],prime_;void find_prime()&#123; minfac[1]=1; minfac[2]=2; no_prime[1]=true; int n=maxn; for(int i=2; i&lt;n; i++) &#123; if(!no_prime[i]) &#123; prime[prime_++]=i; minfac[i]=i; &#125; for(int j=0; j&lt;prime_&amp;&amp;prime[j]*i&lt;n; j++) &#123; no_prime[prime[j]*i]=true; minfac[prime[j]*i]=prime[j]; if(i%prime[j]==0) break; &#125; &#125;&#125;int fac[100][2],fac_;vector&lt;int&gt;v[maxn];//v[i] 代表void getfac(int x)&#123; fac_=0; while(x!=1) &#123; int little=minfac[x]; fac[fac_][0]=little; fac[fac_][1]=0; while(little!=1&amp;&amp;minfac[x]==little) &#123; x/=little; fac[fac_][1]++; &#125; fac_++; &#125;&#125;int n,a[maxn];int main()&#123; find_prime(); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) &#123; //memset(fac,0,sizeof(fac)); getfac(a[i]); for(int j=0; j&lt;fac_; j++) &#123; v[fac[j][0]].push_back(i); &#125; &#125; ll ans=0; for(int i=0; i&lt;prime_; i++) &#123; for(int j=0; j&lt;v[prime[i]].size(); j++) &#123; if(j==v[prime[i]].size()-1) &#123; ans+=1ll*v[prime[i]][j]*(n-v[prime[i]][j]+1); continue; &#125; ans+=1ll*v[prime[i]][j]*(v[prime[i]][j+1]-v[prime[i]][j]); &#125; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;//1 5 9 10 2的贡献//4+20+9+10=43 43+42+31=116//1 6 7 10 3的贡献//5+6+21+10=42//3 4 5的贡献//3+28=31//2 =2 7的贡献/*a1 a2 a3 ... ai a(i+1) 1 5 8 1*(4)=3 [1,1] [1,2] 5 (8-5)*/ $I.建图跑最大流$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;const int eps=1e-12;struct dinic&#123; static const int maxn=2000; static const int maxm=3e5; static const int inf=1e9; int cnt; struct edge &#123; int v,nex; int c; &#125; g[maxm*2]; int lv[maxn],current[maxn],head[maxn]; void add_edge(int u,int v,int c) &#123; g[cnt].v=v; g[cnt].c=c; g[cnt].nex=head[u]; head[u]=cnt++; g[cnt].v=u; g[cnt].c=0; g[cnt].nex=head[v]; head[v]=cnt++; &#125; void ini() &#123; memset(head,-1,sizeof(head)); cnt=0; &#125; void bfs(int s) &#123; memset(lv,-1,sizeof(lv)); lv[s]=0; queue&lt;int&gt;q; q.push(s); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u]; ~i; i=g[i].nex) &#123; edge &amp;e=g[i]; if(e.c&lt;=0||lv[e.v]&gt;=0) continue; lv[e.v]=lv[u]+1; q.push(e.v); &#125; &#125; &#125; int dfs(int u,int t,int f) &#123; if(u==t) return f; for(int &amp;i=current[u]; ~i; i=g[i].nex) &#123; edge &amp;e=g[i],&amp;rev=g[i^1]; if(e.c&lt;=0||lv[u]&gt;=lv[e.v]) continue; int d=dfs(e.v,t,min(f,e.c)); if(d&lt;=0) continue; e.c-=d; rev.c+=d; return d; &#125; return 0; &#125; int maxflow(int s,int t) &#123; int flow=0; while(1) &#123; memmove(current,head,sizeof(head)); bfs(s); if(lv[t]&lt;0) return flow; int f; while((f=dfs(s,t,inf))&gt;0) flow+=f; &#125; &#125;&#125; g;int n,m,k;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); g.ini(); int t=n+m+1; int s=n+m+2,a=n+m+3,b=n+m+4; for(int i=1; i&lt;=n; i++) &#123; int ct; scanf(&quot;%d&quot;,&amp;ct); for(int j=1; j&lt;=ct; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); g.add_edge(i,n+x,1); &#125; &#125; for(int i=n+1; i&lt;=n+m; i++) g.add_edge(i,t,1); for(int i=1; i&lt;=n; i++) g.add_edge(a,i,1),g.add_edge(b,i,1); g.add_edge(s,a,1e9); g.add_edge(s,b,k); printf(&quot;%d\\n&quot;,g.maxflow(s,t));&#125; $G. 公式不太好推，先爆搜出前几项，然后 \\\\连续做几次差分才能发现数列有规律。$ 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod=1e9+7;ll t,n;int main()&#123; scanf(&quot;%lld&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); ll ans=n*(n+1)%mod*(n+2)%mod*(n+3)%mod*41666667%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125; $K.逗你玩，直接随机化输出答案，卡不住。$ 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;char str[30];int main()&#123; srand(time(0)); int n,m; char a[4]= &#123;&apos;U&apos;,&apos;D&apos;,&apos;L&apos;,&apos;R&apos;&#125;; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(&quot;%s&quot;,str); for(int i=1; i&lt;=50000; i++) printf(&quot;%c&quot;,a[rand()%4]); printf(&quot;\\n&quot;);&#125; $D.最小球覆盖，几何法与模拟退火法两种做法，模拟退火的step要 \\\\调大才能满足精度。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const double eps=1e-14;struct point3D&#123; double x,y,z;&#125; data[105];int n;double dis(point3D a,point3D b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));&#125;double solve()&#123; double step=10000,ans=1e30,mt; point3D z; z.x=z.y=z.z=0; int s=0; while(step&gt;eps) &#123; for(int i=0; i&lt;n; i++) if(dis(z,data[s])&lt;dis(z,data[i])) s=i; mt=dis(z,data[s]); ans=min(ans,mt); z.x+=(data[s].x-z.x)/mt*step; z.y+=(data[s].y-z.y)/mt*step; z.z+=(data[s].z-z.z)/mt*step; step*=0.98; &#125; return ans;&#125;int main()&#123; // freopen(&quot;t.txt&quot;,&quot;r&quot;,stdin); double ans; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) scanf(&quot;%lf%lf%lf&quot;,&amp;data[i].x,&amp;data[i].y,&amp;data[i].z); ans=solve(); printf(&quot;%.15f\\n&quot;,ans); return 0;&#125; $M.这份题解讲的很明白了，快速幂记得预处理，不然会T飞。$传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=1e6+100;const ll p=101;const ll mod=1e9+7;char s[maxn],t[maxn],str[maxn&lt;&lt;1];ll hs[maxn],ht[maxn],hw[maxn&lt;&lt;1],pre[maxn];ll len,qpow[maxn];/*inline ll qpow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;*/inline bool ok(ll mid,ll i,ll j)&#123; ll h1=(hs[i]-hs[i-mid]*qpow[mid]%mod+mod)%mod; ll h2=(ht[j]-ht[j-mid]*qpow[mid]%mod+mod)%mod; return h1==h2;&#125;inline void init()&#123; str[1]=&apos;@&apos;; str[2]=&apos;#&apos;; for(ll i=1; i&lt;=len; i++) &#123; str[i*2+1]=s[i]; str[i*2+2]=&apos;#&apos;; &#125; len=len*2+2;&#125;inline void manacher()&#123; ll maxright=0,mid; for(ll i=1; i&lt;=len; i++) &#123; if(i&lt;maxright) hw[i]=min(hw[(mid&lt;&lt;1)-i],hw[mid]+mid-i); else hw[i]=1; for(; str[i+hw[i]]==str[i-hw[i]]; ++hw[i]); if(hw[i]+i&gt;maxright) &#123; maxright=hw[i]+i; mid=i; &#125; &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,s+1); scanf(&quot;%s&quot;,t+1); ll len_s=strlen(s+1); ll len_t=strlen(t+1); qpow[0]=1; for(int i=1;i&lt;=min(len_s,len_t)+2;++i) qpow[i]=qpow[i-1]*101%mod; len=len_s; for(ll i=1,j=len_t; i&lt;j; i++,j--) swap(t[i],t[j]); hs[1]=s[1]-&apos;a&apos;; ht[1]=t[1]-&apos;a&apos;; for(ll i=1; i&lt;=len_s; i++) hs[i]=(hs[i-1]*p+s[i]-&apos;a&apos;)%mod; for(ll i=1; i&lt;=len_t; i++) ht[i]=(ht[i-1]*p+t[i]-&apos;a&apos;)%mod; init(); manacher(); for(ll i=1; i&lt;=len; i++) &#123; ll r=(hw[i]-1)/2; if(!(i&amp;1)) &#123; //@#a#a# pre[i/2-r]++; pre[i/2]--; &#125; else &#123; //@#a#b#a# pre[(i-1)/2-r]++; pre[(i-1)/2+1]--; &#125; &#125; for(ll i=1; i&lt;=len_s; i++) pre[i]+=pre[i-1]; ll ans=0; for(ll i=1; i&lt;len_s; i++) &#123; if(s[i]!=t[len_t]) continue; ll l=0,r=min(i,len_t); while(l+1&lt;r) &#123; ll mid=(l+r)/2; if(ok(mid,i,len_t)) l=mid; else r=mid-1; &#125; if(ok(l+1,i,len_t)) l++; // cout&lt;&lt;l&lt;&lt;endl; ans+=l*pre[i+1]; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; 未完待续。。。","path":"2019/02/08/2018-ICPC-南京站/"},{"title":"Bzoj 1717 产奶的模式","text":"描述:传送门$求可重叠k次重复子串的最大长度。$ 思路:$具有相同公共前缀的后缀集合,它们的排名应该在一段连续 \\\\区间内，由这个思路可以二分,或者，对于一个height[i],找 \\\\一段连续区间，这个位置的height[i]最小，区间长度+1就是 \\\\子串出现次数，这不是单调栈的经典应用吗?$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//#include&lt;bits/stdc++.h&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=1e5+5;int n,m;int x[maxn],y[maxn],t[maxn],sa[maxn],rk[maxn],height[maxn];int l[maxn],r[maxn];stack&lt;int&gt;st;char s[maxn];int a[maxn];bool cmp(int i,int j,int k)&#123; return y[i]==y[j]&amp;&amp;y[i+k]==y[j+k];&#125;void get_sa()&#123; for(int i=1; i&lt;=n; ++i) t[x[i]=a[i]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[i]]--]=i; for(int k=1; k&lt;=n; k&lt;&lt;=1) &#123; int p=0; for(int i=0; i&lt;=m; ++i) y[i]=0; for(int i=n-k+1; i&lt;=n; ++i) y[++p]=i; for(int i=1; i&lt;=n; ++i) if(sa[i]&gt;k) y[++p]=sa[i]-k; for(int i=0; i&lt;=m; ++i) t[i]=0; for(int i=1; i&lt;=n; ++i) t[x[y[i]]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2; i&lt;=n; ++i) x[sa[i]]=cmp(sa[i],sa[i-1],k)?p:++p; if(p&gt;=n) break; m=p; &#125;&#125;void get_rk()&#123; for(int i=1; i&lt;=n; ++i) rk[sa[i]]=i;&#125;void get_height()&#123; for(int i=1,j=0; i&lt;=n; ++i) &#123; if(j) j--; while(a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; &#125;&#125;void ini()&#123; memset(sa,0,sizeof(sa)); memset(rk,0,sizeof(rk)); memset(height,0,sizeof(height)); memset(x,0,sizeof(x)); memset(y,0,sizeof(y)); memset(t,0,sizeof(t)); memset(a,0,sizeof(a));&#125;int main()&#123; int k; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); m=n; for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; get_sa(); get_rk(); get_height(); //height[1]=n-sa[1]+1; l[1]=1; st.push(1); for(int i=2; i&lt;=n; i++) &#123; while(!st.empty()&amp;&amp;height[st.top()]&gt;=height[i]) st.pop(); if(st.empty()) l[i]=1; else l[i]=st.top()+1; st.push(i); &#125; while(!st.empty()) st.pop(); r[n]=n; st.push(n); for(int i=n-1; i&gt;=1; i--) &#123; while(!st.empty()&amp;&amp;height[st.top()]&gt;=height[i]) st.pop(); if(st.empty()) r[i]=n; else r[i]=st.top()-1; st.push(i); &#125; int ans=-1; for(int i=1; i&lt;=n; i++) &#123; if(r[i]-l[i]+2&gt;=k) //这里是加2 ans=max(ans,height[i]); &#125; printf(&quot;%d\\n&quot;,ans);&#125;","path":"2019/02/07/Bzoj-1717-产奶的模式/"},{"title":"SPOJ - DISUBSTR","text":"描述:求字符串中本质不同的子串个数。 思路:$枚举每个排名的后缀对答案的贡献,排名为i的后缀里有n-sa[i]+1个前 \\\\缀,其中前缀被重复算贡献的次数是LCP(sa[i],sa[i-1]),所以答案是 \\\\\\sum n-sa[i]+1-height[i]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e3+5;int n,m;int x[maxn],y[maxn],t[maxn],sa[maxn],rk[maxn],height[maxn];char s[maxn];int a[maxn];bool cmp(int i,int j,int k)&#123; return y[i]==y[j]&amp;&amp;y[i+k]==y[j+k];&#125;void get_sa()&#123; for(int i=1; i&lt;=n; ++i) t[x[i]=a[i]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[i]]--]=i; for(int k=1; k&lt;=n; k&lt;&lt;=1) &#123; int p=0; for(int i=0; i&lt;=m; ++i) y[i]=0; for(int i=n-k+1; i&lt;=n; ++i) y[++p]=i; for(int i=1; i&lt;=n; ++i) if(sa[i]&gt;k) y[++p]=sa[i]-k; for(int i=0; i&lt;=m; ++i) t[i]=0; for(int i=1; i&lt;=n; ++i) t[x[y[i]]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2; i&lt;=n; ++i) x[sa[i]]=cmp(sa[i],sa[i-1],k)?p:++p; if(p&gt;=n) break; m=p; &#125;&#125;void get_rk()&#123; for(int i=1; i&lt;=n; ++i) rk[sa[i]]=i;&#125;void get_height()&#123; for(int i=1,j=0; i&lt;=n; ++i) &#123; if(j) j--; while(a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; &#125;&#125;void ini()&#123; memset(sa,0,sizeof(sa)); memset(rk,0,sizeof(rk)); memset(height,0,sizeof(height)); memset(x,0,sizeof(x)); memset(y,0,sizeof(y)); memset(t,0,sizeof(t)); memset(a,0,sizeof(a));&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ini(); scanf(&quot;%s&quot;,s+1); n=strlen(s+1); m=300; for(int i=1; i&lt;=n; i++) a[i]=s[i]; get_sa(); get_rk(); get_height(); int ans=0; for(int i=1; i&lt;=n; i++) &#123; ans+=(n-sa[i]+1-height[i]); &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","path":"2019/02/05/SPOJ-DISUBSTR/"},{"title":"Bzoj 1031 字符加密","text":"描述:传送门 思路:把字符串倍增一份，然后求后缀数组就好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/************************************************************** Problem: 1031 User: Decaku Language: C++ Result: Accepted Time:1336 ms Memory:29612 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,m;int x[maxn],y[maxn],t[maxn],sa[maxn],rk[maxn],height[maxn];char s[maxn];int a[maxn];bool cmp(int i,int j,int k)&#123; return y[i]==y[j]&amp;&amp;y[i+k]==y[j+k];&#125;void get_sa()&#123; //int m=30; for(int i=1; i&lt;=n; ++i) t[x[i]=a[i]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[i]]--]=i; for(int k=1; k&lt;=n; k&lt;&lt;=1) &#123; int p=0; for(int i=0; i&lt;=m; ++i) y[i]=0; for(int i=n-k+1; i&lt;=n; ++i) y[++p]=i; for(int i=1; i&lt;=n; ++i) if(sa[i]&gt;k) y[++p]=sa[i]-k; for(int i=0; i&lt;=m; ++i) t[i]=0; for(int i=1; i&lt;=n; ++i) t[x[y[i]]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2; i&lt;=n; ++i) x[sa[i]]=cmp(sa[i],sa[i-1],k)?p:++p; if(p&gt;=n) break; m=p; &#125;&#125; void get_rk()&#123; for(int i=1; i&lt;=n; ++i) rk[sa[i]]=i;&#125;void get_height()&#123; for(int i=1,j=0; i&lt;=n; ++i) &#123; if(j) j--; while(a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=n+1;i&lt;=2*n;i++) s[i]=s[i-n]; for(int i=1;i&lt;=2*n;i++) a[i]=s[i]; n*=2; m=500; get_sa(); for(int i=1;i&lt;=n;i++) &#123; if(sa[i]&lt;=n/2) &#123; printf(&quot;%c&quot;,s[sa[i]+n/2-1]); &#125; &#125; printf(&quot;\\n&quot;); &#125;","path":"2019/02/05/Bzoj-1031-字符加密/"},{"title":"Codeforces Round 533 Div2","text":"A:暴力。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint a[1005];int n;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); int t,ans=1e9; for(int i=1;i&lt;=100;i++) &#123; int p=0; for(int j=1;j&lt;=n;j++) &#123; if(a[j]&lt;i-1) p+=i-1-a[j]; else if(a[j]&gt;i+1) p+=a[j]-(i+1); &#125; if(p&lt;ans) &#123; ans=p; t=i; &#125; &#125; printf(&quot;%d %d\\n&quot;,t,ans);&#125; B:$统计26个字母的level，然后比较。$ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=2e5+5;int cnt[30];char str[maxn];int n,k;vector&lt;char&gt;v;int main()&#123; memset(cnt,0,sizeof(cnt)); v.clear(); scanf(&quot;%d %d&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,str); //int tem=0; for(int i=0; i&lt;n; i++) &#123; //tem++; //v.push_back(str[i]); if(v.empty()||v[0]==str[i]) &#123; v.push_back(str[i]); if(v.size()==k) &#123; cnt[v[0]-&apos;a&apos;]++; v.clear(); &#125; &#125; else if(v[0]!=str[i]) &#123; v.clear(); v.push_back(str[i]); &#125; &#125; int ans=-1; for(int i=0; i&lt;=26; i++) ans=max(ans,cnt[i]); printf(&quot;%d\\n&quot;,ans);&#125; D:$计数dp，dp[i][j]表示前i个数的和模3等于j的方案数，答案是dp[n][0]。$ 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=2e5+5;const int mod=1e9+7;ll a[maxn],n,l,r;ll dp[maxn][3];int main()&#123; scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;l,&amp;r); ll a=r/3-(l-1)/3; ll b=(r+2)/3-(l+2-1)/3; ll c=(r+1)/3-(l+1-1)/3; dp[1][0]=a; dp[1][1]=b; dp[1][2]=c; for(int i=2;i&lt;=n;i++) &#123; dp[i][0]=(dp[i-1][0]*a%mod+dp[i-1][1]*c%mod+dp[i-1][2]*b%mod)%mod; dp[i][1]=(dp[i-1][0]*b%mod+dp[i-1][1]*a%mod+dp[i-1][2]*c%mod)%mod; dp[i][2]=(dp[i-1][0]*c%mod+dp[i-1][1]*b%mod+dp[i-1][2]*a%mod)%mod; &#125; printf(&quot;%lld&quot;,dp[n][0]);&#125; D:$bfs,用vector[i]维护第i个人走了第j步以后增加的格子。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,p;int s[11],a[1100][1100];int d[4][2]= &#123;1,0, -1,0, 0,1, 0,-1&#125;;char str[1100];vector&lt;pair&lt;int,int&gt; &gt;v[1100],t;int ans[11];bool bfs(int x)&#123; t.clear(); for(int i=0; i&lt;v[x].size(); i++) t.push_back(v[x][i]); v[x].clear(); int sz=t.size(); for(int i=0; i&lt;sz; i++) &#123; for(int j=0; j&lt;4; j++) &#123; int X=t[i].first,Y=t[i].second; if(X+d[j][0]&lt;1||X+d[j][0]&gt;n) continue; if(Y+d[j][1]&lt;1||Y+d[j][1]&gt;m) continue; if(a[X+d[j][0]][Y+d[j][1]]==0) &#123; a[X+d[j][0]][Y+d[j][1]]=x; v[x].push_back(make_pair(X+d[j][0],Y+d[j][1])); &#125; &#125; &#125; if(!v[x].size()) return 0; return 1;&#125;int main()&#123; memset(a,0,sizeof(a)); scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;p); for(int i=1; i&lt;=p; i++) scanf(&quot;%d&quot;,&amp;s[i]); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%s&quot;,str+1); for(int j=1; j&lt;=m; j++) &#123; if(str[j]==&apos;#&apos;) a[i][j]=-1; else if(str[j]!=&apos;.&apos;) &#123; a[i][j]=str[j]-&apos;0&apos;; v[str[j]-&apos;0&apos;].push_back(make_pair(i,j)); &#125; &#125; &#125; while(1) &#123; bool ok=false; for(int i=1; i&lt;=p; i++) for(int j=1; j&lt;=s[i]; j++) &#123; if(!bfs(i)) break; //只要有一次为真 就会为真 else ok=true; &#125; if(!ok) break; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(a[i][j]&gt;0) ans[a[i][j]]++; &#125; &#125; for(int i=1; i&lt;=p; i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n&quot;);&#125; E:$对于两个type1之间的朋友，只会选择一个朋友去修改名字，那么 \\\\可以把朋友作为结点，对于两个type1之间的结点，两两之间建立无 \\\\向边，最后即求尽量多的点，之间没有边，问题转化为最大独立集。 \\\\最大独立集等于补图最大团。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=45;int g[maxn][maxn];int ans,cnt[maxn],group[maxn],n,m,vis[maxn];bool dfs(int u,int pos)&#123; int i,j; for( i=u+1; i&lt;=m; i++) &#123; if(cnt[i]+pos&lt;=ans) return 0; if(g[u][i]) &#123; for( j=0; j&lt;pos; j++) if(!g[i][vis[j]]) break; if(j==pos) &#123; vis[pos]=i; if(dfs(i,pos+1)) return 1; &#125; &#125; &#125; if(pos&gt;ans) &#123; for(int i=0; i&lt;pos; i++) group[i]=vis[i]; ans=pos; return 1; &#125; return 0;&#125;void maxclique()&#123; ans=-1; for(int i=m; i&gt;0; i--) &#123; vis[0]=i; dfs(i,1); cnt[i]=ans; &#125;&#125;vector&lt;string&gt;v;map&lt;string,int&gt; mp;int tot;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; int type; scanf(&quot;%d&quot;,&amp;type); if(type==2) &#123; string str; cin&gt;&gt;str; v.push_back(str); if(mp[str]==0) mp[str]=++tot; //mp[str]=++tot; &#125; else &#123; for(int i=0; i&lt;v.size(); i++) &#123; for(int j=0; j&lt;i; j++) &#123; g[mp[v[i]]][mp[v[j]]]=1; g[mp[v[j]]][mp[v[i]]]=1; &#125; &#125; v.clear(); //mp.clear(); &#125; &#125; if(v.size()) &#123; for(int i=0; i&lt;v.size(); i++) &#123; for(int j=0; j&lt;i; j++) &#123; g[mp[v[i]]][mp[v[j]]]=1; g[mp[v[j]]][mp[v[i]]]=1; &#125; &#125; &#125; /*for(int i=1; i&lt;=m; i++) &#123; for(int j=1; j&lt;=m; j++) cout&lt;&lt;g[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; // return 0;*/ for(int i=1; i&lt;=m; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(i!=j) g[i][j]^=1; &#125; &#125; maxclique(); printf(&quot;%d\\n&quot;,ans);&#125;","path":"2019/02/05/Codeforces-Round-533-Div2/"},{"title":"Bzoj 2115","text":"描述:$一个无向图，可能有自环与重边，选择一条从1到n的路径， \\\\每个点和边都可以重复经过，使边权异或和最大。$ 思路:$找出所有环，简单证明一下，先任意找一条路径,再找到环， \\\\如果环不在路径上，路径到环的这段距离会被走两次，异或 \\\\以后对答案不产生贡献，再证路径的任意性，如果存在一条 \\\\更优路径，更优路径与当前路径必然形成环，该环与当前选 \\\\择的路径进行异或即可得到更优路径。异或之和最大，即求 \\\\环的异或的线性基。在dfs过程中求环的异或时预处理一个 \\\\sz数组，sz[i]代表从1到i路径上的边权异或和$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/************************************************************** Problem: 2115 User: Decaku Language: C++ Result: Accepted Time:892 ms Memory:17572 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=5e4+5;const ll maxm=5e5+5;vector&lt;pair&lt;ll,ll&gt; &gt;g[maxn];ll n,m;ll vis[maxn],Xor[maxm],sz[maxm],cnt;ll p[65]; void dfs2(ll s,ll f)&#123; vis[s]=1; //for(ll i=g[s].size()-1;i&gt;=0;i--) for(ll i=0; i&lt;=g[s].size()-1; i++) &#123; ll v=g[s][i].first,w=g[s][i].second; if(v==f) continue; if(vis[v]) &#123; Xor[++cnt]=(sz[s]^sz[v]^w); continue; &#125; else &#123; sz[v]=(sz[s]^w); dfs2(v,s); &#125; &#125;&#125; int main()&#123; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m); for(ll i=1; i&lt;=m; i++) &#123; ll u,v,w; scanf(&quot;%lld %lld %lld&quot;,&amp;u,&amp;v,&amp;w); g[u].push_back(make_pair(v,w)); g[v].push_back(make_pair(u,w)); &#125; memset(vis,0,sizeof(vis)); dfs2(1,0); for(int i=1; i&lt;=cnt; i++) &#123; for(int j=62; j&gt;=0; j--) &#123; if(!(Xor[i]&gt;&gt;j)) continue; if(!(p[j])) &#123; p[j]=Xor[i]; break; &#125; else Xor[i]^=p[j]; &#125; &#125; ll ans=sz[n]; for(int i=62; i&gt;=0; i--) &#123; if((ans^p[i])&gt;ans) ans^=p[i]; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","path":"2019/02/05/Bzoj-2115/"},{"title":"Codeforces Round #529 (Div. 3)","text":"A&amp;B:$A模拟,B两个case比较。$ 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int n; string str; scanf(&quot;%d&quot;,&amp;n); cin&gt;&gt;str; string ans=&quot;&quot;; int ct=1; for(int i=0; i&lt;n; i+=ct) &#123; ans+=str[i]; ct++; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e5+5;int a[maxn];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); int ans=0; ans=min(a[n-1]-a[1],a[n]-a[2]); printf(&quot;%d\\n&quot;,ans);&#125; C:所有数都是可以拆的,贪心的不断把大数除2直到变成1，特判输入是1,1的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint n,k;vector&lt;int&gt;ans,v,t;void ini()&#123; for(int i=1; i&lt;=n; i*=2) &#123; v.push_back(i); &#125;&#125;bool solve()&#123; while(1) &#123; int tem=*(upper_bound(v.begin(),v.end(),n)-1); t.push_back(tem); n-=tem; if(!n) break; &#125; if(t.size()&gt;k) return false; else &#123; int sz=t.size(); while(sz&lt;k) &#123; t[0]/=2; if(t[0]==1) &#123; ans.push_back(t[0]); ans.push_back(t[0]); t.erase(t.begin()); sz++; &#125; else &#123; t.push_back(t[0]); t.push_back(t[0]); t.erase(t.begin()); sz++; &#125; &#125; &#125; return true;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); ini(); if(n&amp;1) &#123; ans.push_back(1); n--; k--; &#125; if(n==0&amp;&amp;k==0) &#123; puts(&quot;YES&quot;); puts(&quot;1&quot;); &#125; else if(k&gt;n) &#123; puts(&quot;NO&quot;); &#125; else &#123; if(!solve()) puts(&quot;NO&quot;); else &#123; puts(&quot;YES&quot;); for(int i=0; i&lt;ans.size(); i++) printf(&quot;%d &quot;,ans[i]); for(int i=0; i&lt;t.size(); i++) printf(&quot;%d &quot;,t[i]); &#125; &#125;&#125; D:$如果i的两个临接数是a和b且i的下一个数就是a,那么a的两个 \\\\邻接数里一定有b，然后就可以建图了，输出答案一遍dfs即可。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=4e5+5;vector&lt;int&gt;v[maxn];int n;struct Edge&#123; int nex,to;&#125; e[maxn];int head[maxn],cnt,vis[maxn];void ini()&#123; memset(head,-1,sizeof(head)); memset(vis,0,sizeof(vis)); cnt=-1;&#125;void add_edge(int u,int v)&#123; e[++cnt].nex=head[u]; e[cnt].to=v; head[u]=cnt;&#125;void dfs(int u)&#123; printf(&quot;%d &quot;,u); vis[u]=1; for(int i=head[u]; i!=-1; i=e[i].nex) &#123; int v=e[i].to; if(vis[v]) continue; dfs(v); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); v[i].push_back(x); v[i].push_back(y); &#125; ini(); for(int i=1; i&lt;=n; i++) &#123; int x=v[i][0],y=v[i][1]; if(v[x][0]==y||v[x][1]==y) &#123; add_edge(i,x); add_edge(x,y); &#125; else &#123; add_edge(i,y); add_edge(y,x); &#125; &#125; dfs(1); printf(&quot;\\n&quot;);&#125; E:正着反着各扫描一遍字符串处理4个数组，然后对于每个位置判断一下把它反转以后是否能使得字符串平衡。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e6+5;char str[maxn];int n;int pre[maxn],prec[maxn],suf[maxn],sufc[maxn];//pre[i]前i个字符的封闭度//prec[i]前i个字符是否可以作前缀//suf[i] i到n的字符封闭度//sufc[i] i到n的字符是否可以做后缀int main()&#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,str+1); if(str[1]==&apos;(&apos;) &#123; pre[1]=1; prec[1]=1; &#125; else &#123; pre[1]=-1; prec[1]=0; &#125; for(int i=2; i&lt;=n; i++) &#123; if(str[i]==&apos;(&apos;) pre[i]=pre[i-1]+1; else pre[i]=pre[i-1]-1; if(prec[i-1]&amp;&amp;pre[i]&gt;=0) prec[i]=1; else prec[i]=0; &#125; if(str[n]==&apos;)&apos;) &#123; suf[n]=1; sufc[n]=1; &#125; else &#123; suf[n]=-1; sufc[n]=0; &#125; for(int i=n-1; i&gt;=1; i--) &#123; if(str[i]==&apos;)&apos;) suf[i]=suf[i+1]+1; else suf[i]=suf[i+1]-1; if(sufc[i+1]&amp;&amp;suf[i]&gt;=0) sufc[i]=1; else sufc[i]=0; &#125; int ans=0; prec[0]=sufc[n+1]=1; for(int i=1; i&lt;=n; i++) &#123; if(prec[i-1]&amp;&amp;sufc[i+1]) &#123; if(str[i]==&apos;)&apos;&amp;&amp;suf[i+1]-pre[i-1]==1) ans++; if(str[i]==&apos;(&apos;&amp;&amp;pre[i-1]-suf[i+1]==1) ans++; &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;//( ( ( ( ) ) F:$直接求MST复杂度会爆炸,但是容易发现只有n条边可能在MST里。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=2e5+5;ll n,m;ll f[maxn],W[maxn];void ini()&#123; for(ll i=0;i&lt;maxn;i++) f[i]=i;&#125;ll Find(ll x)&#123; return f[x]==x?x:f[x]=Find(f[x]);&#125;void join(ll a,ll b)&#123; f[Find(a)]=Find(b);&#125;struct edge&#123; ll u,v,w;&#125; e[maxn&lt;&lt;2];bool cmp(edge a,edge b)&#123; return a.w&lt;b.w;&#125;ll cnt;int main()&#123; ini(); scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m); ll pos=1; for(ll i=1; i&lt;=n; i++) &#123; scanf(&quot;%lld&quot;,&amp;W[i]); if(W[i]&lt;W[pos]) pos=i; &#125; for(ll i=1; i&lt;=n; i++) &#123; if(i!=pos) &#123; e[++cnt].u=pos; e[cnt].v=i; e[cnt].w=W[pos]+W[i]; &#125; &#125; for(ll i=1; i&lt;=m; i++) &#123; ll u,v,w; scanf(&quot;%lld %lld %lld&quot;,&amp;u,&amp;v,&amp;w); e[++cnt].u=u; e[cnt].v=v; e[cnt].w=w; &#125; sort(e+1,e+cnt+1,cmp); ll ans=0; for(ll i=1; i&lt;=cnt; i++) &#123; ll u=e[i].u,v=e[i].v,w=e[i].w; if(Find(u)!=Find(v)) &#123; join(u,v); ans+=w; &#125; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","path":"2019/02/05/Codeforces-Round-529-Div-3/"},{"title":"Poj 2104 Kth number","text":"描述:$多组询问，每次求给定区间里第k小的数。$ 思路:划分树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int tree[20][maxn];int sorted[maxn];int toleft[20][maxn];void build(int l,int r,int dep)&#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; int same=mid-l+1; for(int i=l; i&lt;=r; i++) if(tree[dep][i]&lt;sorted[mid]) same--; int lpos=l; int rpos=mid+1; for(int i=l; i&lt;=r; i++) &#123; if(tree[dep][i]&lt;sorted[mid]) tree[dep+1][lpos++]=tree[dep][i]; else if(tree[dep][i]==sorted[mid]&amp;&amp;same&gt;0) &#123; tree[dep+1][lpos++]=tree[dep][i]; same--; &#125; else tree[dep+1][rpos++]=tree[dep][i]; toleft[dep][i]=toleft[dep][l-1]+lpos-l; &#125; build(l,mid,dep+1); build(mid+1,r,dep+1);&#125;int query(int L,int R,int l,int r,int dep,int k)&#123; if(l==r) return tree[dep][l]; int mid=(L+R)&gt;&gt;1; int cnt=toleft[dep][r]-toleft[dep][l-1]; if(cnt&gt;=k) &#123; int newl=L+toleft[dep][l-1]-toleft[dep][L-1]; int newr=newl+cnt-1; return query(L,mid,newl,newr,dep+1,k); &#125; else &#123; int newr=r+toleft[dep][R]-toleft[dep][r]; int newl=newr-(r-l-cnt); return query(mid+1,R,newl,newr,dep+1,k-cnt); &#125;&#125;int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2) &#123; memset(tree,0,sizeof(tree)); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;tree[0][i]); sorted[i]=tree[0][i]; &#125; sort(sorted+1,sorted+n+1); build(1,n,0); int s,t,k; while(m--) &#123; scanf(&quot;%d %d %d&quot;,&amp;s,&amp;t,&amp;k); printf(&quot;%d\\n&quot;,query(1,n,s,t,0,k)); &#125; &#125; return 0;&#125;","path":"2019/02/05/Poj-2104-Kth-number/"},{"title":"Codeforces Round #521 Div3","text":"A:模拟。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); ll a,b,k,ans; while(t--) &#123; scanf(&quot;%lld %lld %lld&quot;,&amp;a,&amp;b,&amp;k); ans=0; ans+=(k+1)/2*a; ans-=(k-(k+1)/2)*b; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; B:贪心。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;int n,a[200],vis[200];vector&lt;int&gt;v;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=2; i&lt;=n-1; i++) &#123; if(!a[i]&amp;&amp;a[i-1]&amp;&amp;a[i+1]) v.push_back(i); &#125; int k; if(v.empty()) k=0; else &#123; k=1; vis[v[0]]=1; for(int i=1; i&lt;v.size(); i++) &#123; if(v[i]-v[i-1]==2&amp;&amp;vis[v[i-1]]) continue; k++; vis[v[i]]=1; &#125; &#125; printf(&quot;%d\\n&quot;,k);&#125; C:作为和的数一定最大。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;const int maxn=2e5+5;int n;struct Node&#123; int id,w;&#125;a[maxn];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;ll sum;vector&lt;int&gt;v;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].w),sum+=a[i].w,a[i].id=i; sort(a,a+n+1,cmp); ll ans=0; for(int i=1;i&lt;n;i++) &#123; ll tem=sum; if(tem-a[i].w-a[n].w==a[n].w) v.push_back(a[i].id),ans++; &#125; if(sum-a[n].w-a[n-1].w==a[n-1].w) v.push_back(a[n].id),ans++; printf(&quot;%d\\n&quot;,ans); for(int i=0;i&lt;v.size();i++) printf(&quot;%d &quot;,v[i]); printf(&quot;\\n&quot;);&#125; D:二分删掉的数在原数组里出现的次数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;int a[maxn],cnt[maxn],n,k,_cnt;vector&lt;int&gt;v;bool check(int mid)&#123; int res=0; for(int i=1; i&lt;=n;) &#123; if(res&gt;=k) return true; res+=cnt[a[i]]/mid; i+=cnt[a[i]]; &#125; if(res&gt;=k) return true; return false;&#125;bool cmp(int x,int y)&#123; if(cnt[x]==cnt[y]) return x&lt;y; return cnt[x]&gt;cnt[y];&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); _cnt=n/k; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]),cnt[a[i]]++; sort(a+1,a+n+1,cmp); int l=1,r=_cnt; while((r-l)&gt;1) &#123; int mid=(l+r)/2; if(check(mid)) &#123; l=mid; &#125; else r=mid-1; &#125; if(check(r)) l=r; int res=0; for(int i=1; i&lt;=n;) &#123; if(res&gt;=k) break; for(int j=1; j&lt;=cnt[a[i]]/l; j++) &#123; v.push_back(a[i]); &#125; res+=cnt[a[i]]/l; i+=cnt[a[i]]; &#125; for(int i=0; i&lt;k; i++) &#123; printf(&quot;%d &quot;,v[i]); &#125; printf(&quot;\\n&quot;);&#125; E:$记录每个数的次数后sort,对每个位置的查找都二分。$ 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;int a[maxn],n;map&lt;int,int&gt;mp;vector&lt;int&gt;v;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); mp[a[i]]++; &#125; for(map&lt;int,int&gt;::iterator it=mp.begin(); it!=mp.end(); it++) &#123; v.push_back(it-&gt;second); &#125; sort(v.begin(),v.end()); int ans=-1; for(int i=1; i&lt;=n; i++) &#123; int x=i; int d=0,tem=0; while(1) &#123; int pos=lower_bound(v.begin()+d,v.end(),x)-v.begin(); if(pos==v.size()) break; tem+=x; x&lt;&lt;=1; d=pos+1; &#125; ans=max(ans,tem); &#125; printf(&quot;%d\\n&quot;,ans);&#125; F&amp;G:$dp过程中要用到滑窗最值,hard version用单调队列优化就好。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll inf=1e15;const ll maxn=5005;ll n,k,x;ll a[maxn],dp[maxn][maxn];//dp[i][j]前j个数选i个且必选第j个数能取得的最大值ll q[maxn][maxn],l,r; //q[i-1][l]代表dp[i-1][j]到dp[i-1][j-k+1]的最大值//dp[i][j]=max(dp[i-1][t])+a[j] (j-k+1&lt;=t&lt;j)int main()&#123; scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;k,&amp;x); for(ll i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(ll i=1; i&lt;maxn; i++) for(ll j=1; j&lt;maxn; j++) dp[i][j]=-inf; for(ll j=1; j&lt;=k; j++) dp[1][j]=a[j]; for(ll i=2; i&lt;=x; i++) &#123; l=0,r=-1; for(ll j=1; j&lt;=n; j++) &#123; if(l&lt;=r) dp[i][j]=dp[i-1][q[i-1][l]]+a[j]; while(l&lt;=r&amp;&amp;dp[i-1][j]&gt;=dp[i-1][q[i-1][r]]) r--; q[i-1][++r]=j; if(l&lt;=r&amp;&amp;q[i-1][l]&lt;j-k+1) l++; &#125; &#125; ll ans=-1; for(ll j=n; j&gt;n-k&amp;&amp;j&gt;=1; j--) ans=max(ans,dp[x][j]); if(ans) printf(&quot;%lld\\n&quot;,ans); else puts(&quot;-1&quot;);&#125;","path":"2019/02/05/Codeforces-Round-521-Div3/"},{"title":"Bzoj 1069 最大土地面积","text":"描述:给出若干个点，取四个点，求最大四边形面积。 思路:很明显这四个点都在凸包上，所以先做个凸包，然后枚举对角线，在两边旋转卡壳求两个最大三角的面积。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/************************************************************** Problem: 1069 User: Decaku Language: C++ Result: Accepted Time:152 ms Memory:1356 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;int n,top;struct P&#123; double x,y;&#125; p[2005],s[2005]; double dis(P a,P b)&#123; return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);&#125; P operator -(P a,P b)&#123; P t; t.x=a.x-b.x; t.y=a.y-b.y; return t;&#125; double operator *(P a,P b)&#123; return a.x*b.y-a.y*b.x;&#125; bool operator &lt;(P a,P b)&#123; double t=(a-p[1])*(b-p[1]); if(t==0) return dis(a,p[1])&lt;dis(b,p[1]); return t&lt;0;&#125; void graham()&#123; int k=1; for(int i=2; i&lt;=n; i++) if(p[k].y&gt;p[i].y||(p[k].y==p[i].y&amp;&amp;p[k].x&gt;p[i].x)) k=i; swap(p[1],p[k]); sort(p+2,p+n+1); s[++top]=p[1]; s[++top]=p[2]; for(int i=3; i&lt;=n; i++) &#123; while(top&gt;1&amp;&amp;(p[i]-s[top-1])*(s[top]-s[top-1])&lt;=0) top--; s[++top]=p[i]; &#125; s[top+1]=p[1];&#125; double RC()&#123; double ans=0; int a,b; for(int x=1; x&lt;=top; x++) &#123; a=x%top+1; b=(x+2)%top+1; for(int y=x+2; y&lt;=top; y++) &#123; while(a%top+1!=y&amp;&amp;(s[y]-s[x])*(s[a+1]-s[x])&gt;(s[y]-s[x])*(s[a]-s[x])) a=a%top+1; while(b%top+1!=x&amp;&amp;(s[b+1]-s[x])*(s[y]-s[x])&gt;(s[b]-s[x])*(s[y]-s[x])) b=b%top+1; ans=max((s[y]-s[x])*(s[a]-s[x])+(s[b]-s[x])*(s[y]-s[x]),ans); &#125; &#125; return ans/2;&#125; int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%lf %lf&quot;,&amp;p[i].x,&amp;p[i].y); graham(); printf(&quot;%.3lf\\n&quot;,RC());&#125;","path":"2019/02/05/Bzoj-1069-最大土地面积/"},{"title":"Codeforces Round #522 ","text":"A:贪心。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int cnt[101];int main()&#123; memset(cnt,0,sizeof(cnt)); int n,k; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(int i=1; i&lt;=n; i++) &#123; int tem; scanf(&quot;%d&quot;,&amp;tem); cnt[tem]++; &#125; int _cnt=-1e9; for(int i=1; i&lt;=100; i++) &#123; _cnt=max(_cnt,cnt[i]); &#125; int tem=ceil(1.0*_cnt/k); int ans=0; for(int i=1; i&lt;=100; i++) &#123; if(!cnt[i]) continue; ans+=tem*k-cnt[i]; &#125; printf(&quot;%d\\n&quot;,ans);&#125; B:贪心。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;string str;int main()&#123; cin&gt;&gt;str; int len=str.length(); int _len=len; bool ok=false; int _1,_2=inf; while(1) &#123; for(int i=1; i&lt;=len; i++) &#123; if(len/i&gt;20||len%i!=0||i&gt;5) //i是组数 continue; else if(i&lt;_2) &#123; _1=len; _2=i; &#125; &#125; if(len==100) break; len++; &#125; int a=_1-_len; int b=a; printf(&quot;%d %d\\n&quot;,_2,_1/_2);//_1/_2是每行的长度,_2是行数 for(int i=1; i&lt;=_2; i++) &#123; for(int j=1; j&lt;=_1/_2; j++) &#123; if(j==_1/_2&amp;&amp;a&gt;0) &#123; cout&lt;&lt;&quot;*&quot;; a--; break; &#125; int pos=(i-1)*(_1/_2)+j-1-(b-a); cout&lt;&lt;str[pos]; &#125; cout&lt;&lt;endl; &#125;&#125; C:$dp[i][j]代表第i个位置能否放j,直接转移 \\\\因为要打印路径，再记录一下每个状态的前驱。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int n;int a[maxn],dp[maxn][6],pre[maxn][6];//pre[i][j]保存dp[i][j]的前一个状态void dfs(int i,int j)//i个位置选j&#123; if(i==1) &#123; cout&lt;&lt;j&lt;&lt;&quot; &quot;; return ; &#125; dfs(i-1,pre[i][j]); cout&lt;&lt;j&lt;&lt;&quot; &quot;;&#125;int main()&#123; memset(dp,0,sizeof(dp)); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int j=1;j&lt;=5;j++) dp[1][j]=1; for(int i=2; i&lt;=n; i++) &#123; if(a[i]==a[i-1]) &#123; for(int j=1; j&lt;=5; j++) &#123; for(int k=1; k&lt;=5; k++)//k是前一个 if(dp[i-1][k]&amp;&amp;j!=k) dp[i][j]=1, pre[i][j]=k; //pre[i][j]= &#125; &#125; else if(a[i]&gt;a[i-1]) &#123; for(int j=1; j&lt;=5; j++) &#123; for(int k=1; k&lt;=5; k++) if(dp[i-1][k]&amp;&amp;j&gt;k) dp[i][j]=1, pre[i][j]=k; &#125; &#125; else if(a[i]&lt;a[i-1]) &#123; for(int j=1; j&lt;=5; j++) &#123; for(int k=1; k&lt;=5; k++) if(dp[i-1][k]&amp;&amp;j&lt;k) dp[i][j]=1, pre[i][j]=k; &#125; &#125; &#125; int ans=0,tem; for(int j=1; j&lt;=5; j++) if(dp[n][j]) ans=1,tem=j; if(!ans) cout&lt;&lt;-1&lt;&lt;endl; else &#123; dfs(n,tem); cout&lt;&lt;endl; &#125;&#125; D:$猜了一下，应该只有五种case,都算出来取最小值即可。$ 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;double a,b,c;double x_1,y_1,x_2,y_2;double dis(double a,double b,double c,double d)&#123; return sqrt((a-c)*(a-c)+(b-d)*(b-d));&#125;int main()&#123; scanf(&quot;%lf %lf %lf&quot;,&amp;a,&amp;b,&amp;c); scanf(&quot;%lf %lf %lf %lf&quot;,&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2); double ans=abs(x_1-x_2)+abs(y_1-y_2); double p=(-1*c-b*y_1)/a,q=(-1*c-a*x_1)/b,r=(-1*c-b*y_2)/a,s=(-1*c-a*x_2)/b; double tem=abs(p-x_1)+abs(r-x_2)+dis(p,y_1,r,y_2); ans=min(ans,tem); tem=abs(p-x_1)+abs(s-y_2)+dis(p,y_1,x_2,s); ans=min(ans,tem); tem=abs(q-y_1)+abs(r-x_2)+dis(x_1,q,r,y_2); ans=min(ans,tem); tem=abs(q-y_1)+abs(s-y_2)+dis(x_1,q,x_2,s); ans=min(ans,tem); printf(&quot;%.10lf\\n&quot;,ans);&#125; E:$如果只有2种物品，ans最大可能是n，超过两种，能够鉴别出 \\\\的砝码必须质量都相等。所以可以先做一次背包，求出i个砝码 \\\\组成质量为j的方案数，有一个优化是dp过程中方案超过2就没意 \\\\义了，它不可能是答案。然后对每种物品枚举数量，检查方案数 \\\\是否只有一种，更新答案。要注意的是ans是n的情况要加特判。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[110],dp[10005][110];//dp[i][j]表示用j个物品正好装满容量为i的背包的方案数。map&lt;int,int&gt;m;vector&lt;pair&lt;int,int&gt; &gt;v;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); m[a[i]]++; &#125; for(map&lt;int,int&gt;::iterator it=m.begin(); it!=m.end(); it++) &#123; v.push_back(*it); &#125; dp[0][0]=1; for(vector&lt;pair&lt;int,int&gt; &gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; int tem=it-&gt;first; int cnt=it-&gt;second; for(int v=10000; v&gt;0; v--) &#123; for(int i=1; i&lt;=n; i++) &#123; for(int t=1; t&lt;=cnt&amp;&amp;t&lt;=i&amp;&amp;v-tem*t&gt;=0; t++) dp[v][i]+=dp[v-tem*t][i-t],dp[v][i]=min(dp[v][i],2); &#125; &#125; &#125; int ans=1; for(vector&lt;pair&lt;int,int&gt; &gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; int tem=it-&gt;first; int cnt=it-&gt;second; for(int t=1; t&lt;=cnt; t++) &#123; if(dp[tem*t][t]==1) &#123; if(v.size()==2&amp;&amp;t==cnt) &#123; printf(&quot;%d\\n&quot;,n); return 0; &#125; else ans=max(ans,t); &#125; &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","path":"2019/02/05/Codeforces-Round-522/"},{"title":"2014 ICPC 北京站","text":"A:$sort一下，注意除法转乘法因为浮点数的运算误差$ 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct Node&#123; int t,p;&#125; e[10005],e_2[10005];bool cmp(Node x, Node y)&#123; return x.t&lt;y.t;&#125;bool cmp2(Node x,Node y)&#123; return 1ll*x.p*y.t&gt;1ll*y.p*x.t;&#125;int main()&#123; int T,n; scanf(&quot;%d&quot;,&amp;T); for(int Time=1; Time&lt;=T; Time++) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d %d&quot;,&amp;e[i].t,&amp;e[i].p); sort(e+1,e+n+1,cmp); for(int i=2; i&lt;=n; i++) &#123; e_2[i].t=e[i].t-e[i-1].t; e_2[i].p=abs(e[i].p-e[i-1].p); &#125; sort(e_2+2,e_2+1+n,cmp2); double x=1; printf(&quot;Case #%d: %.2lf\\n&quot;,Time,x*e_2[2].p/e_2[2].t); &#125;&#125; K:树状数组差分乱搞。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,tree[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int k,int d)&#123; for(int i=k; i&lt;=n; i+=lowbit(i)) &#123; tree[i]+=d; &#125;&#125;int sigma(int k)&#123; int res=0; while(k&gt;0) &#123; res+=tree[k]; k-=lowbit(k); &#125; return res;&#125;int t,tem,ans,id[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;t); for(int time=1; time&lt;=t; time++) &#123; memset(tree,0,sizeof(tree)); ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;tem); id[tem]=i; add(i,1); &#125; for(int i=n; i&gt;0; i--) &#123; if(sigma(id[i])!=i) &#123; ans++; add(id[i],-1); &#125; &#125; printf(&quot;Case #%d: %d\\n&quot;,time,ans); &#125;&#125; H:$两数异或以后不会大于它们的和，直接暴力dp。$ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=1&lt;&lt;20;ll a[1&lt;&lt;21],dp[2][1&lt;&lt;21];ll t,n,m;int main()&#123; scanf(&quot;%lld&quot;,&amp;t); for(ll time=1; time&lt;=t; time++) &#123; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m); memset(a,0,sizeof(a)); for(ll i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(ll i=0; i&lt;maxn*2; i++) &#123; if(a[1]==i) dp[1][i]=1; else dp[1][i]=0; &#125; dp[1][0]=1; ll tem=0,ans=0; for(ll i=2; i&lt;=n; i++) &#123; for(ll j=0; j&lt;maxn*2; j++) &#123; dp[tem][j]=dp[1-tem][j]+dp[1-tem][j^a[i]]; &#125; tem=1-tem; &#125; for(ll i=m;i&lt;maxn;i++) ans+=dp[1-tem][i]; printf(&quot;Case #%lld: %lld\\n&quot;,time,ans); &#125;&#125; I:算圆环的交转换到算圆的交，然后套模板就好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-8;const double pi=acos(-1.0);int t;double R,r,x_1,y_1,x_2,y_2;int sgn(double x)&#123; if(fabs(x)&lt;eps) return 0; if(x&lt;0) return -1; else return 1;&#125;struct Point&#123; double x,y; Point() &#123;&#125; Point(double _x,double _y) &#123; x=_x; y=_y; &#125; double distance(Point p) &#123; return hypot(x-p.x,y-p.y); &#125;&#125;;struct circle&#123; Point p; double r; circle() &#123;&#125; double area() &#123; return pi*r*r; &#125; int relationship(circle v) &#123; double d=p.distance(v.p); if(sgn(d-r-v.r)&gt;0) return 5; if(sgn(d-r-v.r)==0) return 4; double l=fabs(r-v.r); if(sgn(d-r-v.r)&lt;0 &amp;&amp; sgn(d-l)&gt;0) return 3; if(sgn(d-l)==0) return 2; if(sgn(d-l)&lt;0) return 1; &#125; double areacircle(circle v) &#123; int rel=relationship(v); if(rel&gt;=4) return 0.0; if(rel&lt;=2) return min(area(),v.area()); double d=p.distance(v.p); double hf=(r+v.r+d)/2.0; double ss=2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d)); double a1=acos((r*r+d*d-v.r*v.r)/(2.0*r*d)); a1=a1*r*r; double a2=acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d)); a2=a2*v.r*v.r; return a1+a2-ss; &#125;&#125;;int main()&#123; scanf(&quot;%d&quot;,&amp;t); circle A,a,B,b; for(int time=1; time&lt;=t; time++) &#123; scanf(&quot;%lf %lf&quot;,&amp;r,&amp;R); scanf(&quot;%lf %lf&quot;,&amp;x_1,&amp;y_1); scanf(&quot;%lf %lf&quot;,&amp;x_2,&amp;y_2); A.p=a.p=Point(x_1,y_1); B.p=b.p=Point(x_2,y_2); A.r=B.r=R; a.r=b.r=r; double ans=0; ans=ans+A.areacircle(B)-A.areacircle(b)*2+a.areacircle(b); printf(&quot;Case #%d: %.6lf\\n&quot;,time,ans); &#125;&#125; D:$区间dp$ 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=2e9;int t,n;int dp[205][205],a[205],b[205];int main()&#123; scanf(&quot;%d&quot;,&amp;t); for(int time=1;time&lt;=t;time++) &#123; for(int i=0; i&lt;205; i++) for(int j=i; j&lt;205; j++) dp[i][j]=inf; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;b[i]); a[0]=b[0]=a[n+1]=b[n+1]=0; for(int len=1; len&lt;=n; len++) &#123; for(int s=1; s+len-1&lt;=n; s++) &#123; int e=s+len-1; for(int mid=s; mid&lt;=e; mid++) &#123; dp[s][e]=min(dp[s][e],dp[s][mid-1]+dp[mid+1][e]+a[mid]+b[s-1]+b[e+1]); &#125; &#125; &#125; printf(&quot;Case #%d: %d\\n&quot;,time,dp[1][n]); &#125;&#125; 未完待续。。。","path":"2019/02/05/2014-ICPC-北京站/"},{"title":"2012 ICPC 杭州站","text":"I:模拟。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;int dat[256];#pragma warning(disable:4996)int main()&#123; dat[&apos;A&apos;] = 16; dat[&apos;B&apos;] = 7; dat[&apos;C&apos;] = 8; dat[&apos;D&apos;] = 1; dat[&apos;E&apos;] = 1; dat[&apos;F&apos;] = 2; dat[&apos;G&apos;] = 3; int T; int A, B; cin &gt;&gt; T; for (int tim = 1; tim &lt;= T; tim++) &#123; cin &gt;&gt; A; int flagA = 0; int flagA1 = 0; int flagB = 0; int flagB1 = 0; int sum = 0; char tmp; for (int i = 0; i &lt; A; i++) &#123; cin &gt;&gt; tmp; if (tmp == &apos;B&apos;)flagA = 1; else if (tmp == &apos;C&apos;)flagA1 = 1; sum += dat[tmp]; &#125; if ((!flagA||!flagA1)&amp;&amp;sum&gt;1)sum--; cin &gt;&gt; B; int sumB = 0; for (int i = 0; i &lt; B; i++) &#123; cin &gt;&gt; tmp; sumB += dat[tmp]; if (tmp == &apos;B&apos;)flagB = 1; else if (tmp == &apos;C&apos;)flagB1 = 1; &#125; if ((!flagB1||!flagB)&amp;&amp;sumB&gt;1)sumB--; if (sum &gt; sumB)puts(&quot;red&quot;); else if (sum == sumB)puts(&quot;tie&quot;); else puts(&quot;black&quot;); &#125; return 0;&#125; K:$MST。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int f[60];double ans=0;int Find(int a)&#123; return f[a]==a?a:f[a]=Find(f[a]);&#125;int join(int a,int b)&#123; f[Find(a)]=Find(b);&#125;struct edge&#123; int u,v; double w;&#125; e[3000];bool cmp(edge a,edge b)&#123; return a.w&lt;b.w;&#125;void join(edge &amp;e)&#123; if(Find(e.u)!=Find(e.v)) &#123; f[Find(e.u)]=Find(e.v); ans+=e.w; &#125;&#125;struct Point&#123; int x,y;&#125; point[60];int n,a,b;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(n==0) break; for(int i=0; i&lt;60; i++) f[i]=i; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;point[i].x,&amp;point[i].y); &#125; int cnt=0; for(int i=1; i&lt;=n; i++) for(int j=i; j&lt;=n; j++) &#123; e[++cnt].u=i; e[cnt].v=j; e[cnt].w=sqrt((point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y)); &#125; sort(e+1,e+cnt+1,cmp); ans=0; f[a]=b; ans+=sqrt((point[a].x-point[b].x)*(point[a].x-point[b].x)+(point[a].y-point[b].y)*(point[a].y-point[b].y)); for(int i=1; i&lt;=cnt; i++) join(e[i]); printf(&quot;%.2lf\\n&quot;,ans); &#125;&#125; H:$对每个点跑一边堆优化的Dij。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt;mp;int f[1005];int Find(int a)&#123; return f[a]==a?a:f[a]=Find(f[a]);&#125;void join(int a,int b)&#123; f[Find(a)]=Find(b);&#125;struct dijkstra&#123; static const int maxn=1005; static const int maxm=20010; struct edge &#123; int v,w,nex; &#125; g[maxm]; int head[maxn],d[maxn]; bool done[maxn]; int n,cnt; void ini(int newn) &#123; n=newn; cnt=0; memset(head,-1,sizeof(head)); &#125; void add_edge(int u,int v,int w) &#123; g[cnt].v=v; g[cnt].w=w; g[cnt].nex=head[u]; head[u]=cnt++; &#125; struct HeapNode &#123; int d,u; bool operator &lt; (const HeapNode&amp; rhs)const &#123; return d&gt;rhs.d; &#125; &#125;; int short_path(int s) &#123; int ret=s; priority_queue&lt;HeapNode&gt;q; //memset(d,0,sizeof(d)); fill(d,d+n+1,1e9); d[s]=0; memset(done,0,sizeof(done)); q.push(HeapNode&#123;d[s],s&#125;); while(!q.empty()) &#123; HeapNode x=q.top(); q.pop(); int u=x.u; if(done[u]) continue; done[u]=true; for(int i=head[u]; ~i; i=g[i].nex) &#123; if(d[g[i].v]&gt;d[u]+g[i].w) &#123; d[g[i].v]=d[u]+g[i].w; if(d[g[i].v]&gt;d[ret]) ret=g[i].v; q.push(HeapNode&#123;d[g[i].v],g[i].v&#125;); &#125; &#125; &#125; return ret; &#125;&#125; g;int main()&#123; int n,m; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; mp.clear(); srand(time(NULL)); if(n==0) break; g.ini(n+1); string c,d; for(int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;c; mp[c]=i; f[i]=i; &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=1; i&lt;=m; i++) &#123; cin&gt;&gt;c&gt;&gt;d; join(mp[c],mp[d]); g.add_edge(mp[c],mp[d],1); g.add_edge(mp[d],mp[c],1); &#125; int cnt=0; for(int i=1; i&lt;=n; i++) &#123; if(f[i]==i) cnt++; &#125; if(cnt&gt;1) puts(&quot;-1&quot;); else &#123; int ans=-1; for(int i=1; i&lt;=n; i++) &#123; int s=i; //int s=(rand()%n)+1; int t=g.short_path(s); ans=max(ans,g.d[t]); //s=g.short_path(t); //ans=max(ans,g.d[s]); &#125; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125; C:队友写的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+5;int w[maxn];//okint cntsuf[maxn];//okint len[maxn];//okint pre[maxn];//okll dp[maxn];bool vis[maxn];//okint main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n))&#123; if(n==0)break; for(int i=0;i&lt;maxn;i++)&#123; pre[i]=-1; &#125; for(int i=0;i&lt;maxn;i++)&#123; len[i]=0; &#125; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,w+i); len[i-pre[w[i]]-1]++; pre[w[i]]=i; &#125; memset(vis,0,sizeof(vis)); cntsuf[n]=0; for(int i=n-1;i&gt;=0;i--)&#123; if(!vis[w[i]])&#123; cntsuf[i]=cntsuf[i+1]+1; vis[w[i]]-=true; &#125; else cntsuf[i]=cntsuf[i+1]; &#125; int sum=0; for(int i=n-1;i&gt;=1;i--)&#123; sum=sum+len[i]; &#125; dp[1]=n; for(int i=2;i&lt;n;i++)&#123; dp[i]=dp[i-1]-cntsuf[n-i+1]+sum; sum-=len[i-1]; &#125; int q; scanf(&quot;%d&quot;,&amp;q); while(q--)&#123; int tmp; scanf(&quot;%d&quot;,&amp;tmp); printf(&quot;%lld\\n&quot;,dp[tmp]); &#125; &#125;&#125; J:观察数据大小，直接枚举子集然后验证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;vector&lt;int&gt;v;int m[55][55],d[15];int n,k,ans;struct Node&#123; int x,y;&#125;node[11];bool check(int a,int b,int i)&#123; if(a&lt;1||a&gt;n||b&lt;1||b&gt;n) return false; int dis=abs(node[v[i]].x-a)+abs(node[v[i]].y-b); if(dis&gt;d[v[i]]) return false; return true;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(!m[i][j]) &#123; return false; &#125; &#125; &#125; return true;&#125;void color()&#123; for(int i=0;i&lt;v.size();i++) &#123; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(check(a,b,i)) m[a][b]=1; &#125; &#125; &#125;&#125;void solve()&#123; for(int i=0; i&lt;(1&lt;&lt;k); i++) &#123; v.clear(); memset(m,0,sizeof(m)); for(int j=1;j&lt;=k;j++) m[node[j].x][node[j].y]=1; for(int j=0; j&lt;k; j++) &#123; if(i&amp;(1&lt;&lt;j)) v.push_back(j+1); &#125; color(); if(check()) ans=min(ans,(int)v.size()); &#125;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(!n) break; memset(m,0,sizeof(m)); memset(d,0,sizeof(d)); scanf(&quot;%d&quot;,&amp;k); for(int i=1; i&lt;=k; i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); m[x][y]=1; node[i].x=x, node[i].y=y; &#125; for(int i=1; i&lt;=k; i++) scanf(&quot;%d&quot;,&amp;d[i]); ans=inf; solve(); if(ans==inf) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;,ans); &#125;&#125; 未完待续。。。","path":"2019/02/05/2012-ICPC-杭州站/"},{"title":"2016 ICPC 青岛站","text":"A:暴力打表,二分查询询问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longvector&lt;ll&gt;v;ll qpow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res*=a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;void init()&#123; v.clear(); for(int i=0; i&lt;=30; i++) &#123; for(int j=0; j&lt;=30; j++) &#123; for(int k=0; k&lt;=30; k++) &#123; for(int l=0; l&lt;=30; l++) &#123; ll tem=qpow(2,i); if(tem&gt;1e9) break; tem*=qpow(3,j); if(tem&gt;1e9) break; tem*=qpow(5,k); if(tem&gt;1e9) break; tem*=qpow(7,l); if(tem&gt;1e9) break; v.push_back(tem); &#125; &#125; &#125; &#125; sort(v.begin(),v.end());&#125;int main()&#123; init(); int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,*lower_bound(v.begin(),v.end(),x)); &#125;&#125; B:$该级数收敛于 \\pi^2/6,对1000万以下的询问预处理即可。$ 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const double PI=acos(-1.0);double a[1000000+5];string str;int init(string s)&#123; int res=0,len=s.length(),w=1; for(int i=len-1;i&gt;=0;i--) &#123; res+=(s[i]-&apos;0&apos;)*w; w*=10; &#125; return res;&#125;void init()&#123; for(int i=1;i&lt;=1000000;i++) &#123; a[i]=a[i-1]+1.0/(1.0*i*i); &#125;&#125;int main()&#123; init(); while(cin&gt;&gt;str) &#123; if(str.length()&gt;=7) printf(&quot;%.5f\\n&quot;,PI*PI/6); else &#123; int value=init(str); printf(&quot;%.5f\\n&quot;,a[value]); &#125; &#125;&#125; E:$当(n * (n-1)/2) \\mod 2=0时游戏平衡 \\\\所以n是偶数游戏就平衡。$ 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if(x&amp;1) puts(&quot;Balanced&quot;); else puts(&quot;Bad&quot;); &#125;&#125; F:$先判图是否连通。因为异或满足交换律,所以如果是欧拉通路 \\\\答案是定值,如果是欧拉回路那就枚举起点，因为起点会被多 \\\\算一次，否则答案都是NO。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=5e5+5;int t,n,m,u,v,ans;int a[maxn],deg[maxn],cnt[maxn],f[maxn];int Find(int a)&#123; return f[a]==a?a:f[a]=Find(f[a]);&#125;void join(int a,int b)&#123; int pa=Find(a),pb=Find(b); if(pa!=pb) f[pb]=pa;&#125;void init()&#123; for(int i=1; i&lt;=n; i++) &#123; f[i]=i; deg[i]=cnt[i]=0; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); ans=0; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); deg[u]++; deg[v]++; join(u,v); &#125; int _cnt=0; for(int i=1; i&lt;=n; i++) &#123; cnt[i]=(deg[i]+1)/2; if(f[i]==i) _cnt++; &#125; if(_cnt!=1) &#123; puts(&quot;Impossible&quot;); continue; &#125; _cnt=0; for(int i=1; i&lt;=n; i++) &#123; if(deg[i]&amp;1) _cnt++; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=cnt[i]; j++) ans^=a[i]; &#125; if(_cnt==2) &#123; printf(&quot;%d\\n&quot;,ans); continue; &#125; if(_cnt==0) &#123; int tem=ans; ans^=a[1]; for(int i=2; i&lt;=n; i++) ans=max(ans,tem^a[i]); printf(&quot;%d\\n&quot;,ans); continue; &#125; puts(&quot;Impossible&quot;); &#125;&#125; K:$先跑spfa抠出最短路，然后在最短路上跑最大流即可。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e3+5;const int maxm=1e4+5;const int inf=1e9;int cnt,s,t,n,m;int head[maxn],dep[maxn],cur[maxn],dis[maxn],inq[maxn];int g[maxn][maxn],e[maxn][maxn];struct Edge&#123; int nex,to,w;&#125; edge[2*maxm];void add_edge(int u,int v,int w)&#123; edge[++cnt].nex=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;void init()&#123; memset(head,-1,sizeof(head)); memset(dep,0,sizeof(dep)); memset(cur,0,sizeof(cur)); memset(inq,0,sizeof(inq)); memset(g,0,sizeof(g)); memset(e,0,sizeof(e)); cnt=-1;&#125;bool bfs()&#123; queue&lt;int&gt;que; memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if((dep[v]==0)&amp;&amp;edge[i].w&gt;0) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;(edge[i].w!=0)) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=n; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;void spfa(int s)&#123; fill(dis,dis+1+n,1e9); memset(inq,0,sizeof(inq)); queue&lt;int&gt;que; que.push(s); inq[s]=1; dis[s]=0; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=0; for(int v=1; v&lt;=n; v++) &#123; int w=g[u][v]; if(!w) continue; if(dis[v]&gt;dis[u]+w) &#123; dis[v]=dis[u]+w; if(!inq[v]) &#123; inq[v]=1; que.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; //起点是1 终点是n int time; scanf(&quot;%d&quot;,&amp;time); while(time--) &#123; init(); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); g[a][b]=1; g[b][a]=1; e[a][b]=e[b][a]=c; &#125; spfa(1); for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(dis[j]-dis[i]==1&amp;&amp;e[i][j]!=0) add_edge(i,j,e[i][j]),add_edge(j,i,0); &#125; &#125; s=1,t=n; cout&lt;&lt;Dinic()&lt;&lt;endl; &#125; return 0;&#125; D:$对R \\le 1, R \\le 2, (R-L) \\le 2,L=0分开讨论 \\\\其它情况都有一种最优策略。$ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; ll l,r; while(~scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r)) &#123; if(r&lt;=1) &#123; puts(&quot;0&quot;); continue; &#125; if(r&lt;=2) &#123; puts(&quot;1&quot;); continue; &#125; if(r-l&lt;=2) &#123; puts(&quot;2&quot;); continue; &#125; if(l==0) &#123; ll ans=(r-3)/2+2; printf(&quot;%lld\\n&quot;,ans); continue; &#125; else &#123; ll ans=2; if((r-l-2)&amp;1) ans+=(r-l-3)/2; else ans+=(r-l-2)/2; printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125; L:$二分+优先队列的做法会被卡常,做些预处理可以水过， \\\\正解是利用单调性模拟优先队列优化掉一个log。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;#define ll long longint n;ll cost;ll num[maxn];ll pre[maxn];bool check(int x)&#123; priority_queue&lt; ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;q; ll ans=0,sum=0; ll d=(n-1)%(x-1)+1; if(d&gt;1) &#123; ans=pre[d]; q.push(pre[d]); for(int i=d+1; i&lt;=n; i++) q.push(num[i]); &#125; else &#123; for(int i=1; i&lt;=n; i++) q.push(num[i]); &#125; while(!q.empty()) &#123; sum=0; for(int i=1; i&lt;=x; i++) &#123; sum+=q.top(); q.pop(); &#125; ans+=sum; if(ans&gt;cost) return false; if(!q.empty()) q.push(sum); &#125; if(ans&lt;=cost) return true; else return false;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%lld&quot;,&amp;n,&amp;cost); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%lld&quot;,&amp;num[i]); &#125; sort(num+1,num+1+n); pre[1]=num[1]; for(int i=2; i&lt;=n; i++) pre[i]=pre[i-1]+num[i]; int l=2,r=n; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) r=mid; else l=mid+1; &#125; printf(&quot;%d\\n&quot;,l); &#125;&#125; L:$本质不同的排列远小于询问数量，所以先预处理，预处理时用 \\\\bitset加速01背包。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint num[60];int ans[55][55][55];int tem[5];int t,n,q;bitset&lt;90&gt;b[15];void read(ll&amp; x)&#123; int f = 1; x = 0; char ch = getchar(); while (ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123; if (ch == &apos;-&apos;) f = -1; ch = getchar(); &#125; while (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) &#123; x = x * 10 + ch - &apos;0&apos;; ch = getchar(); &#125; x *= f;&#125;void read(int&amp; x)&#123; int f = 1; x = 0; char ch = getchar(); while (ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123; if (ch == &apos;-&apos;) f = -1; ch = getchar(); &#125; while (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) &#123; x = x * 10 + ch - &apos;0&apos;; ch = getchar(); &#125; x *= f;&#125;///--------------head--------------------///inline void solve(int x,int y,int z)&#123; for(int i=0; i&lt;=11; i++) b[i].reset(); b[0][0]=1; for(int i=1; i&lt;=n; i++) &#123; if(num[i]&gt;87||i==x||i==y||i==z) continue; for(int j=10; j&gt;=1; j--) b[j]|=b[j-1]&lt;&lt;num[i]; &#125; if(b[10][87]==1) ans[x][y][z]=1;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(ans,0,sizeof(ans)); read(n); for(int i=1; i&lt;=n; i++) read(num[i]); for(int i=1; i&lt;=n; i++) for(int j=i; j&lt;=n; j++) for(int k=j; k&lt;=n; k++) &#123; solve(i,j,k); &#125; read(q); while(q--) &#123; read(tem[1]),read(tem[2]),read(tem[3]); sort(tem+1,tem+4); if(ans[tem[1]][tem[2]][tem[3]]) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125;&#125;","path":"2019/02/05/2016-ICPC-青岛站/"},{"title":"Bzoj 1026 windy数","text":"描述:求区间里满足相邻数位差值的绝对值不小于2的数的个数。 思路:$数位dp,对有无前导0分情况讨论。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/************************************************************** Problem: 1026 User: Decaku Language: C++ Result: Accepted Time:48 ms Memory:1288 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;int dp[15][15];void init()&#123; for(int i=0; i&lt;=9; i++) dp[1][i]=1; for(int i=2; i&lt;=10; i++) for(int j=0; j&lt;=9; j++) for(int k=0; k&lt;=9; k++) &#123; if(abs(j-k)&gt;=2) dp[i][j]+=dp[i-1][k]; &#125;&#125; int query(int x)&#123; int d[15]= &#123;&#125;,cnt=0,ret=0; while(x) &#123; d[++cnt]=x%10; x/=10; &#125; for(int i=1; i&lt;cnt; i++) for(int j=1; j&lt;10; j++) ret+=dp[i][j]; for(int i=1; i&lt;d[cnt]; i++) ret+=dp[cnt][i]; for(int i=cnt-1; i&gt;=1; i--) &#123; for(int j=0; j&lt;d[i]; j++) &#123; if(abs(j-d[i+1])&gt;=2) ret+=dp[i][j]; &#125; if(abs(d[i]-d[i+1])&lt;2) break; &#125; return ret;&#125; int main()&#123; init(); int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,query(b+1)-query(a));&#125;","path":"2019/02/05/Bzoj-1026-windy数/"},{"title":"Edu Codeforces Round 53","text":"A:扫描长度为2的字符串就好。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int a[30];int main()&#123; bool flag=true; int n; string str; cin&gt;&gt;n; cin&gt;&gt;str; for(int i=0;i&lt;n-1;i++) &#123; if(str[i]!=str[i+1]) &#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; cout&lt;&lt;str[i]&lt;&lt;str[i+1]&lt;&lt;endl; flag=false; break; &#125; &#125; if(flag) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; B:用栈模拟。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int a[30];int main()&#123; bool flag=true; int n; string str; cin&gt;&gt;n; cin&gt;&gt;str; for(int i=0;i&lt;n-1;i++) &#123; if(str[i]!=str[i+1]) &#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; cout&lt;&lt;str[i]&lt;&lt;str[i+1]&lt;&lt;endl; flag=false; break; &#125; &#125; if(flag) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; C:$先记录两个数组a,b,a_i表示从起点开始i条指令能到达的位置,b_i \\\\记录从终点开始对i条指令反向后能够到达的位置。二分修改 \\\\区间的长度,所以区间左端点扫描,对区间右端点二分,check的时 \\\\候只要根据区间长度是否比区间首尾的曼哈顿距离大且差值是偶 \\\\数来二分即可,复杂度是nlog(n)。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 200005char str[maxn];struct Point&#123; int x,y;&#125; s[maxn],e[maxn];int main()&#123; int n,x,y; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,str); scanf(&quot;%d %d&quot;,&amp;x,&amp;y); if((abs(x)+abs(y))&gt;n||(n-abs(x)-abs(y))%2!=0) printf(&quot;%d\\n&quot;,-1); else &#123; int s_x=0,s_y=0; s[0].x=0,s[0].y=0; for(int i=0; i&lt;n; i++) &#123; if(str[i]==&apos;U&apos;) s_y++, s[i+1].x=s_x, s[i+1].y=s_y; if(str[i]==&apos;D&apos;) s_y--, s[i+1].x=s_x, s[i+1].y=s_y; if(str[i]==&apos;L&apos;) s_x--, s[i+1].x=s_x, s[i+1].y=s_y; if(str[i]==&apos;R&apos;) s_x++, s[i+1].x=s_x, s[i+1].y=s_y; &#125; if(s[n].x==x&amp;&amp;s[n].y==y) printf(&quot;0\\n&quot;); else &#123; s_x=x,s_y=y; e[0].x=x,e[0].y=y; int cnt=0; for(int i=n-1; i&gt;=0; i--) &#123; if(str[i]==&apos;U&apos;) s_y--, e[++cnt].x=s_x, e[cnt].y=s_y; if(str[i]==&apos;D&apos;) s_y++, e[++cnt].x=s_x, e[cnt].y=s_y; if(str[i]==&apos;L&apos;) s_x++, e[++cnt].x=s_x, e[cnt].y=s_y; if(str[i]==&apos;R&apos;) s_x--, e[++cnt].x=s_x, e[cnt].y=s_y; &#125; int ans=1e9; for(int i=1; i&lt;=n; i++) &#123; int l=i,r=n,mid; while(l&lt;r) &#123; int mid=(l+r)/2; int p_x=s[i-1].x,p_y=s[i-1].y; int q_x=e[n-mid].x,q_y=e[n-mid].y; int dis=abs(p_x-q_x)+abs(p_y-q_y); if(mid-i+1&gt;=dis&amp;&amp;(mid-i+1-dis)%2==0) r=mid; else l=mid+1; &#125; int p_x=s[i-1].x,p_y=s[i-1].y; int q_x=e[n-l].x,q_y=e[n-l].y; int dis=abs(p_x-q_x)+abs(p_y-q_y); if(l-i+1&gt;=dis&amp;&amp;(l-i+1-dis)%2==0) ans=min(ans,l-i+1); &#125; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125; D:经过一次循环以后可以取模,所以可以暴力莽过去。 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=2e5+5;ll n,t,ans,sum,_;int a[maxn];int main()&#123; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;t); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); while(1) &#123; ll tem=t,cnt=0,sum=0; for(int i=1;i&lt;=n;i++) &#123; if(tem&gt;=a[i]) &#123; cnt++; tem-=a[i]; sum+=a[i]; &#125; &#125; if(cnt==0) break; ans+=t/sum*cnt; t%=sum; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; 未完待续。。。","path":"2019/02/05/Edu-Codeforces-Round-53/"},{"title":"Codeforces Round #519 Div2","text":"A:签到题。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int sum,n,tem,mx;int main()&#123; scanf(&quot;%d&quot;,&amp;n); mx=-1; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;tem); mx=max(tem,mx); sum+=tem; &#125; int ans=max((2*sum)/n+1,mx); printf(&quot;%d\\n&quot;,ans);&#125; B:差分数组后就是求字符串可能的循环节长度，暴力。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[1005],b[1005],ans[1005],_ans;int main()&#123; scanf(&quot;%d&quot;,&amp;n); a[0]=0; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) b[i]=a[i]-a[i-1]; for(int i=1;i&lt;=n;i++) &#123; bool ok=true; for(int j=i+1;j&lt;=n;j+=i) &#123; for(int k=j;k&lt;=j+i-1&amp;&amp;k&lt;=n;k++) &#123; if(b[k]!=b[k-i]) &#123; ok=false; break; &#125; &#125; if(!ok) break; &#125; if(ok) ans[++_ans]=i; &#125; printf(&quot;%d\\n&quot;,_ans); for(int i=1;i&lt;=_ans;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n&quot;);&#125; C:$操作完了以后一定可以让所有a在b的前面,所以假设 \\\\前i长的字符串已经是最小字典序了,那么如果第i+1个 \\\\字符是a,前i个字符就要倒过来,再反转前i+1个字符. \\\\$ 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int ans[1005];int main()&#123; string str; cin&gt;&gt;str; for(int i=1;i&lt;str.size();i++) &#123; if(str[i]==&apos;a&apos;) ans[i-1]^=1, ans[i]^=1; &#125; for(int i=0;i&lt;str.size()-1;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;%d\\n&quot;,ans[str.size()-1]);&#125; D:$预处理一个a数组,a_i=j代表在所有字符串中i的后一个字符 \\\\都是j,然后根据a数组建一棵树,在树上统计每一条链上的结点 \\\\个数就行。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int a[maxn],head[maxn],vis[maxn];int n,m,tem,pre,cnt;struct Edge&#123; int to,nex;&#125; edge[2*maxn];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt; edge[++cnt].to=u; edge[cnt].nex=head[v]; head[v]=cnt;&#125;int dfs(int u)&#123; vis[u]=1; int ret=0; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(vis[v]) continue; ret+=dfs(v)+1; &#125; return ret;&#125;int main()&#123; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d&quot;,&amp;pre); for(int j=2; j&lt;=n; j++) &#123; scanf(&quot;%d&quot;,&amp;tem); if(a[pre]==0) a[pre]=tem; else if(a[pre]!=tem) a[pre]=-1; pre=tem; &#125; a[pre]=-1; &#125; for(int i=1; i&lt;=n; i++) &#123; if(a[i]!=-1) add_edge(i,a[i]); &#125; long long ans=0; for(int i=1; i&lt;=n; i++) &#123; if(!vis[i]) &#123; int tem =dfs(i)+1+1; ans+=1ll*tem*(tem-1)/2; &#125; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; 未完待续。。。","path":"2019/02/05/Codeforces Round 519/"},{"title":"Bzoj 1257 余数之和","text":"描述:$求\\sum _{i=1}^nk \\mod i, i \\le n,k \\le (10)^9$ 思路:$原式=\\sum _{i=1}^n(k-k/i * i)=n * k-\\sum _{i=1}^n(k/i*i) \\\\k/i只有 \\sqrt k个，所以可以整除分块。 \\\\复杂度是 \\sqrt n。$ 12345678910111213141516171819202122232425262728/************************************************************** Problem: 1257 User: Decaku Language: C++ Result: Accepted Time:72 ms Memory:1288 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n,k,sum;int main()&#123; ll ans=0; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;k); sum=n*k; if(n&gt;k) n=k; for(ll l=1,r; l&lt;=n; l=r+1) &#123; r=k/(k/l); if(r&gt;n) r=n; ll tem=r*(r+1)/2-(l-1)*l/2; ans+=tem*(k/l); &#125; printf(&quot;%lld\\n&quot;,sum-ans);&#125;","path":"2019/02/05/Bzoj-1257-余数之和/"},{"title":"Poj2796 Feel Good","text":"描述:$一串数字序列,定义value为某一区间的最小值乘该区间的和, \\\\再除以区间长度,求最大的value。 $ 思路:$预处理a_i为最小值时的区间,使用单调栈从前向后和 \\\\从后向前扫描两次。 $ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;using namespace std;#define ll long long#define maxn 100005ll st[maxn],top;ll a[maxn],sum[maxn],l[maxn],r[maxn];int main()&#123; top=0; int n; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%lld&quot;,&amp;a[1]); sum[0]=0; sum[1]=a[1]; for(int i=2; i&lt;=n; i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; st[top++]=1; l[1]=1; for(int i=2; i&lt;=n; i++) &#123; while(top&amp;&amp;a[st[top-1]]&gt;=a[i]) &#123; top--; &#125; if(!top) l[i]=1; else l[i]=st[top-1]+1; st[top++]=i; &#125; top=0; st[top++]=n; r[n]=n; for(int i=n-1; i&gt;=1; i--) &#123; while(top&amp;&amp;a[st[top-1]]&gt;=a[i]) &#123; top--; &#125; if(!top) r[i]=n; else r[i]=st[top-1]-1; st[top++]=i; &#125; ll ans=-1; ll _l,_r; for(int i=1; i&lt;=n; i++) &#123; if((a[i])*(sum[r[i]]-sum[l[i]-1])&gt;ans) &#123; ans=(a[i])*(sum[r[i]]-sum[l[i]-1]); _l=l[i]; _r=r[i]; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); printf(&quot;%lld %lld\\n&quot;,_l,_r);&#125;","path":"2019/02/05/Poj2796-Feel-Good/"},{"title":"Poj4045 Power Station","text":"描述:找到树上一个结点,树上其它结点与它距离之和最小。 思路:$枚举每一条树边,儿子的值可以由父亲转移过来, \\\\统计完所有结点以后比较即可。所以需要做两遍dfs, \\\\第一遍统计每个结点子树的数量和根节点的值。 \\\\第二遍dfs更新其它结点的值。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+5;const int inf=1e9;vector&lt;int&gt;ans;struct Edge&#123; int to,nex;&#125; edge[maxn*2];int head[maxn],cnt,siz[maxn],dis[maxn],tem;int n,I,R;void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs1(int u,int f,int dep)&#123; siz[u]=1; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==f) continue; tem+=dep; dfs1(v,u,dep+1); siz[u]+=siz[v]; &#125;&#125;void dfs2(int u,int f)&#123; if(u!=1) dis[u]=dis[f]-siz[u]+n-siz[u]; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==f) continue; dfs2(v,u); &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ans.clear(); memset(head,-1,sizeof(head)); cnt=-1; tem=0; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;I,&amp;R); for(int i=1; i&lt;n; i++) &#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); &#125; dfs1(1,0,1); dis[1]=tem; dfs2(1,0); int mi=inf; for(int i=1; i&lt;=n; i++) &#123; if(dis[i]&lt;mi) &#123; mi=dis[i]; ans.clear(); ans.push_back(i); &#125; else if(dis[i]==mi) ans.push_back(i); &#125; printf(&quot;%lld\\n&quot;,1ll*mi*I*I*R); printf(&quot;%d&quot;,ans[0]); for(int i=1; i&lt;ans.size(); i++) printf(&quot; %d&quot;,ans[i]); printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); &#125;&#125;","path":"2019/02/05/Poj4045-Power-Station/"},{"title":"Hdu1520 Anniversary party","text":"描述:从树上选择一些结点,使被选择的结点的权值和最大,儿子与父亲结点最多选一个。 思路:$设dp[0][i],表示以i为根节点,且i结点不选能取得的最大值, \\\\dp[1][i]表示以i为根节点且i结点选择的最大值,答案为 \\\\max\\{dp[0][1],dp[1][1]\\}。 \\\\转移方程是 dp[0][u]=dp[0][u]+max\\{dp[1][v],dp[0][v]\\}; \\\\dp[1][u]+=dp[0][v]; 其中v是u的儿子。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=6000+10;int head[maxn],cnt,value[maxn];int dp[2][maxn];struct Edge&#123; int to,nex;&#125; edge[maxn*2];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int f)&#123; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==f) continue; dfs(v,u); dp[0][u]=dp[0][u]+max(dp[1][v],dp[0][v]); dp[1][u]+=dp[0][v]; &#125;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; memset(head,-1,sizeof(head)); cnt=-1; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;value[i]); int u,v; while(~scanf(&quot;%d %d&quot;,&amp;u,&amp;v)) &#123; if(!u&amp;&amp;!v) break; add_edge(u,v); add_edge(v,u); &#125; memset(dp[0],0,sizeof(dp[0])); for(int i=1; i&lt;=n; i++) dp[1][i]=value[i]; dfs(1,0); printf(&quot;%d\\n&quot;,max(dp[0][1],dp[1][1])); &#125;&#125;","path":"2019/02/05/Hdu1520-Anniversary-party/"},{"title":"Codeforces Round #514 (Div. 2)","text":"A:$模拟时特判一下n为0即可$ 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n,l,a,ans;int main()&#123; ans=0; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;l,&amp;a); if(n==0) ans=l/a; else &#123; int s,t,_; scanf(&quot;%d %d&quot;,&amp;s,&amp;t); ans+=s/a; _=s+t; for(int i=2; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;s,&amp;t); ans+=(s-_)/a; _=s+t; &#125; ans+=(l-_)/a; &#125; printf(&quot;%d\\n&quot;,ans);&#125; B:对地图染色以后暴力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;char mp[1005][1005];bool vis[1005][1005];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof(vis)); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=m; j++) cin&gt;&gt;mp[i][j]; for(int i=2; i&lt;=n-1; i++) for(int j=2; j&lt;=m-1; j++) &#123; if(mp[i-1][j-1]==&apos;.&apos;||mp[i-1][j]==&apos;.&apos;||mp[i-1][j+1]==&apos;.&apos;||mp[i][j-1]==&apos;.&apos;||mp[i][j+1]==&apos;.&apos; ||mp[i+1][j-1]==&apos;.&apos;||mp[i+1][j]==&apos;.&apos;||mp[i+1][j+1]==&apos;.&apos;) continue; else &#123; vis[i-1][j-1]=1; vis[i-1][j]=1; vis[i-1][j+1]=1; vis[i][j-1]=1; vis[i][j+1]=1; vis[i+1][j-1]=1; vis[i+1][j]=1; vis[i+1][j+1]=1; &#125; &#125; bool ans=true; for(int i=1; i&lt;=n; i++) &#123; if(ans==false) break; for(int j=1; j&lt;=m; j++) &#123; if((mp[i][j]==&apos;#&apos;&amp;&amp;!vis[i][j])||(mp[i][j]==&apos;.&apos;&amp;&amp;vis[i][j])) &#123; ans=false; break; &#125; &#125; &#125; if(ans) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0;&#125; C:$采取贪心策略尽早使gcd比1大,又相邻的奇数和偶数 \\\\一定互素,所以先删奇数，剩下偶数不断除2变成奇数 \\\\删掉，递归即可$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int ans[maxn],ans_;int seq[maxn];void solve(int n,int t)&#123; if(n==1) &#123; ans[ans_++]=t; return; &#125; if(n==2) &#123; ans[ans_++]=t; ans[ans_++]=t*2; return; &#125; if(n==3) &#123; ans[ans_++]=t; ans[ans_++]=t; ans[ans_++]=3*t; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if(seq[i]&amp;1) ans[ans_++]=t; &#125; for(int i=1;i&lt;=n/2;i++) &#123; seq[i]=seq[i*2]/2; &#125; solve(n/2,t*2);&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) seq[i]=i; solve(n,1); for(int i=0;i&lt;ans_-1;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;%d\\n&quot;,ans[ans_-1]);&#125; 未完待续。。。","path":"2019/02/05/Codeforces-Round-514-Div-2/"},{"title":"Codeforces Round #513 Div1+Div2","text":"A:签到题。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;string str;int main()&#123; int n; cin&gt;&gt;n; cin&gt;&gt;str; int cnt=0; for(int i=0;i&lt;n;i++) &#123; if(str[i]==&apos;8&apos;) cnt++; &#125; cnt=min(cnt,n/11); cout&lt;&lt;cnt&lt;&lt;endl;&#125; B:$ 考虑从n的最低位开始更新答案，如果最低位小于等于8, \\\\就从下一位拿1过来，ans+10。$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll solve(ll n)&#123; ll ans=0; while(n)&#123; int d=n%10; n/=10; if(d&lt;=8&amp;&amp;n)&#123; d=10; n--; &#125; ans+=d; &#125; return ans;&#125;int main()&#123; ll n; while(cin&gt;&gt;n)&#123; cout&lt;&lt;solve(n)&lt;&lt;endl; &#125;&#125; C:$ C矩阵的每一个子矩阵的和都是数组A和B的一个连续子段和相乘所得。 \\\\所以可以考虑预处理A和B的所有连续子段和，然后把B的子段和按从小 \\\\到大排序，每次枚举A的一个子段和a,可以在B的子段和里二分找x/a。 \\\\然后就是询问子段和在0-x/a里最长的一段是多少，这个询问可以预处 \\\\理，询问的时候是O(1)。所以总的复杂度是O(n^2log(n))。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2005;int a[maxn],b[maxn];int n,m,cnta,cntb;int suma[maxn],sumb[maxn];struct node&#123; int len,w; bool operator &lt;(const node&amp;other)const&#123; return w&lt;other.w; &#125;;&#125;nodea[maxn*(maxn+1)/2],nodeb[maxn*(maxn+1)/2];int lenb[maxn*(maxn+1)/2];inline void ini()&#123; for(int i=1;i&lt;=n;i++)suma[i]=suma[i-1]+a[i]; for(int i=1;i&lt;=m;i++)sumb[i]=sumb[i-1]+b[i]; cnta=cntb=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=i;j&lt;=n;j++)&#123; nodea[cnta].len=j-i+1; nodea[cnta].w=suma[j]-suma[i-1]; cnta++; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=i;j&lt;=m;j++)&#123; nodeb[cntb].len=j-i+1; nodeb[cntb].w=sumb[j]-sumb[i-1]; cntb++; &#125; &#125; sort(nodeb,nodeb+cntb); for(int i=0;i&lt;cntb;i++)lenb[i]=max(lenb[i-1],nodeb[i].len); &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=m;i++)scanf(&quot;%d&quot;,b+i); int x;cin&gt;&gt;x; ini(); int ans=0; for(int i=0;i&lt;cnta;i++)&#123; int t=upper_bound(nodeb,nodeb+cntb,node&#123;0,x/nodea[i].w&#125;)-1-nodeb; ans=max(ans,lenb[t]*nodea[i].len); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 未完待续。。。","path":"2019/02/05/Codeforces-Round-513-Div1-Div2/"},{"title":"Codeforces #512 div2","text":"A:签到题。 B:判断点是否在矩形内,利用外积即可。 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int n,d,m;int main()&#123; cin&gt;&gt;n&gt;&gt;d; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; int _1=(n-d)*(y-d)-(n-d)*x; int _2=(d-n)*(y-n+d)-(d-n)*(x-n); int _3=(-d)*y-d*(x-d); int _4=d*(y-n)-(-d)*(x-n+d); if(_1*_2&gt;=0&amp;&amp;_3*_4&gt;=0) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;&#125; C:暴力。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n;string a;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;a; int sum=0; string str=&quot;&quot;; for(int i=0; i&lt;n; i++) &#123; if(a[i]!=&apos;0&apos;) str+=a[i]; sum+=a[i]-&apos;0&apos;; &#125; bool ok=true; bool flag=false; for(int i=1; i&lt;=sum; i++) &#123; int tem=0; int cnt=0; ok=true; for(int j=0; j&lt;str.length(); j++) &#123; tem+=str[j]-&apos;0&apos;; if(tem&gt;i) &#123; ok=false; break; &#125; if(tem==i) &#123; tem=0; cnt++; if(j==str.length()-1) flag=true; continue; &#125; &#125; if(ok&amp;&amp;cnt&gt;1&amp;&amp;flag) &#123; break; &#125; if(!flag) ok=false; if(cnt==1) ok=false; &#125; if(ok) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; D:$由皮克定理可知，该三角形底乘高为整数 \\\\则有2m/k \\le b \\le m \\\\2n/k \\le a \\le n \\\\观察2n/k，因为k \\ge 2,令t=gcd(2n,k) \\\\若t \\ge 2,令a=2n/t,若t=1,令a=n。 $ 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;long long n,m,k;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; if(2*n*m%k!=0) &#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; &#125; int t=__gcd(2*n,k); int a=2*n/t; int b=m*t/k; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; if(t!=1) &#123; cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;2*m/k&lt;&lt;endl; &#125; return 0;&#125; 未完待续。。。","path":"2019/02/05/Codeforces-512-div2/"},{"title":"Codeforces Round＃498 E","text":"描述:$给出一个有根树，多组询问，求编号为u的结点的dfs序的第k个儿子。$ 思路:$dfs预处理树上一些信息乱搞就行了。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 2e5+10;queue&lt;int&gt;que[maxn];int a[maxn],b[maxn],sum[maxn];////a存dfs序号,b存序号对应的结点编号int cnt1=1;void dfs(int k)&#123; int cnt2=0; while(que[k].empty()==false) &#123; int t=que[k].front(); cnt2++; que[k].pop(); cnt1++; a[t]=cnt1; b[cnt1]=t; dfs(t); cnt2+=sum[t]; &#125; sum[k]+=cnt2; return;&#125;int main()&#123; memset(sum,0,sizeof(sum)); int n,q,tem,x,y; cin&gt;&gt;n&gt;&gt;q; for(int i=1; i&lt;n; i++) &#123; cin&gt;&gt;tem; que[tem].push(i+1); &#125; dfs(1); a[1]=1; b[1]=1; while(q--) &#123; cin&gt;&gt;x&gt;&gt;y; if(sum[x]+1&lt;y) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;b[a[x]+y-1]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/05/Codeforces-Round＃498（Div-3）E/"},{"title":"Codeforces #511 div2 D. Bicolorings","text":"描述:$ 有个2行n列的格子图,用2种颜色给格子涂色,相邻格子颜色 \\\\不能相同,求不同的染色方案数。$ 思路:$类似状压dp的思路，只有两行，所以每一列只有4个状态, \\\\所以可以考虑枚举每一列，这样复杂度是O(n^4)，n只有1000, \\\\题目又要求把方格分成k个连通块，我们在dp中再加一维即可, \\\\k最大是2n的，所以最多做8 * (10)^6次循环。$ 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=998244353;long long dp[5][1100][2100];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; memset(dp,0,sizeof(dp)); dp[0][1][1]=1; dp[1][1][1]=0; dp[2][1][1]=0; dp[3][1][1]=1; dp[0][1][2]=0; dp[1][1][2]=1; dp[2][1][2]=1; dp[3][1][2]=0; for(int j=2; j&lt;=n; j++) for(int i=0; i&lt;=3; i++) for(int t=1; t&lt;=k; t++) &#123; if(i==0) dp[i][j][t]=(dp[0][j-1][t]+dp[1][j-1][t]+dp[2][j-1][t]+dp[3][j-1][t-1])%mod; else if(i==1) dp[i][j][t]=(dp[0][j-1][t-1]+dp[1][j-1][t]+dp[2][j-1][t-2]+dp[3][j-1][t-1])%mod; else if(i==2) dp[i][j][t]=(dp[0][j-1][t-1]+dp[1][j-1][t-2]+dp[2][j-1][t]+dp[3][j-1][t-1])%mod; else dp[i][j][t]=(dp[0][j-1][t-1]+dp[1][j-1][t]+dp[2][j-1][t]+dp[3][j-1][t])%mod; &#125; cout&lt;&lt;(dp[0][n][k]+dp[1][n][k]+dp[2][n][k]+dp[3][n][k])%mod&lt;&lt;endl;&#125;","path":"2019/02/05/Codeforces-511-div2-D-Bicolorings/"},{"title":"Hdu1005 Number Sequence","text":"描述:$ f(1)=1, f(2)=1, f(n) = (A * f(n - 1) + B * f(n - 2)) \\mod 7. \\\\然后计算f(n),n很大。$ 找循环节，循环节长度最大是49，但是发现前几项可能不出现在循环节里，所以舍弃前50项即可。 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int x,y,n,tem;int ans[100];int main()&#123; while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;n&amp;&amp;(x+y+n)) &#123; ans[1]=ans[2]=1; for(int i=3; i&lt;=100; i++) ans[i]=(ans[i-1]*x+ans[i-2]*y)%7; int a=ans[50]; int b=ans[51]; for(int i=52; i&lt;=99; i++) if(ans[i]==a&amp;&amp;ans[i+1]==b) &#123; tem=i; break; &#125; if(n&lt;50) cout&lt;&lt;ans[n]&lt;&lt;endl; else cout&lt;&lt;ans[(n-49)%(tem-50)+49]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/05/Hdu1005-Number-Sequence/"},{"title":"Hdu 6440 Dream","text":"描述:$重新定义加法和乘法，使得对于p是素数时(a+b)^{p}=a^{p}+b^{p}。$ 思路:$根据费马小定理有x^{p-1}与1在模p的意义下同余(p是素数)。 \\\\ 于是做如下定义：a+b=(a+b) \\mod p \\\\ ab=ab \\mod p \\\\ 易证 (a+b)^{p}=a^{p}+b^{p}=(a+b) \\mod p $ 12345678910111213141516171819202122232425262728293031323334include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;using namespace std;int t,p;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;p); for(int i=1; i&lt;=p; i++) &#123; for(int j=1; j&lt;=p; j++) &#123; printf(&quot;%d &quot;,((i-1)%p+(j-1)%p)%p); &#125; printf(&quot;\\n&quot;); &#125; for(int i=1; i&lt;=p; i++) &#123; for(int j=1; j&lt;=p; j++) &#123; printf(&quot;%d &quot;,((i-1)%p*(j-1)%p)%p); &#125; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125;","path":"2019/02/04/Hdu-6440-Dream/"},{"title":"2018Hdu暑期多校3 L Visual Cube","text":"描述:打印一个长方体。 思路:有意思的模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;char m[85][85];int main()&#123; int t,a,b,c,tem; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); int A=2*a+1+2*b; int B=2*b+2*c+1; for(int i=1; i&lt;=2*b; i++) for(int j=1; j&lt;=2*b-i+1; j++) m[i][j]=&apos;.&apos;; int k=A; for(int i=2*c+2; i&lt;=B; i++) &#123; for(int j=k; j&lt;=A; j++) &#123; m[i][j]=&apos;.&apos;; &#125; k--; &#125; for(int i=2*b+1; i&lt;=B; i+=2) for(int j=1; j&lt;=2*a+1; j++) &#123; if(j%2==1) m[i][j]=&apos;+&apos;; else m[i][j]=&apos;-&apos;; &#125; for(int i=2*b+2; i&lt;=B-1; i+=2) for(int j=1; j&lt;=2*a+1; j++) &#123; if(j%2==1) m[i][j]=&apos;|&apos;; else m[i][j]=&apos;.&apos;; &#125; for(int i=1; i&lt;=2*b; i++) for(int j=2*b-i+2; j&lt;=2*b-i+2+2*a+1; j++) &#123; if(i%2==1&amp;&amp;j%2==1) m[i][j]=&apos;+&apos;; else if(i%2==1&amp;&amp;j%2==0) m[i][j]=&apos;-&apos;; else if(i%2==0&amp;&amp;j%2==1) m[i][j]=&apos;.&apos;; else m[i][j]=&apos;/&apos;; &#125; tem=B; for(int i=2*a+1; i&lt;=A; i++) &#123; for(int j=2*b+1+tem-B; j&lt;=tem; j++) &#123; if(i%2==1&amp;&amp;j%2==1) m[j][i]=&apos;+&apos;; else if(i%2==1&amp;&amp;j%2==0) m[j][i]=&apos;|&apos;; else if(i%2==0&amp;&amp;j%2==0)m[j][i]=&apos;/&apos;; else m[j][i]=&apos;.&apos;; &#125; tem--; &#125; for(int i=1; i&lt;=B; i++) &#123; for(int j=1; j&lt;=A; j++) &#123; cout&lt;&lt;m[i][j]; &#125; cout&lt;&lt;endl; &#125; &#125;&#125;","path":"2019/02/04/2018Hdu暑期多校3-L-Visual-Cube/"},{"title":"Poj1679 The Unique MST","text":"描述:判断最小生成树是否唯一。 思路:求次小生成树和最小生成树比较。 对边按照边权排序，边权相同按照边的序号升序排列，然后求最小生成树的边的集合。之后在边权相同时按照边的序号降序排列，又可以得到一组生成树中边的序号集合。如果集合不同说明生成树不唯一。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define M 107#define inf 0x3f3f3fusing namespace std;int g[M][M],path[M][M];int dist[M],pre[M],vis[M];bool used[M][M];int n,m,mst;void init()&#123; for(int i=0; i&lt;=n; i++) for(int j=i+1; j&lt;=n; j++) g[i][j]=g[j][i]=inf;&#125;int prime()&#123; int mst=0; memset(path,0,sizeof(path)); memset(vis,0,sizeof(vis)); memset(used,0,sizeof(used)); vis[1]=1; for(int i=1; i&lt;=n; i++) &#123; dist[i]=g[1][i]; pre[i]=1; &#125; for(int i=1; i&lt;n; i++) &#123; int u=-1; for(int j=1; j&lt;=n; j++) &#123; if(!vis[j]) if(u==-1||dist[j]&lt;dist[u]) u=j; &#125; used[u][pre[u]]=used[pre[u]][u]=true; mst+=g[pre[u]][u]; vis[u]=1; for(int j=1; j&lt;=n; j++) &#123; if(vis[j]&amp;&amp;j!=u) path[j][u]=path[u][j]=max(path[j][pre[u]],dist[u]); if(!vis[j]) if(dist[j]&gt;g[u][j]) &#123; dist[j]=g[u][j]; pre[j]=u; &#125; &#125; &#125; return mst;&#125;int second_tree()&#123; int res=inf; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) if(i!=j&amp;&amp;!used[i][j]) res=min(res,mst-path[i][j]+g[i][j]); return res;&#125;int main()&#123; int t,a,b,c; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); g[a][b]=g[b][a]=c; &#125; mst=prime(); int second_mst=second_tree(); if(mst!=second_mst) cout&lt;&lt;mst&lt;&lt;endl; else cout&lt;&lt;&quot;Not Unique!&quot;&lt;&lt;endl; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int ans;const int N=10000+1;struct edge&#123;int u,v,w,id;&#125;g[N];int f[N];//记得初始化int find(int a) &#123; return a == f[a]?a:f[a] = find(f[a]);&#125; //对边集排序后，对所有边调用join函数就可以得到最小生成树bool join(const edge &amp;e)&#123; if(find(e.u) !=find(e.v))&#123; f[find(e.u)] = find(e.v); ans+=e.w; return true;//ans =max(ans,e.w)，cnt++; &#125; return false;&#125;bool cmp1(edge a,edge b)&#123; if(a.w!=b.w)return a.w&lt;b.w; else return a.id&lt;b.id;&#125;bool cmp2(edge a,edge b)&#123; if(a.w!=b.w)return a.w&lt;b.w; else return a.id&gt;b.id;&#125;int main()&#123; int t; while(cin&gt;&gt;t)while(t--)&#123; int n,m,u,v,w; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;g[i].u&gt;&gt;g[i].v&gt;&gt;g[i].w; g[i].id=i; &#125; string state1,state2; ans=0; sort(g,g+n,cmp1); for(int i=0;i&lt;=n;i++)f[i]=i; for(int i=0;i&lt;m;i++)if(join(g[i]))state1.push_back(g[i].id); ans=0; sort(g,g+n,cmp2); for(int i=0;i&lt;=n;i++)f[i]=i; for(int i=0;i&lt;m;i++)if(join(g[i]))state2.push_back(g[i].id); if(state1!=state2)cout&lt;&lt;&quot;Not Unique!&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Poj1679-The-Unique-MST/"},{"title":"Poj 2299","text":"描述:求一段序列的逆序数对的个数。 思路:和归并排序思路类似,使用树状数组时注意稳定排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=5e5+5;typedef long long ll;int a[maxn];int c[maxn];ll ans;inline void solve(int l,int r)&#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid+1,r); int i=l,j=mid+1,k=l; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; if(a[i]&lt;=a[j]) c[k++]=a[i++]; else c[k++]=a[j++],ans+=mid-i+1; &#125; while(i&lt;=mid) c[k++]=a[i++]; while(j&lt;=r) c[k++]=a[j++]; for(int i=l; i&lt;=r; i++) a[i]=c[i];&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n&gt;0) &#123; ans=0; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); solve(1,n); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/Poj-2299/"},{"title":"Zoj3261 Connections in Galaxy War","text":"描述:$给n个点和m个边，点带权。然后给若干个操作，操作一是删边, \\\\操作二是询问这个点所在连通分量的代表点的编号。所以一个连 \\\\通分量里的代表点，它的权必须是最大的。$ 思路:$ 权最大的是代表点，所以在合并连通分量时以权大的为父亲, \\\\然后我们离线处理每个询问,用map维护。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;int p[10005],a[10005];struct query&#123; char str[10]; int p1,p2;////有2个参数&#125; tem;struct edge&#123; int u,v; bool operator &lt; (const edge &amp;a)const &#123; if(u==a.u) return v&lt;a.v; else return u&lt;a.u; &#125;&#125; e[20005],teme;int findset(int x)&#123; return x==p[x]?p[x]:p[x]=findset(p[x]);&#125;void join(int x,int y)&#123; int px=findset(x),py=findset(y); if(px!=py&amp;&amp;a[px]&gt;=a[py]) p[py]=px; if(px!=py&amp;&amp;a[px]&lt;a[py]) p[px]=py;&#125;int main()&#123; int n,m,aa,bb,q; bool flag=false; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(flag) cout&lt;&lt;endl; flag=true; stack&lt;int&gt;ans; stack&lt;query&gt;st; map&lt;edge,bool&gt;mp; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); p[i]=i; &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;aa,&amp;bb); e[i].u=min(aa,bb); e[i].v=max(aa,bb); mp[e[i]]=true; &#125; scanf(&quot;%d&quot;,&amp;q); for(int i=0; i&lt;q; i++) &#123; scanf(&quot;%s%d&quot;,&amp;tem.str,&amp;tem.p1); if(tem.str[0]==&apos;d&apos;) &#123; scanf(&quot;%d&quot;,&amp;tem.p2); teme.u=min(tem.p1,tem.p2),teme.v=max(tem.p1,tem.p2); mp[teme]=false; st.push(tem); &#125; else tem.p2=-1,st.push(tem); &#125; map&lt;edge, bool&gt;::iterator iter=mp.begin(); while(iter!=mp.end()) &#123; if(iter-&gt;second) &#123; join(iter-&gt;first.u,iter-&gt;first.v); &#125; iter++; &#125; while(!st.empty()) &#123; tem=st.top(); st.pop(); if(tem.str[0]==&apos;q&apos;) &#123; if(a[findset(tem.p1)]==a[tem.p1]) ans.push(-1); else ans.push(findset(tem.p1)); &#125; else join(tem.p1,tem.p2); &#125; while(!ans.empty()) &#123; printf(&quot;%d\\n&quot;,ans.top()); ans.pop(); &#125; &#125; return 0;&#125;","path":"2019/02/04/Zoj3261-Connections-in-Galaxy-War/"},{"title":"Poj 3522 Slim Span","text":"描述:找一棵生成树，且生成树中边权最大差值尽可能小。 思路:$把边权从小到大排序，然后依次枚举生成树中的最小权重，更新差值, \\\\找到答案，算法复杂度为E*log(V)*E。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;int p[105];int Find(int x)&#123; return p[x]==x?x:p[x]=Find(p[x]);&#125;void join(int x,int y)&#123; int px=Find(x),py=Find(y); if(px!=py) p[px]=py;&#125;struct node&#123; int u,v,w;&#125; e[6000];bool cmp(node x,node y)&#123; return x.w&lt;y.w;&#125;int main()&#123; int n,m,t; bool flag; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n+m)) &#123; for(int i=1; i&lt;=m; i++) &#123; cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; &#125; sort(e+1,e+m+1,cmp); flag=false; int ans=1e7; for(int i=1; i&lt;=m; i++) &#123; t=0; int tem; for(int k=0; k&lt;105; k++) p[k]=k; for(int j=i; j&lt;=m&amp;&amp;t&lt;n-1; j++) &#123; int x=Find(e[j].u); int y=Find(e[j].v); if(x!=y) &#123; p[x]=y; t++; tem=j; &#125; &#125; if(t==n-1) &#123; flag=true; ans=min(ans,e[tem].w-e[i].w); &#125; &#125; if(flag) cout&lt;&lt;ans&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Poj-3522-Slim-Span/"},{"title":"Poj 2186 Popular Cows","text":"描述:$有若干cows，如果a崇拜b，b崇拜c那么a崇拜c，求有多少cows \\\\被其他的所有cows崇拜。$ 思路:$建立有向图，然后缩点，需要找的点就是出度为0的点。 \\\\证明:若有一点a出度不为0且a到b有一条边，由于是DAG \\\\可知不存在从b到a的路径，所以a不是所求点，又发现若 \\\\出度为0的点数量大于1时必然不满足题意,这些点之间不 \\\\存在有向边。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=20005;const int maxm=50005;struct Edge&#123; int to,next;&#125; edge[maxm];int head[maxn],tot;int index,top;int Low[maxn],Dfn[maxn],Stack[maxn],Belong[maxn];int mark[maxn];int scc;bool Instack[maxn];int num[maxn];int n,m,x,y;void addedge(int u,int v)&#123; edge[tot].to=v; edge[tot].next=head[u]; head[u]=tot++;&#125;void Tarjan(int u)&#123; int v; Low[u]=Dfn[u]=++index; Stack[top++]=u; Instack[u]=true; for(int i=head[u]; i!=-1; i=edge[i].next) &#123; v=edge[i].to; if(!Dfn[v]) &#123; Tarjan(v); if(Low[u]&gt;Low[v]) Low[u]=Low[v]; &#125; else if(Instack[v]&amp;&amp;Low[u]&gt;Dfn[v]) Low[u]=Dfn[v]; &#125; if(Low[u]==Dfn[u]) &#123; scc++; do &#123; v=Stack[--top]; Instack[v]=false; Belong[v]=scc; num[scc]++; &#125; while(v!=u); &#125;&#125;void solve(int n)&#123; memset(Dfn,0,sizeof(Dfn)); memset(Low,0,sizeof(Low)); memset(Instack,false,sizeof(Instack)); memset(num,0,sizeof(num)); memset(mark,0,sizeof(mark)); index=scc=top=0; for(int i=1; i&lt;=n; i++) if(!Dfn[i]) Tarjan(i); for(int i=1; i&lt;=n; i++) for(int j=head[i]; j!=-1; j=edge[j].next) &#123; if(Belong[i]!=Belong[edge[j].to]) mark[Belong[i]]=true; &#125; int pos=0,lab=0; for(int i=1; i&lt;=scc; i++) if(!mark[i]) &#123; lab++; pos=i; &#125; if(lab&gt;1)printf(&quot;0\\n&quot;); else printf(&quot;%d\\n&quot;,num[pos]);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); tot=0; memset(head,-1,sizeof(head)); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); addedge(x,y); &#125; solve(n);&#125;","path":"2019/02/04/Poj-2186-Popular-Cows/"},{"title":"Hdu 6447 YJJ Salesman","text":"描述:有一个矩阵，某些点有宝物，宝物有权重，某人从左下角出发，只能向右，上，右上走，求取到的物品权重之和最大值。 思路:$首先离散化地图,然后推出朴素的转移方程 \\\\dp[i][j]=max\\{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+w\\}, \\\\N^{2}复杂度对(10)^{5}数据会T。考虑加速dp。先把有宝物 \\\\的地点排序,按照从左向右，从上到下的顺序排序。考虑在 \\\\(x,y)处获得的最大收益，其实就是要求在(x-1,y-1)这个 \\\\矩形内的最大收益加上w(x,y)。这是一个区间最值问题, \\\\还涉及到点修改，可以用树状数组维护。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int t,n,tree[maxn],yy[maxn];struct Node&#123; int x,y,z;&#125; node[maxn];bool cmp(Node a,Node b)&#123; if(a.x==b.x) return a.y&gt;b.y; return a.x&lt;b.x;&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void uppdate(int x,int tem)&#123; for(int i=x; i&lt;=maxn; i+=lowbit(i)) &#123; tree[i]=max(tree[i],tem); &#125;&#125;int query(int x)&#123; int ret=0; for(int i=x; i&gt;=1; i-=lowbit(i)) &#123; ret=max(ret,tree[i]); &#125; return ret;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); memset(tree,0,sizeof(tree)); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].z); yy[i]=node[i].y; &#125; sort(yy+1,yy+n+1); int Size=unique(yy+1,yy+n+1)-yy-1; for(int i=1; i&lt;=n; i++) node[i].y=lower_bound(yy+1,yy+1+Size,node[i].y)-yy; sort(node+1,node+n+1,cmp); int ans=0; for(int i=1; i&lt;=n; i++) &#123; int val=query(node[i].y-1)+node[i].z; ans=max(ans,val); uppdate(node[i].y,val); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu-6447-YJJ-Salesman/"},{"title":"Hdu6434 Count","text":"描述:$求\\sum _{i=1}^n \\sum _{j=1}^{i-1} [gcd(i+j,i-j)=1] $ 思路:$先做变量代换，令a=i-j,先枚举i,再枚举a,然后对等式变形, \\\\题意转化为对于每个i，求有多少个小于它的a满足gcd(i,a)=1 \\\\且a是奇数,当i是奇数时,答案为\\varphi(i)/2,当i是偶数时, \\\\答案是 \\varphi(i),注意特判i=1时,答案为0。$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;typedef long long ll;const int maxn=2e7+5;int phi[maxn];ll sum[maxn];void phi_table()&#123; memset(phi,0,sizeof(phi)); phi[1]=1; for(int i=2; i&lt;maxn; i++)if(!phi[i]) for(int j=i; j&lt;maxn; j+=i) &#123; if(!phi[j]) phi[j]=j; phi[j]=phi[j]/i*(i-1); &#125;&#125;int main()&#123; phi_table(); sum[1]=0; sum[2]=phi[2]; for(int i=3; i&lt;maxn; i++) if(i%2==1) sum[i]=sum[i-1]+phi[i]/2; else sum[i]=sum[i-1]+phi[i]; int t,n; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;sum[n]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu6434-Count/"},{"title":"Hdu6432 Cyclic","text":"描述:$1-n的n个数组成一个环,要求i后面不能放i+1，n后面不能放1 \\\\经旋转能得到的2种视为同一种方案,求所有本质不同的方案数。$ 思路:容斥计数。 1234567891011121314151617181920212223242526272829303132#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;typedef long long ll;const int mod=998244353;const int maxn=1e5+5;ll ans[maxn];int main()&#123; int t,n; cin&gt;&gt;t; ans[0]=1; ans[1]=0; ans[2]=0; ans[3]=1; ans[4]=1; for(int i=5; i&lt;maxn; i++) &#123; ans[i]=((i-3)*ans[i-1]%mod+(i-2)*(2*ans[i-2]+ans[i-3])%mod)%mod; &#125; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;ans[n]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu6432-Cyclic/"},{"title":"Hdu6060 RXD and dividing","text":"描述:$把树上2-n的结点分成k个集合且不能相交,然后每次取出一个集合 \\\\所有点与1号结点形成连通分量把连通分量里的所有边权相加后加 \\\\到ans上，求最大的ans。$ 思路:$一条边对于ans的贡献值应该是min\\{k,k的子孙的数量\\}*边权, \\\\然后又是经典的统计子树了。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;const int maxn=1e6+5;struct node&#123; int next,w;&#125;;vector&lt;node&gt;vec[maxn];node tem;int son[maxn],p[maxn];void dfs(int v,int u)&#123; son[v]=1; int len=vec[v].size(); for(int i=0; i&lt;len; i++) &#123; int t=vec[v][i].next; p[t]=vec[v][i].w; dfs(t,v); son[v]+=son[t]; &#125;&#125;int main()&#123; int n,k,u,v,value; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k)) &#123; for(int i=1; i&lt;=n; i++) &#123; vec[i].clear(); son[i]=0; p[i]=0; &#125; for(int i=1; i&lt;=n-1; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;value); tem.next=v; tem.w=value; vec[u].push_back(tem); &#125; dfs(1,0); ll ans=0; for(int i=2;i&lt;=n;i++) &#123; ans+=(ll)p[i]*min(son[i],k); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/Hdu6060-RXD-and-dividing/"},{"title":"Hdu5901","text":"描述:$求n以内素数个数,n最大(10)^{11}$。 思路: 论文题,套模板就好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cmath&gt;#define LL long longusing namespace std;const int N = 5e6 + 5;const int M = 7;const int PM = 2 * 3 * 5 * 7 * 11 * 13 * 17;int np[N];int prime[N], pi[N];int phi[PM+1][M+1], sz[M+1];int getprime()&#123; int cnt = 0; np[0] = np[1] = 1; pi[0] = pi[1] = 0; for(int i = 2; i &lt; N; ++i) &#123; if(!np[i]) prime[++cnt] = i; pi[i] = cnt; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j) &#123; np[i * prime[j]] = 1; if(i % prime[j] == 0) break; &#125; &#125; return cnt;&#125;void init()&#123; getprime(); sz[0] = 1; for(int i = 0; i &lt;= PM; ++i) phi[i][0] = i; for(int i = 1; i &lt;= M; ++i) &#123; sz[i] = prime[i] * sz[i-1]; for(int j = 1; j &lt;= PM; ++j) phi[j][i] = phi[j][i-1] - phi[j/prime[i]][i-1]; &#125;&#125;int sqrt2(LL x)&#123; LL r = (LL)sqrt(x - 0.1); while(r*r &lt;= x) ++r; return (int)(r-1);&#125;int sqrt3(LL x)&#123; LL r = (LL)cbrt(x - 0.1); //cbrt(x): x的立方根 while(r*r*r &lt;= x) ++r; return (int)(r-1);&#125;LL getphi(LL x, int s)&#123; if(s == 0) return x; if(s &lt;= M) return phi[x%sz[s]][s] + (x/sz[s]) * phi[sz[s]][s]; if(x &lt;= prime[s]*prime[s]) return pi[x] - s + 1; if(x &lt;= prime[s]*prime[s]*prime[s] &amp;&amp; x &lt; N) &#123; int s2x = pi[sqrt2(x)]; LL ans = pi[x] - (s2x+s-2)*(s2x-s+1)/2; for(int i = s+1; i &lt;= s2x; ++i) ans += pi[x/prime[i]]; return ans; &#125; return getphi(x, s-1) - getphi(x/prime[s], s-1);&#125;LL getpi(LL x)&#123; if(x &lt; N) return pi[x]; LL ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1; for(int i = pi[sqrt3(x)]+1, ed = pi[sqrt2(x)]; i &lt;= ed; ++i) ans -= getpi(x/prime[i]) - i + 1; return ans;&#125;LL lehmer_pi(LL x)&#123; if(x &lt; N) return pi[x]; int a = (int)lehmer_pi(sqrt2(sqrt2(x))); int b = (int)lehmer_pi(sqrt2(x)); int c = (int)lehmer_pi(sqrt3(x)); LL sum = getphi(x, a) + (LL)(b+a-2) * (b-a+1)/2; for (int i = a+1; i &lt;= b; ++i) &#123; LL w = x/prime[i]; sum -= lehmer_pi(w); if(i &gt; c) continue; LL lim = lehmer_pi(sqrt2(w)); for(int j = i; j &lt;= lim; ++j) sum -= lehmer_pi(w/prime[j]) - (j-1); &#125; return sum;&#125;int main()&#123; LL n; init(); while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; printf(&quot;%lld\\n&quot;, lehmer_pi(n)); &#125; return 0;&#125;","path":"2019/02/04/Hdu5901/"},{"title":"Hdu 1695","text":"描述:$求i \\in [1,m],j \\in [1,n],gcd(i,j)=k的pair数。$ 思路:莫比乌斯反演入门题,套个容斥去重。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;bool check[maxn];ll prime[maxn];ll mu[maxn];void mobius()&#123; memset(check,false,sizeof(check)); mu[1]=1; int tot=0; for(int i=2; i&lt;maxn; i++) &#123; if(!check[i]) &#123; prime[tot++]=i; mu[i]=-1; &#125; for(int j=0; j&lt;tot; j++) &#123; if(i*prime[j]&gt;=maxn) break; check[i*prime[j]]=true; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; else mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;ll t,a,b,c,d,k;__int64 ans,ans2;int main()&#123; mobius(); cin&gt;&gt;t; for(int i=1; i&lt;=t; i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k; if(!k) &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;0&lt;&lt;endl; continue; &#125; ans=0; ans2=0; int minn=min(b/k,d/k); for(int i=1; i&lt;=minn; i++) &#123; ans+=mu[i]*(b/k/i)*(d/k/i); &#125; for(int i=1;i&lt;=minn;i++) &#123; ans2+=mu[i]*(minn/i)*(minn/i); &#125; printf(&quot;Case %d: %I64d\\n&quot;,i,ans-ans2/2); //cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;ans-ans2/2&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu-1695/"},{"title":"2018ICPC徐州网络赛 Maze Designer 最大生成树+LCA","text":"描述:要求删除一些边以后使剩下一棵生成树,并且使得删除的边权和最小,然后询问树上2点的最短距离。 思路:$ 先求原图的最大生成树，然后求LCA。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N=250005;struct node&#123; int v,dis,next;&#125;edges[N&lt;&lt;1];int head[N],e;int id[N]; //节点第一次被遍历的顺序int dis[N]; //节点到根节点的距离int RMQ[N*3][20];int curID;//F[i]表示第i个遍历的节点//B[i]表示F[i]在树中的深度int F[N*3],B[N*3];int root;void init()&#123; e = 0; curID = 0; memset(head,-1,sizeof(head));&#125;void Add (int u,int v,int dis)&#123; edges[e].v=v; edges[e].dis=dis; edges[e].next=head[u]; head[u]=e++;&#125;void DFS (int u,int p,int Dep,int d)&#123; int i,v; curID++; F[curID]=u; B[curID]=Dep; id[u]=curID; dis[u]=d; for (i=head[u];i!=-1;i=edges[i].next)&#123; v=edges[i].v; if (v==p) continue; DFS(v,u,Dep+1,d+1); curID++; F[curID]=u; B[curID]=Dep; &#125;&#125;void initRMQ ()&#123; int i,j,x,y; for (i=1;i&lt;=curID;i++) RMQ[i][0]=i; for (j=1;(1&lt;&lt;j)&lt;=curID;j++) for (i=1;i+(1&lt;&lt;j)-1&lt;=curID;i++)&#123; x=RMQ[i][j-1]; y=RMQ[i+(1&lt;&lt;(j-1))][j-1]; RMQ[i][j]=B[x]&lt;B[y]?x:y; &#125;&#125;int getLCA (int a,int b)&#123; int k,x,y; a=id[a];b=id[b]; if (a&gt;b) k=a,a=b,b=k; k=log(1.0+b-a)/log(2.0); x=RMQ[a][k]; y=RMQ[b-(1&lt;&lt;k)+1][k]; return B[x]&lt;B[y]?F[x]:F[y];&#125;int dist(int x,int y)&#123; return dis[x] +dis[y] - 2*dis[getLCA(x,y)];&#125;struct Edg&#123; int u,v; LL dist; bool operator&lt;(const Edg &amp;rhs)const&#123;return dist&gt;rhs.dist;&#125;&#125;;struct Kruskal&#123; int n,m; Edg edges[N&lt;&lt;1]; int fa[N]; int findset(int x)&#123; return fa[x]==-1?x:fa[x]=findset(fa[x]); &#125; void init(int n)&#123; this-&gt;n=n; m=0; memset(fa,-1,sizeof(fa)); &#125; void AddEdge(int u,int v,LL dist)&#123; edges[m++] = (Edg)&#123;u,v,dist&#125;; &#125; void kruskal()&#123; LL sum=0; int cnt=0; sort(edges,edges+m); for(int i=0;i&lt;m;i++)&#123; int u=edges[i].u, v=edges[i].v; if(findset(u) != findset(v))&#123; Add(u,v,1); Add(v,u,1); sum +=edges[i].dist; fa[findset(u)] = findset(v); if(++cnt&gt;=n-1) return ; &#125; &#125; return ; &#125;&#125;G;int main()&#123; int n,m; char c1,c2; LL w1,w2; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; init(); G.init(n*m+1); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; scanf(&quot;\\n%c %lld %c %lld&quot;,&amp;c1,&amp;w1,&amp;c2,&amp;w2); if(c1==&apos;D&apos;)&#123; G.AddEdge((i-1)*m+j,i*m+j,w1); &#125; if(c2 == &apos;R&apos;)&#123; G.AddEdge((i-1)*m+j,(i-1)*m+j+1,w2); &#125; &#125; &#125; G.kruskal(); root=1; DFS(root,0,0,0); initRMQ(); int Q; scanf(&quot;%d&quot;,&amp;Q); int x1,y1,x2,y2; while(Q--)&#123; scanf(&quot;%d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); int u = (x1-1)*m+y1, v = (x2-1)*m+y2; printf(&quot;%d\\n&quot;,dist(u,v)); &#125; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC徐州网络赛-Maze-Designer-最大生成树-LCA/"},{"title":"2018牛客国庆训练营 day6","text":"C&amp;H签到。 G:对方格染色，使得在所有操作后，每种颜色的sum都相同。 12345678910111213141516171819202122232425262728293031323334include&lt;bits/stdc++.h&gt;using namespace std;int a[1005][1005];int color[1005][1005];int n,ans,tem,sum;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; scanf(&quot;%d&quot;,&amp;a[i][j]); color[i][j]=(i+j)%n; if(a[i][j]==-1) tem=color[i][j]; &#125; &#125; int _color,_sum=0; if(tem==n-1) _color=n-2; else _color=n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(color[i][j]==_color) _sum+=a[i][j]; if(color[i][j]==tem&amp;&amp;a[i][j]!=-1) sum+=a[i][j]; &#125; &#125; printf(&quot;%d\\n&quot;,_sum-sum);&#125; A:$拆点以后跑费用流,每个区域拆成n个点，一个蛋糕和第i层连边，其 \\\\费用是i*i-(i-1)*(i-1)。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;const int maxn=5005;const int maxm=50005;int s,t;int num=-1,tot,sum;int dis[maxn],b[maxn],xb[maxn],flow[maxn],fa[maxn];int head[maxm];struct Edge&#123; int from,to,dis,nxt,w;&#125; edge[maxm*2];void add_edge(int from,int to,int w,int dis)&#123; edge[++num].nxt=head[from]; edge[num].from=from; edge[num].to=to; edge[num].w=w; edge[num].dis=dis; head[from]=num;&#125;bool spfa()&#123; for(int i=0; i&lt;=maxn; i++) dis[i]=inf; memset(b,0,sizeof(b)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); memset(fa,-1,sizeof(fa)); b[s]=1; dis[s]=0; fa[s]=0; flow[s]=inf; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); b[u]=0; for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(edge[i].w&gt;0&amp;&amp;dis[v]&gt;dis[u]+edge[i].dis) &#123; dis[v]=dis[u]+edge[i].dis; fa[v]=u; xb[v]=i; flow[v]=min(flow[u],edge[i].w); if(!b[v]) &#123; b[v]=1; que.push(v); &#125; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;void max_flow()&#123; while(spfa()) &#123; int k=t; while(k!=s) &#123; edge[xb[k]].w-=flow[t]; edge[xb[k]^1].w+=flow[t]; k=fa[k]; &#125; tot+=flow[t]; sum+=flow[t]*dis[t]; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; for(int j=1; j&lt;=n; j++) &#123; add_edge(i,n+(j-1)*m+a,1,2*j-1); add_edge(n+(j-1)*m+a,i,0,1-2*j); add_edge(i,n+(j-1)*m+b,1,2*j-1); add_edge(n+(j-1)*m+b,i,0,1-2*j); &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; add_edge(0,i,1,0); add_edge(i,0,0,0); &#125; for(int i=n+1; i&lt;=n+n*m; i++) &#123; add_edge(i,n+n*m+1,1,0); add_edge(n+n*m+1,i,0,0); &#125; s=0; t=n+n*m+1; max_flow(); cout&lt;&lt;sum&lt;&lt;endl;&#125;","path":"2019/02/04/2018牛客国庆训练营-day6/"},{"title":"2018牛客国庆集训派对 day3","text":"D:签到。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;double a[1050];int b[1050];bool cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; int cnt=0; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; if(b[i]) cnt++; &#125; sort(a,a+n,cmp); double ans=0; cnt=min(cnt,m); for(int i=0;i&lt;cnt;i++) &#123; ans+=a[i]/2; &#125; for(int i=cnt;i&lt;n;i++) ans+=a[i]; printf(&quot;%.1f\\n&quot;,ans); &#125;&#125; H:发现和树的结构没有关系，只要考虑如何把树上的结点分成几部分，推完发现是个组合数取模，预处理阶乘，用乘法逆元即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;const int mod=1e9+7;ll fac[maxn];void init_fac()&#123; fac[0]=fac[1]=1; for(int i=2;i&lt;maxn;i++) fac[i]=i*fac[i-1]%mod;&#125; ll quickpow(ll a,ll n)&#123; ll ret=1; while(n) &#123; if(n&amp;1) ret=ret*a%mod; a=a*a%mod; n&gt;&gt;=1; &#125; return ret;&#125;ll C(ll a,ll b)&#123; return fac[a]*quickpow(fac[b],mod-2)%mod*quickpow(fac[a-b],mod-2)%mod;&#125; int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); init_fac(); while(t--) &#123; int n,m; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;n;i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); &#125; ll ans=C(n-1,m-1)*fac[m]%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125; A:马走日问题，因为棋盘太大，可以大范围贪心+小范围暴搜。题解是找规律。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x, y, ans; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;x&gt;&gt;y; x=abs(x); y=abs(y); if(x&gt;y)swap(x, y); if(y==x*2) &#123; printf(&quot;%d\\n&quot;, (x+y)/3); continue; &#125; if(y&lt;=2*x) &#123; if(x==1&amp;&amp;y==1) ans = 2; else if(x==2&amp;&amp;y==2) ans = 4; else ans = (x+y)/3+(x+y)%3; &#125; else &#123; ans=x; int c=(y-2*x)%4; ans+=c; ans+=(y-2*x-c)/2; if(y==1&amp;&amp;x==0) ans=3; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/2018牛客国庆集训派对-day3/"},{"title":"2018牛客国庆集训派对day1 J Princess Principal","text":"描述:给出一个括号序列，然后给出多组询问，每次判断一个区间里的括号是否是匹配的。 思路:$对于一个括号序列，如果想让所有的括号尽可能多的匹配，每个单 \\\\括号应该只对应唯一的另一个单括号与它匹配。那么就可以比较加入 \\\\a_l之前栈里留下的括号的状态和加入a_r以后栈里留下的括号的状态, \\\\如果一样，相当于这段区间的括号消掉了。$ $思路二，已知括号序列的匹配方式是唯一的，如果在区间里任意取出 \\\\一个单括号,与它匹配的单括号也必须在这个区间里。所以先预处理与 \\\\每一个位置单括号匹配的另一个单括号的编号x_i。 但是这时查询一个 \\\\区间的复杂度仍然是线性的。 但其实只需要查询这个区间里x_i的最大值 \\\\和最小值即可，最大值是右端点，最小值是左端点说明这个区间匹配。$ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,m,q;int a[maxn],x[maxn];stack&lt;int&gt;s;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); while(!s.empty()) s.pop(); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=n;i++) &#123; if(s.empty()||!(a[i]&amp;1)) s.push(i); else if(a[s.top()]+1==a[i]) s.pop(); else s.push(i); if(s.empty()) x[i]=0; else x[i]=s.top(); &#125; while(q--) &#123; int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); if(x[l-1]==x[r]) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,m,q;int a[maxn],b[maxn],x[maxn&lt;&lt;2],y[maxn&lt;&lt;2];stack&lt;int&gt;s;void build(int R,int l,int r)&#123; if(l==r) &#123; x[R]=b[l]; y[R]=b[l]; return; &#125; int mid=l+r&gt;&gt;1; build(R&lt;&lt;1,l,mid); build(R&lt;&lt;1|1,mid+1,r); x[R]=min(x[R&lt;&lt;1],x[R&lt;&lt;1|1]); y[R]=max(y[R&lt;&lt;1],y[R&lt;&lt;1|1]);&#125;void ask(int R,int l,int r,int ql,int qr,int &amp;u,int &amp;v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) &#123; u=min(u,x[R]); v=max(v,y[R]); return ; &#125; int mid=l+r&gt;&gt;1; if(ql&lt;=mid) ask(R&lt;&lt;1,l,mid,ql,qr,u,v); if(qr&gt;mid) ask(R&lt;&lt;1|1,mid+1,r,ql,qr,u,v);&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,a+i); b[i]=-1; if(s.empty()||!(a[i]&amp;1)) s.push(i); else if (a[s.top()]+1==a[i]) b[i]=s.top(),b[s.top()]=i,s.pop(); else s.push(i); &#125; build(1,1,n); while(q--) &#123; int ql,qr; scanf(&quot;%d %d&quot;,&amp;ql,&amp;qr); int _1=1e9,_2=-2; ask(1,1,n,ql,qr,_1,_2); if(_1==ql&amp;&amp;_2==qr) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;","path":"2019/02/04/2018牛客国庆集训派对day1-J-Princess-Principal/"},{"title":"2018牛客暑期多校训练四 A gpa 01分数规划","text":"描述:$给一个数列a和一个数列b，然后从这两个数列中中最多删除k个项, \\\\即同时删除a_i和b_i，求剩下来的\\sum (a_i*b_i)/\\sum a_i最大值。$ 思路:$设\\sum (a_i*b_i)/ \\sum a_i \\ge D $ $变形\\sum (a_i*b_i) \\ge (\\sum a_i)*D$ $变形\\sum (a_i*(b_i-D)) \\ge 0$ $然后二分D 把s_i排个序，至多删除k项，就把就k小的项都删除，判断 \\\\剩下来的项的和，把和与0比较进行二分。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;typedef long double ld;const double eps=1e-6;struct node&#123; double s,c;&#125; p[100005];double d[100005];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;p[i].s; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i].c; &#125; memset(d,0,sizeof(d)); double r=1000; double l=0; double mid; while(r-l&gt;eps) &#123; double sum=0; mid=(r+l)/2; for(int i=0; i&lt;n; i++) d[i]=p[i].s*p[i].c-p[i].s*mid; sort(d,d+n); for(int i=k; i&lt;n; i++) sum+=d[i]; if(sum&gt;=0) l=mid; else r=mid; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l&lt;&lt;endl;&#125;","path":"2019/02/04/2018牛客暑期多校训练四-A-gpa-01分数规划/"},{"title":"2018ICPC南京网络赛 分层图最短路","text":"描述:$考虑边带权的图，已知源点和终点，如果可以使的图里的k条边\\\\边权变成0，最短路是多少。$ 思路:$把图分成k层，每层仍然是n个点，每层的连边方式仍然和原图相同。\\\\除此以外，层与层之间该如何连边?假设现在在第i层，点u和点v之间\\\\有一条权值w的边，对于下一层，即i+1层，u’与v’之间仍是有一条\\\\权为w的边，且对于u与v’之间应该加上一条边权为0的边。$ $拆点以后在新图上跑最短路。另外此题卡SPFA，\\\\用优化后的dijkstra即可。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF=1e18;const int maxn=1200000;const int maxm=4500000;int t,n,m,k,a,b,c,cnt;bool done[maxn];ll d[maxn];struct Edge&#123; int u,v,nex; ll w;&#125; edge;Edge g[maxm];int head[maxn];void add(int u,int v,ll w)&#123; g[cnt].u=u; g[cnt].v=v; g[cnt].w=w; g[cnt].nex=head[u]; head[u]=cnt++;&#125;struct HeapNode&#123; int d,u; bool operator &lt; (const HeapNode&amp; rhs)const &#123; return d&gt;rhs.d; &#125;&#125; node;inline void dijkstra(int s)&#123; priority_queue&lt;HeapNode&gt;Q; memset(d,0x3f,sizeof(d)); d[s]=0; memset(done,false,sizeof(done)); Q.push(HeapNode&#123;0,s&#125;); while(!Q.empty()) &#123; HeapNode x=Q.top(); Q.pop(); int u=x.u; if(done[u]) continue; done[u]=true; for(int i=head[u]; i+1; i=g[i].nex) &#123; if(d[g[i].v]&gt;d[u]+g[i].w) &#123; d[g[i].v]=d[u]+g[i].w; Q.push(HeapNode&#123;d[g[i].v],g[i].v&#125;); &#125; &#125; &#125;&#125;inline int read()&#123; char c=getchar(); int x=0,f=1; while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;) &#123; if(c==&apos;-&apos;)f=-1; c=getchar(); &#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) &#123; x=x*10+c-&apos;0&apos;; c=getchar(); &#125; return x*f;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;t)) &#123; while(t--) &#123; //scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); n=read(); m=read(); k=read(); cnt=0; memset(head,-1,sizeof(head)); for(int i=1; i&lt;=m; i++) &#123; //scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); a=read(); b=read(); c=read(); add(a,b,c); for(int j=1; j&lt;=k; j++) &#123; add(j*n+a,j*n+b,c); add((j-1)*n+a,j*n+b,0); &#125; &#125; dijkstra(1); ll ans=INF; for(int i=1; i&lt;=k+1; i++) &#123; ans=min(ans,d[i*n]); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC南京网络赛-分层图最短路/"},{"title":"2018ICPC南京网络赛 AC Challenge 状压dp","text":"描述:$n个题，做每个题之前必须把限制的某几个题做完。\\\\做第i个题的得分是a*w_i+b,w_i是第i题权重，a,b$都是常数，问能得到的最高分。 思路:考虑到$n$最大只有20，且每个题只有做和不做两种状态，所以可以状压dp。 对于每个状态的枚举时，首先判断这种状态是否符合条件。如果这种状态是符合条件的，那考虑这种状态中所有已经做了的题，分别把它们状态设为没做，这样就找到所有能转移到目前状态的前驱状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;int t;struct Node&#123; int a,b,s;&#125; node[25];vector&lt;int&gt;vec[25];int dp[(1&lt;&lt;20)+1];int main()&#123; while(cin&gt;&gt;t) &#123; for(int i=1; i&lt;=t; i++) &#123; cin&gt;&gt;node[i].a&gt;&gt;node[i].b&gt;&gt;node[i].s; int tem; for(int j=1; j&lt;=node[i].s; j++) &#123; cin&gt;&gt;tem; vec[i].push_back(tem); &#125; &#125; memset(dp,0,sizeof(dp)); int ans=0; for(int i=0; i&lt;(1&lt;&lt;t); i++) &#123; bool ok=true; for(int j=1; j&lt;=t; j++) &#123; if(!(i&amp;(1&lt;&lt;(j-1)))) continue; for(int k=0;k&lt;vec[j].size();k++) &#123; int tmp=vec[j][k]; if(!(i&amp;(1&lt;&lt;(tmp-1)))) &#123; ok=false; break; &#125; &#125; if(!ok) break; &#125; if(!ok) continue;//如果不满足大条件 就丢掉 for(int j=1;j&lt;=t;j++) &#123; if(!(i&amp;(1&lt;&lt;(j-1)))) continue;//这题做过的才能继续这个算法 int s=i,cnt=0;//统计i的二进制里有几个1，也就是有几题做过 while(s) &#123; if(s&amp;1) cnt++; s/=2; &#125; dp[i]=max(dp[i],dp[i^(1&lt;&lt;(j-1))]+cnt*node[j].a+node[j].b);//让做过的这题没做就是前一个状态 &#125; ans=max(ans,dp[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC南京网络赛-AC-Challenge-状压dp/"},{"title":"2018ICPC北京网络赛D 80days 尺取法","text":"描述:传送门 思路:有环，易想到复制一份在后面，然后考虑枚举起点，尺取法双指针扫描即可，复杂度为线性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+5;int t;int n,k;int a[maxn],b[maxn],c[maxn&lt;&lt;1];int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) &#123; c[i]=a[i]-b[i]; c[n+i]=a[i]-b[i]; &#125; int l=1,r=1; ll tem=0; bool ok=true; while(l&lt;=n&amp;&amp;r-l+1&lt;=n) &#123; if(!ok) break; if(tem+c[r]+k&gt;=0) &#123; tem+=c[r]; r++; &#125; else &#123; tem+=c[r]; r++; while(tem+k&lt;0) &#123; tem-=c[l]; l++; if(l&gt;r) &#123; ok=false; break; &#125; &#125; &#125; &#125; if(!ok||l&gt;n) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;l&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC北京网络赛D-80days-尺取法/"},{"title":"2018Hdu 多校训练一 Time Zone","text":"描述:模拟时区，时区可以是小数。 思路:大力模拟。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int p,a,b,zs,xs;////直接从字符串里提取小数会有误差，所以这里分两部分提取出来char str[15];int main()&#123; scanf(&quot;%d&quot;,&amp;p); while(p--) &#123; scanf(&quot;%d%d%s&quot;,&amp;a,&amp;b,&amp;str); if(str[5]==&apos;.&apos;)zs=str[4]-&apos;0&apos;,xs=str[6]-&apos;0&apos;; else if(str[6]==&apos;.&apos;) zs=(str[4]-&apos;0&apos;)*10+str[5]-&apos;0&apos;,xs=str[7]-&apos;0&apos;; else if(str[5]==&apos;\\0&apos;) zs=str[4]-&apos;0&apos;,xs=0; else if(str[6]==&apos;\\0&apos;) zs=(str[4]-&apos;0&apos;)*10+str[5]-&apos;0&apos;,xs=0; if(str[3]==&apos;-&apos;) zs=-zs,xs=-xs; if(zs&gt;=8) &#123; if(xs*6+b&gt;=60) &#123; b=(xs*6+b)%60; a=(a+1+zs-8+24)%24; &#125; else b=xs*6+b,a=(a+zs-8+24)%24; if(a&gt;=10&amp;&amp;b&gt;=10) printf(&quot;%d:%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&lt;10) printf(&quot;0%d:0%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&gt;=10) printf(&quot;0%d:%d\\n&quot;,a,b); else if(a&gt;=10&amp;&amp;b&lt;10) printf(&quot;%d:0%d\\n&quot;,a,b); &#125; else if(zs&lt;8) &#123; int h=(80-(zs*10+xs))*6/60; int m=(80-(zs*10+xs))*6-h*60; if(m&gt;b) &#123; b=b+60-m; a=(a-1-h+24)%24; &#125; else b=b-m,a=(a-h+24)%24; if(a&gt;=10&amp;&amp;b&gt;=10) printf(&quot;%d:%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&lt;10) printf(&quot;0%d:0%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&gt;=10) printf(&quot;0%d:%d\\n&quot;,a,b); else if(a&gt;=10&amp;&amp;b&lt;10) printf(&quot;%d:0%d\\n&quot;,a,b); &#125; &#125;&#125;","path":"2019/02/04/2018Hdu-多校训练一-Time-Zone/"},{"title":"牛客练习赛22-C简单瞎搞题 bitset+dp","text":"描述:给出$n$个区间，然后分别给出区间的左右边界，可以在每个区间中选择一个整数，问这$n$个整数的平方和有多少种不同的取值。 思路:$ f_i $表示一个bitset，bitset里有几个1，就表示这i个区间所能得到的平方和的取值种数。 转移方程为 f[i]=f[i] | f[i-1]&lt;&lt;k^k (k from l to r) 状态转移的复杂度是n，每次操作对应的复杂度是l-r。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;bitset&gt;using namespace std;bitset&lt;1000000+10&gt;f[105];int main()&#123; int n,l,r; cin&gt;&gt;n; f[0][0]=1; for (int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;l, &amp;r); for(int j=l; j&lt;=r; j++) &#123; f[i]=f[i]|f[i-1]&lt;&lt;j*j; &#125; &#125; printf(&quot;%d\\n&quot;, f[n].count()); return 0;&#125;","path":"2019/02/04/牛客练习赛22-C简单瞎搞题-bitset-dp/"},{"title":"Poj 3281 Dining 最大流","text":"描述:有一些牛，食物，饮料，每头牛都有一个喜欢吃的食物和饮料集合，要求你找出一个最大匹配，能满足所有牛的需求。 思路:拆点以后跑最大流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500;const int maxm=210000;const int inf=1e9;int cnt=-1,f,d,n,s,t;int head[maxn],dep[maxn],cur[maxn];struct Edge&#123; int nxt; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; edge[++cnt].nxt=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=f+2*n+d+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; for(int i=0; i&lt;maxm*2; i++) edge[i].nxt=-1; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;f,&amp;d); s=f+2*n+d+1; t=f+2*n+d+2; for(int i=1; i&lt;=n; i++) &#123; int a,b,tem; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); for(int j=1;j&lt;=a;j++) &#123; scanf(&quot;%d&quot;,&amp;tem); add_edge(tem,f+i,1); add_edge(f+i,tem,0); &#125; for(int j=1;j&lt;=b;j++) &#123; scanf(&quot;%d&quot;,&amp;tem); add_edge(f+n+i,f+2*n+tem,1); add_edge(f+2*n+tem,f+n+i,0); &#125; add_edge(f+i,f+n+i,1); add_edge(f+n+i,f+i,0); &#125; for(int i=1;i&lt;=f;i++) &#123; add_edge(s,i,1); add_edge(i,s,0); &#125; for(int i=1;i&lt;=d;i++) &#123; add_edge(f+2*n+i,t,1); add_edge(t,f+2*n+i,0); &#125; printf(&quot;%d\\n&quot;,Dinic());&#125;","path":"2019/02/04/Poj-3281-Dining-最大流/"},{"title":"Poj 3041 Asteroids 最小点覆盖","text":"描述:有一个500*500的网格图，格点上有一些点，每次可以消除一行或者一列上所有的点，问消除所有的点最少需要几次。 思路:因为要消除一个点,只有2种方式，并且一行或者一列多次消除是没有意义的。可以考虑构建一个二分图，左边是所有的行，右边是所有的列，把待消除的点作为边，一个点会唯一连一条边，那么题意转化为了，选择二分图上的点，把与这个点连的边加入一个集合，这个集合应该包含了所有边，最少选择的点的个数，问题转化为了最小点覆盖。 二分图里最小点覆盖等于最大匹配，跑一遍最大流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1100;const int maxm=260000;const int inf=1e9;int cnt=-1,n,k,s,t;int head[maxn],dep[maxn],cur[maxn];struct Edge&#123; int nxt; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; edge[++cnt].nxt=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=2*n+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; //建图 左边点1-N(行) 右边点N+1， 2N 源点2N+1,汇点2N+2; for(int i=0;i&lt;maxm*2;i++) edge[i].nxt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); memset(head,-1,sizeof(head)); cnt=-1; for(int i=1;i&lt;=k;i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); add_edge(x,y+n,1); add_edge(y+n,x,0); &#125; for(int i=1;i&lt;=n;i++) &#123; add_edge(2*n+1,i,1); add_edge(i,2*n+1,0); add_edge(i+n,2*n+2,1); add_edge(2*n+2,i+n,0); &#125; s=2*n+1; t=2*n+2; printf(&quot;%d\\n&quot;,Dinic());&#125;","path":"2019/02/04/Poj-3041-Asteroids-最小点覆盖/"},{"title":"Poj 2135 Farm Tour 费用流","text":"描述:给出起点和终点，要求从起点走到终点，再从终点回来，走的路最短，且来回走的路中不能有相同的边。 思路:不要考虑来回，其实本质就是选择两条路，边权和最小，所以我们可以跑一个最大流是2的费用流。(选n条路就跑最大流是n的费用流) 本题所有边都是无向边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;const int maxn=2000;const int maxm=11000;int n,m,s,t;int cnt=-1,tot,sum;int dis[maxn],b[maxn],xb[maxn],flow[maxn],fa[maxn];int head[maxm];struct Edge&#123; int from,to,dis,nxt,w;&#125;edge[maxm*4];void add_edge(int from,int to,int w,int dis)&#123; edge[++cnt].nxt=head[from]; edge[cnt].from=from; edge[cnt].to=to; edge[cnt].w=w; edge[cnt].dis=dis; head[from]=cnt;&#125;bool spfa()&#123; for(int i=0;i&lt;=maxn;i++) dis[i]=inf; memset(b,0,sizeof(b)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); memset(fa,-1,sizeof(fa)); b[s]=1; dis[s]=0; fa[s]=0; flow[s]=inf; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); b[u]=0; for(int i=head[u];i!=-1;i=edge[i].nxt) &#123; int v=edge[i].to; if(edge[i].w&amp;&amp;dis[v]&gt;dis[u]+edge[i].dis) &#123; dis[v]=dis[u]+edge[i].dis; fa[v]=u; xb[v]=i; flow[v]=min(flow[u],edge[i].w); if(!b[v]) &#123; b[v]=1; que.push(v); &#125; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;void max_flow()&#123; while(spfa()) &#123; int k=t; while(k!=s) &#123; edge[xb[k]].w-=flow[t]; edge[xb[k]^1].w+=flow[t]; k=fa[k]; &#125; tot+=flow[t]; sum+=flow[t]*dis[t]; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); s=n+1; t=n+2; for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,1,c); add_edge(b,a,0,-c); add_edge(b,a,1,c); add_edge(a,b,0,-c); &#125; add_edge(s,1,2,0); add_edge(1,s,0,0); add_edge(n,t,2,0); add_edge(t,n,0,0); max_flow(); printf(&quot;%d\\n&quot;,sum);&#125;","path":"2019/02/04/Poj-2135-Farm-Tour-费用流/"},{"title":"Hdu1569 洛谷P2774方格取数 状压dp or 最小割","text":"描述:给一个$n*m$的方格，每个格子里有个正数，要求选择若干数，这些数所在方格不能有相邻的边，要求选择的数的和最大。 思路:状压dp玄学爆过去了,然而复杂度算下来不对。 正解是网络流。对方格染色，把方格变成二分图，把所有点的权相加，去掉最小割就是我们所要的答案了，所以具体的建图方式为：源点与黑色点连，汇点与白色点连，容量都是点权。然后又因为选了一个点以后会影响它相邻的点，这些边是不会出现在割集中的，所以把这些边的容量置inf。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=15000;const int maxm=50000;const int inf=1e9;int cnt=-1,n,m,s,t,sum;int head[maxn],dep[maxn],cur[maxn];struct P&#123; int id,w;&#125;;vector&lt;P&gt;_1,_2;struct Edge&#123; int next=-1; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; //cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].next) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].next) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=n*m+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; //1-n*n n*n+1,n*n+2m while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; _1.clear(); _2.clear(); sum=0; memset(head,-1,sizeof(head)); cnt=-1; s=n*m+1; t=n*m+2; int _cnt=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; P tem; scanf(&quot;%d&quot;,&amp;tem.w); sum+=tem.w; _cnt++; tem.id=_cnt; if((i+j)&amp;1) _1.push_back(tem); else _2.push_back(tem); &#125; &#125; for(int i=0; i&lt;_1.size(); i++) &#123; add_edge(s,_1[i].id,_1[i].w); add_edge(_1[i].id,s,0); &#125; for(int i=0; i&lt;_2.size(); i++) &#123; add_edge(_2[i].id,t,_2[i].w); add_edge(t,_2[i].id,0); &#125; for(int i=0; i&lt;_1.size(); i++) &#123; if(_1[i].id%m!=0) add_edge(_1[i].id,_1[i].id+1,inf),add_edge(_1[i].id+1,_1[i].id,0); if(_1[i].id%m!=1) add_edge(_1[i].id,_1[i].id-1,inf),add_edge(_1[i].id-1,_1[i].id,0); if(_1[i].id+m&lt;=n*m) add_edge(_1[i].id,_1[i].id+m,inf),add_edge(_1[i].id+m,_1[i].id,0); if(_1[i].id-m&gt;=1) add_edge(_1[i].id,_1[i].id-m,inf),add_edge(_1[i].id-m,_1[i].id,0); &#125; printf(&quot;%d\\n&quot;,sum-Dinic()); &#125;&#125;","path":"2019/02/04/Hdu1569-洛谷P2774方格取数-状压dp-or-最小割/"},{"title":"Hdu 1116 Play on Words 并查集+有向图的欧拉路","text":"描述:类似于成语接龙，给若干个单词，问能否组成一个排列，使得一个单词的尾字母和后面一个单词的首字母相同。例如acm，malform，mouse这三个单词就满足题意。 思路:把每个单词看成一条边，取首字母和尾字母，作为起点和终点。建图，图上有26个点，每输入一个单词，就在对应的两点间建立一条有向边。要判断输入的单词是否满足题意，其实就是判断图中是否存在一条欧拉路径。如果这个图不只包含一个连通分量，那么一定不满足题意。连通分量用并查集维护。 下面的问题就是判断有向图的欧拉路径。如果不是回路，那么图中只有一个点的出度比入度大1（起点），一个点的出度比入度小1（终点），其它点出度等于入度。如果是欧拉回路，则所有的点出度等于入度。并且如果存在出度入度的差值大于1的点也一定不能形成欧拉路。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int p[30];int Find(int x)&#123; if(x!=p[x]) p[x]=Find(p[x]); return p[x];&#125;void join(int a,int b)&#123; if(Find(a)!=Find(b)) p[Find(a)]=Find(b);&#125;int main()&#123; //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int t,num,num1,num2; cin&gt;&gt;t; int indeg[30],outdeg[30]; bool vis[30],flag; while(t--) &#123; num=num1=num2=0; flag=true; int n; cin&gt;&gt;n; char str[1000]; for(int i=0; i&lt;26; i++) &#123; p[i]=i; vis[i]=false; outdeg[i]=indeg[i]=0; &#125; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;str; join(str[0]-&apos;a&apos;,str[strlen(str)-1]-&apos;a&apos;); indeg[str[0]-&apos;a&apos;]++; outdeg[str[strlen(str)-1]-&apos;a&apos;]++; vis[str[0]-&apos;a&apos;]=true; vis[str[strlen(str)-1]-&apos;a&apos;]=true; &#125; for(int i=0; i&lt;26; i++) &#123; if(p[i]==i&amp;&amp;vis[i]) num++; if(indeg[i]-outdeg[i]==1) num1++; if(outdeg[i]-indeg[i]==1) num2++; if(indeg[i]-outdeg[i]&gt;1||outdeg[i]-indeg[i]&gt;1) flag=false; &#125; if(flag==true&amp;&amp;num==1&amp;&amp;(num1==num2==0||num1==num2==1)) &#123; cout&lt;&lt;&quot;Ordering is possible.&quot;&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;The door cannot be opened.&quot;&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Hdu-1116-Play-on-Words-并查集-有向图的欧拉路/"},{"title":"bzoj 1036 树的统计 树链剖分","text":"描述:三种操作，一是修改树上某结点的权，二是询问结点x到y路径上的最大点的权，三是询问结点x到y路径上所有点的权值和。 思路:先对树进行重链剖分，然后用线段树维护连续区间的最大值和区间和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=30005;const int maxm=60005;const int inf=1e9;int cnt,tot,n,q;int head[maxn],siz[maxn],dep[maxn],pre[maxn],fa[maxn],wson[maxn],dfn[maxn],top[maxn];int value[maxn];struct Tree&#123; int l,r,sum,mx;&#125; tree[4*maxn];struct Edge&#123; int nex,to;&#125; edge[maxm];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs1(int u,int f)&#123; siz[u]=1; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==fa[u]) continue; dep[v]=dep[u]+1; fa[v]=u; dfs1(v,u); siz[u]+=siz[v]; if(siz[wson[u]]&lt;siz[v]) wson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++tot; pre[tot]=u; top[u]=tp; if(wson[u]) dfs2(wson[u],tp); for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v!=fa[u]&amp;&amp;v!=wson[u]) dfs2(v,v); &#125;&#125;void build(int k,int l,int r)&#123; tree[k].l=l,tree[k].r=r; if(l==r) return ; int mid=l+r&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r);&#125;void change(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==r) &#123; tree[k].sum=tree[k].mx=y; return ; &#125; if(x&lt;=mid) change(k&lt;&lt;1,x,y); else change(k&lt;&lt;1|1,x,y); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; tree[k].mx=max(tree[k&lt;&lt;1].mx,tree[k&lt;&lt;1|1].mx);&#125;int querysum(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].sum; if(y&lt;=mid) return querysum(k&lt;&lt;1,x,y); else if(x&gt;mid) return querysum(k&lt;&lt;1|1,x,y); else return querysum(k&lt;&lt;1,x,mid)+querysum(k&lt;&lt;1|1,mid+1,y);&#125;int querymax(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].mx; if(y&lt;=mid) return querymax(k&lt;&lt;1,x,y); else if(x&gt;mid) return querymax(k&lt;&lt;1|1,x,y); else return max(querymax(k&lt;&lt;1,x,mid),querymax(k&lt;&lt;1|1,mid+1,y));&#125;int solvesum(int x,int y)&#123; int sum=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); sum+=querysum(1,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); sum+=querysum(1,dfn[x],dfn[y]); return sum;&#125;int solvemax(int x,int y)&#123; int mx=-inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); mx=max(mx,querymax(1,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); mx=max(mx,querymax(1,dfn[x],dfn[y])); return mx;&#125;void solve()&#123; build(1,1,n); for(int i=1; i&lt;=n; i++) change(1,dfn[i],value[i]); scanf(&quot;%d&quot;,&amp;q); char ch[10]; for(int i=1; i&lt;=q; i++) &#123; int x,y; scanf(&quot;%s%d%d&quot;,ch,&amp;x,&amp;y); if(ch[0]==&apos;C&apos;) &#123; value[x]=y; change(1,dfn[x],y); &#125; else &#123; if(ch[1]==&apos;M&apos;) printf(&quot;%d\\n&quot;,solvemax(x,y)); else printf(&quot;%d\\n&quot;,solvesum(x,y)); &#125; &#125;&#125;int main()&#123; cnt=-1; tot=0; memset(head,-1,sizeof(head)); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); add_edge(a,b); add_edge(b,a); &#125; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;value[i]); dfs1(1,0); dfs2(1,1); solve(); return 0;&#125;","path":"2019/02/04/bzoj-1036-树的统计-树链剖分/"},{"title":"bzoj 1008 越狱","text":"描述:有n个人排成一列，一共有m种势力，每个人可能属于一个势力，相邻的人势力相同则不合法，一共有多少种可能的不合法状态。 思路:所有的状态是$m^{n}$,正面很难求不合法的状态，所以想到先求合法状态，第一个人有$m$种选择，剩下的人都只有$m-1$种选择，所以答案就是$m^{n}-m*(m-1)^{n-1}$。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=100003;ll m,n;ll quick_pow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=(res*a)%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; while(~scanf(&quot;%lld %lld&quot;,&amp;m,&amp;n)) &#123; ll ans=(quick_pow(m,n)-(m*quick_pow(m-1,n-1))%mod+mod)%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","path":"2019/02/04/bzoj-1008-越狱/"},{"title":"bzoj1003 预处理最短路+区间dp","text":"描述:给一个图，让你跑n次最短路，第i次最短路有若干点是不能使用的，并且更改一次路线就又需要加k的额外花费，问跑完n次以后最小花费。 思路:想到把n次最短路分割成多个区间最短路的和，一个区间内最短路是不变的，对于每种最短路，我们可以预处理，因为只有n方的区间，n最大100，点最多只有20个，先跑n方的spfa。设dp[i][j]表示第i次到第j次最短路的所有花费的最小值。那么答案就是dp[1][n]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200;const int maxm=1000;int cnt=-1,n,m,k,e;int head[maxn],use[110][110],dist[maxn],dp[110][110];bool inq[maxn];struct Edge&#123; int nex; int to,w;&#125; edge[maxm];void add_edge(int u,int v,int w)&#123; edge[++cnt].nex=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool check(int x,int s,int t)&#123; for(int i=s; i&lt;=t; i++) if(!use[x][i]) return false; return true;&#125;int spfa(int s,int t)&#123; memset(dist,0x3f,sizeof(dist)); memset(inq,false,sizeof(inq)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); que.push(1); dist[1]=0; inq[1]=true; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=false; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(check(v,s,t)&amp;&amp;dist[v]&gt;dist[u]+edge[i].w) &#123; dist[v]=dist[u]+edge[i].w; if(!inq[v]) inq[v]=true,que.push(v); &#125; &#125; &#125; return dist[m]==0x3f3f3f3f ? 0x3f3f3f3f:dist[m]*(t-s+1);&#125;void solve()&#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=i; j&lt;=n; j++) dp[i][j]=spfa(i,j); &#125; int e; for(int len=2; len&lt;=n; len++) for(int s=1; (e=s+len-1)&lt;=n; s++) for(int p=s; p&lt;s+len-1; p++) &#123; dp[s][e]=min(dp[s][e],dp[s][p]+dp[p+1][e]+k); &#125; printf(&quot;%d\\n&quot;,dp[1][n]);&#125;int main()&#123; while(~scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;k,&amp;e)) &#123; memset(head,-1,sizeof(head)); cnt=-1; for(int i=1; i&lt;maxm; i++) edge[i].nex=-1; for(int i=1; i&lt;=e; i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,c); add_edge(b,a,c); &#125; memset(use,1,sizeof(use)); int tem; scanf(&quot;%d&quot;,&amp;tem); for(int i=1; i&lt;=tem; i++) &#123; int p,a,b; scanf(&quot;%d %d %d&quot;,&amp;p,&amp;a,&amp;b); for(int j=a; j&lt;=b; j++) use[p][j]=0; &#125; solve(); &#125;&#125;","path":"2019/02/04/bzoj1003-预处理最短路-区间dp/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/01/31/hello-world/"}]}
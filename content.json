{"pages":[{"title":"","text":"Al1yf5cTUE","path":"baidu_verify_Al1yf5cTUE.html"},{"title":"about-me","text":"测试","path":"about-me/index.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"categories","text":"","path":"categories/index.html"}],"posts":[{"title":"bzoj 1036 树的统计 树链剖分","text":"描述: 三种操作，一是修改树上某结点的权，二是询问结点x到y路径上的最大点的权，三是询问结点x到y路径上所有点的权值和。 思路: 先对树进行重链剖分，然后用线段树维护连续区间的最大值和区间和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=30005;const int maxm=60005;const int inf=1e9;int cnt,tot,n,q;int head[maxn],siz[maxn],dep[maxn],pre[maxn],fa[maxn],wson[maxn],dfn[maxn],top[maxn];int value[maxn];struct Tree&#123; int l,r,sum,mx;&#125; tree[4*maxn];struct Edge&#123; int nex,to;&#125; edge[maxm];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs1(int u,int f)&#123; siz[u]=1; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==fa[u]) continue; dep[v]=dep[u]+1; fa[v]=u; dfs1(v,u); siz[u]+=siz[v]; if(siz[wson[u]]&lt;siz[v]) wson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++tot; pre[tot]=u; top[u]=tp; if(wson[u]) dfs2(wson[u],tp); for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v!=fa[u]&amp;&amp;v!=wson[u]) dfs2(v,v); &#125;&#125;void build(int k,int l,int r)&#123; tree[k].l=l,tree[k].r=r; if(l==r) return ; int mid=l+r&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r);&#125;void change(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==r) &#123; tree[k].sum=tree[k].mx=y; return ; &#125; if(x&lt;=mid) change(k&lt;&lt;1,x,y); else change(k&lt;&lt;1|1,x,y); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; tree[k].mx=max(tree[k&lt;&lt;1].mx,tree[k&lt;&lt;1|1].mx);&#125;int querysum(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].sum; if(y&lt;=mid) return querysum(k&lt;&lt;1,x,y); else if(x&gt;mid) return querysum(k&lt;&lt;1|1,x,y); else return querysum(k&lt;&lt;1,x,mid)+querysum(k&lt;&lt;1|1,mid+1,y);&#125;int querymax(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].mx; if(y&lt;=mid) return querymax(k&lt;&lt;1,x,y); else if(x&gt;mid) return querymax(k&lt;&lt;1|1,x,y); else return max(querymax(k&lt;&lt;1,x,mid),querymax(k&lt;&lt;1|1,mid+1,y));&#125;int solvesum(int x,int y)&#123; int sum=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); sum+=querysum(1,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); sum+=querysum(1,dfn[x],dfn[y]); return sum;&#125;int solvemax(int x,int y)&#123; int mx=-inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); mx=max(mx,querymax(1,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); mx=max(mx,querymax(1,dfn[x],dfn[y])); return mx;&#125;void solve()&#123; build(1,1,n); for(int i=1; i&lt;=n; i++) change(1,dfn[i],value[i]); scanf(&quot;%d&quot;,&amp;q); char ch[10]; for(int i=1; i&lt;=q; i++) &#123; int x,y; scanf(&quot;%s%d%d&quot;,ch,&amp;x,&amp;y); if(ch[0]==&apos;C&apos;) &#123; value[x]=y; change(1,dfn[x],y); &#125; else &#123; if(ch[1]==&apos;M&apos;) printf(&quot;%d\\n&quot;,solvemax(x,y)); else printf(&quot;%d\\n&quot;,solvesum(x,y)); &#125; &#125;&#125;int main()&#123; cnt=-1; tot=0; memset(head,-1,sizeof(head)); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); add_edge(a,b); add_edge(b,a); &#125; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;value[i]); dfs1(1,0); dfs2(1,1); solve(); return 0;&#125;","path":"2019/02/04/bzoj-1036-树的统计-树链剖分/"},{"title":"bzoj 1008 越狱","text":"描述: 有n个人排成一列，一共有m种势力，每个人可能属于一个势力，相邻的人势力相同则不合法，一共有多少种可能的不合法状态。 思路: 所有的状态是mnm^{n}mn,正面很难求不合法的状态，所以想到先求合法状态，第一个人有mmm种选择，剩下的人都只有m−1m-1m−1种选择，所以答案就是mn−m∗(m−1)n−1m^{n}-m*(m-1)^{n-1}mn−m∗(m−1)n−1。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=100003;ll m,n;ll quick_pow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=(res*a)%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; while(~scanf(&quot;%lld %lld&quot;,&amp;m,&amp;n)) &#123; ll ans=(quick_pow(m,n)-(m*quick_pow(m-1,n-1))%mod+mod)%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","path":"2019/02/04/bzoj-1008-越狱/"},{"title":"bzoj1003 预处理最短路+区间dp","text":"描述: 给一个图，让你跑n次最短路，第i次最短路有若干点是不能使用的，并且更改一次路线就又需要加k的额外花费，问跑完n次以后最小花费。 思路: 想到把n次最短路分割成多个区间最短路的和，一个区间内最短路是不变的，对于每种最短路，我们可以预处理，因为只有n方的区间，n最大100，点最多只有20个，先跑n方的spfa。设dp[i][j]表示第i次到第j次最短路的所有花费的最小值。那么答案就是dp[1][n]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200;const int maxm=1000;int cnt=-1,n,m,k,e;int head[maxn],use[110][110],dist[maxn],dp[110][110];bool inq[maxn];struct Edge&#123; int nex; int to,w;&#125; edge[maxm];void add_edge(int u,int v,int w)&#123; edge[++cnt].nex=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool check(int x,int s,int t)&#123; for(int i=s; i&lt;=t; i++) if(!use[x][i]) return false; return true;&#125;int spfa(int s,int t)&#123; memset(dist,0x3f,sizeof(dist)); memset(inq,false,sizeof(inq)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); que.push(1); dist[1]=0; inq[1]=true; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=false; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(check(v,s,t)&amp;&amp;dist[v]&gt;dist[u]+edge[i].w) &#123; dist[v]=dist[u]+edge[i].w; if(!inq[v]) inq[v]=true,que.push(v); &#125; &#125; &#125; return dist[m]==0x3f3f3f3f ? 0x3f3f3f3f:dist[m]*(t-s+1);&#125;void solve()&#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=i; j&lt;=n; j++) dp[i][j]=spfa(i,j); &#125; int e; for(int len=2; len&lt;=n; len++) for(int s=1; (e=s+len-1)&lt;=n; s++) for(int p=s; p&lt;s+len-1; p++) &#123; dp[s][e]=min(dp[s][e],dp[s][p]+dp[p+1][e]+k); &#125; printf(&quot;%d\\n&quot;,dp[1][n]);&#125;int main()&#123; while(~scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;k,&amp;e)) &#123; memset(head,-1,sizeof(head)); cnt=-1; for(int i=1; i&lt;maxm; i++) edge[i].nex=-1; for(int i=1; i&lt;=e; i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,c); add_edge(b,a,c); &#125; memset(use,1,sizeof(use)); int tem; scanf(&quot;%d&quot;,&amp;tem); for(int i=1; i&lt;=tem; i++) &#123; int p,a,b; scanf(&quot;%d %d %d&quot;,&amp;p,&amp;a,&amp;b); for(int j=a; j&lt;=b; j++) use[p][j]=0; &#125; solve(); &#125;&#125;","path":"2019/02/04/bzoj1003-预处理最短路-区间dp/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","path":"2019/01/31/hello-world/"}]}
{"pages":[{"title":"","text":"Al1yf5cTUE","path":"baidu_verify_Al1yf5cTUE.html"},{"title":"about-me","text":"测试","path":"about-me/index.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"categories","text":"","path":"categories/index.html"}],"posts":[{"title":"Hdu 6440 Dream","text":"描述:$重新定义加法和乘法，使得对于p是素数时(a+b)^{p}=a^{p}+b^{p}。$ 思路:$根据费马小定理有x^{p-1}与1在模p的意义下同余(p是素数)。 \\\\ 于是做如下定义：a+b=(a+b) \\mod p \\\\ ab=ab \\mod p \\\\ 易证 (a+b)^{p}=a^{p}+b^{p}=(a+b) \\mod p $ 12345678910111213141516171819202122232425262728293031323334include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;using namespace std;int t,p;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;p); for(int i=1; i&lt;=p; i++) &#123; for(int j=1; j&lt;=p; j++) &#123; printf(&quot;%d &quot;,((i-1)%p+(j-1)%p)%p); &#125; printf(&quot;\\n&quot;); &#125; for(int i=1; i&lt;=p; i++) &#123; for(int j=1; j&lt;=p; j++) &#123; printf(&quot;%d &quot;,((i-1)%p*(j-1)%p)%p); &#125; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125;","path":"2019/02/04/Hdu-6440-Dream/"},{"title":"2018Hdu暑期多校3 L Visual Cube","text":"描述:打印一个长方体。 思路:有意思的模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;char m[85][85];int main()&#123; int t,a,b,c,tem; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); int A=2*a+1+2*b; int B=2*b+2*c+1; for(int i=1; i&lt;=2*b; i++) for(int j=1; j&lt;=2*b-i+1; j++) m[i][j]=&apos;.&apos;; int k=A; for(int i=2*c+2; i&lt;=B; i++) &#123; for(int j=k; j&lt;=A; j++) &#123; m[i][j]=&apos;.&apos;; &#125; k--; &#125; for(int i=2*b+1; i&lt;=B; i+=2) for(int j=1; j&lt;=2*a+1; j++) &#123; if(j%2==1) m[i][j]=&apos;+&apos;; else m[i][j]=&apos;-&apos;; &#125; for(int i=2*b+2; i&lt;=B-1; i+=2) for(int j=1; j&lt;=2*a+1; j++) &#123; if(j%2==1) m[i][j]=&apos;|&apos;; else m[i][j]=&apos;.&apos;; &#125; for(int i=1; i&lt;=2*b; i++) for(int j=2*b-i+2; j&lt;=2*b-i+2+2*a+1; j++) &#123; if(i%2==1&amp;&amp;j%2==1) m[i][j]=&apos;+&apos;; else if(i%2==1&amp;&amp;j%2==0) m[i][j]=&apos;-&apos;; else if(i%2==0&amp;&amp;j%2==1) m[i][j]=&apos;.&apos;; else m[i][j]=&apos;/&apos;; &#125; tem=B; for(int i=2*a+1; i&lt;=A; i++) &#123; for(int j=2*b+1+tem-B; j&lt;=tem; j++) &#123; if(i%2==1&amp;&amp;j%2==1) m[j][i]=&apos;+&apos;; else if(i%2==1&amp;&amp;j%2==0) m[j][i]=&apos;|&apos;; else if(i%2==0&amp;&amp;j%2==0)m[j][i]=&apos;/&apos;; else m[j][i]=&apos;.&apos;; &#125; tem--; &#125; for(int i=1; i&lt;=B; i++) &#123; for(int j=1; j&lt;=A; j++) &#123; cout&lt;&lt;m[i][j]; &#125; cout&lt;&lt;endl; &#125; &#125;&#125;","path":"2019/02/04/2018Hdu暑期多校3-L-Visual-Cube/"},{"title":"Poj1679 The Unique MST","text":"描述:判断最小生成树是否唯一。 思路:求次小生成树和最小生成树比较。 对边按照边权排序，边权相同按照边的序号升序排列，然后求最小生成树的边的集合。之后在边权相同时按照边的序号降序排列，又可以得到一组生成树中边的序号集合。如果集合不同说明生成树不唯一。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define M 107#define inf 0x3f3f3fusing namespace std;int g[M][M],path[M][M];int dist[M],pre[M],vis[M];bool used[M][M];int n,m,mst;void init()&#123; for(int i=0; i&lt;=n; i++) for(int j=i+1; j&lt;=n; j++) g[i][j]=g[j][i]=inf;&#125;int prime()&#123; int mst=0; memset(path,0,sizeof(path)); memset(vis,0,sizeof(vis)); memset(used,0,sizeof(used)); vis[1]=1; for(int i=1; i&lt;=n; i++) &#123; dist[i]=g[1][i]; pre[i]=1; &#125; for(int i=1; i&lt;n; i++) &#123; int u=-1; for(int j=1; j&lt;=n; j++) &#123; if(!vis[j]) if(u==-1||dist[j]&lt;dist[u]) u=j; &#125; used[u][pre[u]]=used[pre[u]][u]=true; mst+=g[pre[u]][u]; vis[u]=1; for(int j=1; j&lt;=n; j++) &#123; if(vis[j]&amp;&amp;j!=u) path[j][u]=path[u][j]=max(path[j][pre[u]],dist[u]); if(!vis[j]) if(dist[j]&gt;g[u][j]) &#123; dist[j]=g[u][j]; pre[j]=u; &#125; &#125; &#125; return mst;&#125;int second_tree()&#123; int res=inf; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) if(i!=j&amp;&amp;!used[i][j]) res=min(res,mst-path[i][j]+g[i][j]); return res;&#125;int main()&#123; int t,a,b,c; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); g[a][b]=g[b][a]=c; &#125; mst=prime(); int second_mst=second_tree(); if(mst!=second_mst) cout&lt;&lt;mst&lt;&lt;endl; else cout&lt;&lt;&quot;Not Unique!&quot;&lt;&lt;endl; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int ans;const int N=10000+1;struct edge&#123;int u,v,w,id;&#125;g[N];int f[N];//记得初始化int find(int a) &#123; return a == f[a]?a:f[a] = find(f[a]);&#125; //对边集排序后，对所有边调用join函数就可以得到最小生成树bool join(const edge &amp;e)&#123; if(find(e.u) !=find(e.v))&#123; f[find(e.u)] = find(e.v); ans+=e.w; return true;//ans =max(ans,e.w)，cnt++; &#125; return false;&#125;bool cmp1(edge a,edge b)&#123; if(a.w!=b.w)return a.w&lt;b.w; else return a.id&lt;b.id;&#125;bool cmp2(edge a,edge b)&#123; if(a.w!=b.w)return a.w&lt;b.w; else return a.id&gt;b.id;&#125;int main()&#123; int t; while(cin&gt;&gt;t)while(t--)&#123; int n,m,u,v,w; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;g[i].u&gt;&gt;g[i].v&gt;&gt;g[i].w; g[i].id=i; &#125; string state1,state2; ans=0; sort(g,g+n,cmp1); for(int i=0;i&lt;=n;i++)f[i]=i; for(int i=0;i&lt;m;i++)if(join(g[i]))state1.push_back(g[i].id); ans=0; sort(g,g+n,cmp2); for(int i=0;i&lt;=n;i++)f[i]=i; for(int i=0;i&lt;m;i++)if(join(g[i]))state2.push_back(g[i].id); if(state1!=state2)cout&lt;&lt;&quot;Not Unique!&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Poj1679-The-Unique-MST/"},{"title":"Poj 2299","text":"描述:求一段序列的逆序数对的个数。 思路:和归并排序思路类似,使用树状数组时注意稳定排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=5e5+5;typedef long long ll;int a[maxn];int c[maxn];ll ans;inline void solve(int l,int r)&#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid+1,r); int i=l,j=mid+1,k=l; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; if(a[i]&lt;=a[j]) c[k++]=a[i++]; else c[k++]=a[j++],ans+=mid-i+1; &#125; while(i&lt;=mid) c[k++]=a[i++]; while(j&lt;=r) c[k++]=a[j++]; for(int i=l; i&lt;=r; i++) a[i]=c[i];&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n&gt;0) &#123; ans=0; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); solve(1,n); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/Poj-2299/"},{"title":"Zoj3261 Connections in Galaxy War","text":"描述:$给n个点和m个边，点带权。然后给若干个操作，操作一是删边, \\\\操作二是询问这个点所在连通分量的代表点的编号。所以一个连 \\\\通分量里的代表点，它的权必须是最大的。$ 思路:$ 权最大的是代表点，所以在合并连通分量时以权大的为父亲, \\\\然后我们离线处理每个询问,用map维护。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;int p[10005],a[10005];struct query&#123; char str[10]; int p1,p2;////有2个参数&#125; tem;struct edge&#123; int u,v; bool operator &lt; (const edge &amp;a)const &#123; if(u==a.u) return v&lt;a.v; else return u&lt;a.u; &#125;&#125; e[20005],teme;int findset(int x)&#123; return x==p[x]?p[x]:p[x]=findset(p[x]);&#125;void join(int x,int y)&#123; int px=findset(x),py=findset(y); if(px!=py&amp;&amp;a[px]&gt;=a[py]) p[py]=px; if(px!=py&amp;&amp;a[px]&lt;a[py]) p[px]=py;&#125;int main()&#123; int n,m,aa,bb,q; bool flag=false; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(flag) cout&lt;&lt;endl; flag=true; stack&lt;int&gt;ans; stack&lt;query&gt;st; map&lt;edge,bool&gt;mp; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); p[i]=i; &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;aa,&amp;bb); e[i].u=min(aa,bb); e[i].v=max(aa,bb); mp[e[i]]=true; &#125; scanf(&quot;%d&quot;,&amp;q); for(int i=0; i&lt;q; i++) &#123; scanf(&quot;%s%d&quot;,&amp;tem.str,&amp;tem.p1); if(tem.str[0]==&apos;d&apos;) &#123; scanf(&quot;%d&quot;,&amp;tem.p2); teme.u=min(tem.p1,tem.p2),teme.v=max(tem.p1,tem.p2); mp[teme]=false; st.push(tem); &#125; else tem.p2=-1,st.push(tem); &#125; map&lt;edge, bool&gt;::iterator iter=mp.begin(); while(iter!=mp.end()) &#123; if(iter-&gt;second) &#123; join(iter-&gt;first.u,iter-&gt;first.v); &#125; iter++; &#125; while(!st.empty()) &#123; tem=st.top(); st.pop(); if(tem.str[0]==&apos;q&apos;) &#123; if(a[findset(tem.p1)]==a[tem.p1]) ans.push(-1); else ans.push(findset(tem.p1)); &#125; else join(tem.p1,tem.p2); &#125; while(!ans.empty()) &#123; printf(&quot;%d\\n&quot;,ans.top()); ans.pop(); &#125; &#125; return 0;&#125;","path":"2019/02/04/Zoj3261-Connections-in-Galaxy-War/"},{"title":"Poj 3522 Slim Span","text":"描述:找一棵生成树，且生成树中边权最大差值尽可能小。 思路:$把边权从小到大排序，然后依次枚举生成树中的最小权重，更新差值, \\\\找到答案，算法复杂度为E*log(V)*E。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;int p[105];int Find(int x)&#123; return p[x]==x?x:p[x]=Find(p[x]);&#125;void join(int x,int y)&#123; int px=Find(x),py=Find(y); if(px!=py) p[px]=py;&#125;struct node&#123; int u,v,w;&#125; e[6000];bool cmp(node x,node y)&#123; return x.w&lt;y.w;&#125;int main()&#123; int n,m,t; bool flag; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n+m)) &#123; for(int i=1; i&lt;=m; i++) &#123; cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; &#125; sort(e+1,e+m+1,cmp); flag=false; int ans=1e7; for(int i=1; i&lt;=m; i++) &#123; t=0; int tem; for(int k=0; k&lt;105; k++) p[k]=k; for(int j=i; j&lt;=m&amp;&amp;t&lt;n-1; j++) &#123; int x=Find(e[j].u); int y=Find(e[j].v); if(x!=y) &#123; p[x]=y; t++; tem=j; &#125; &#125; if(t==n-1) &#123; flag=true; ans=min(ans,e[tem].w-e[i].w); &#125; &#125; if(flag) cout&lt;&lt;ans&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Poj-3522-Slim-Span/"},{"title":"Poj 2186 Popular Cows","text":"描述:$有若干cows，如果a崇拜b，b崇拜c那么a崇拜c，求有多少cows \\\\被其他的所有cows崇拜。$ 思路:$建立有向图，然后缩点，需要找的点就是出度为0的点。 \\\\证明:若有一点a出度不为0且a到b有一条边，由于是DAG \\\\可知不存在从b到a的路径，所以a不是所求点，又发现若 \\\\出度为0的点数量大于1时必然不满足题意,这些点之间不 \\\\存在有向边。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=20005;const int maxm=50005;struct Edge&#123; int to,next;&#125; edge[maxm];int head[maxn],tot;int index,top;int Low[maxn],Dfn[maxn],Stack[maxn],Belong[maxn];int mark[maxn];int scc;bool Instack[maxn];int num[maxn];int n,m,x,y;void addedge(int u,int v)&#123; edge[tot].to=v; edge[tot].next=head[u]; head[u]=tot++;&#125;void Tarjan(int u)&#123; int v; Low[u]=Dfn[u]=++index; Stack[top++]=u; Instack[u]=true; for(int i=head[u]; i!=-1; i=edge[i].next) &#123; v=edge[i].to; if(!Dfn[v]) &#123; Tarjan(v); if(Low[u]&gt;Low[v]) Low[u]=Low[v]; &#125; else if(Instack[v]&amp;&amp;Low[u]&gt;Dfn[v]) Low[u]=Dfn[v]; &#125; if(Low[u]==Dfn[u]) &#123; scc++; do &#123; v=Stack[--top]; Instack[v]=false; Belong[v]=scc; num[scc]++; &#125; while(v!=u); &#125;&#125;void solve(int n)&#123; memset(Dfn,0,sizeof(Dfn)); memset(Low,0,sizeof(Low)); memset(Instack,false,sizeof(Instack)); memset(num,0,sizeof(num)); memset(mark,0,sizeof(mark)); index=scc=top=0; for(int i=1; i&lt;=n; i++) if(!Dfn[i]) Tarjan(i); for(int i=1; i&lt;=n; i++) for(int j=head[i]; j!=-1; j=edge[j].next) &#123; if(Belong[i]!=Belong[edge[j].to]) mark[Belong[i]]=true; &#125; int pos=0,lab=0; for(int i=1; i&lt;=scc; i++) if(!mark[i]) &#123; lab++; pos=i; &#125; if(lab&gt;1)printf(&quot;0\\n&quot;); else printf(&quot;%d\\n&quot;,num[pos]);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); tot=0; memset(head,-1,sizeof(head)); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); addedge(x,y); &#125; solve(n);&#125;","path":"2019/02/04/Poj-2186-Popular-Cows/"},{"title":"Hdu 6447 YJJ Salesman","text":"描述:有一个矩阵，某些点有宝物，宝物有权重，某人从左下角出发，只能向右，上，右上走，求取到的物品权重之和最大值。 思路:$首先离散化地图,然后推出朴素的转移方程 \\\\dp[i][j]=max\\{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+w\\}, \\\\N^{2}复杂度对(10)^{5}数据会T。考虑加速dp。先把有宝物 \\\\的地点排序,按照从左向右，从上到下的顺序排序。考虑在 \\\\(x,y)处获得的最大收益，其实就是要求在(x-1,y-1)这个 \\\\矩形内的最大收益加上w(x,y)。这是一个区间最值问题, \\\\还涉及到点修改，可以用树状数组维护。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int t,n,tree[maxn],yy[maxn];struct Node&#123; int x,y,z;&#125; node[maxn];bool cmp(Node a,Node b)&#123; if(a.x==b.x) return a.y&gt;b.y; return a.x&lt;b.x;&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void uppdate(int x,int tem)&#123; for(int i=x; i&lt;=maxn; i+=lowbit(i)) &#123; tree[i]=max(tree[i],tem); &#125;&#125;int query(int x)&#123; int ret=0; for(int i=x; i&gt;=1; i-=lowbit(i)) &#123; ret=max(ret,tree[i]); &#125; return ret;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); memset(tree,0,sizeof(tree)); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].z); yy[i]=node[i].y; &#125; sort(yy+1,yy+n+1); int Size=unique(yy+1,yy+n+1)-yy-1; for(int i=1; i&lt;=n; i++) node[i].y=lower_bound(yy+1,yy+1+Size,node[i].y)-yy; sort(node+1,node+n+1,cmp); int ans=0; for(int i=1; i&lt;=n; i++) &#123; int val=query(node[i].y-1)+node[i].z; ans=max(ans,val); uppdate(node[i].y,val); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu-6447-YJJ-Salesman/"},{"title":"Hdu6434 Count","text":"描述:$求\\sum _{i=1}^n \\sum _{j=1}^{i-1} [gcd(i+j,i-j)=1] $ 思路:$先做变量代换，令a=i-j,先枚举i,再枚举a,然后对等式变形, \\\\题意转化为对于每个i，求有多少个小于它的a满足gcd(i,a)=1 \\\\且a是奇数,当i是奇数时,答案为\\varphi(i)/2,当i是偶数时, \\\\答案是 \\varphi(i),注意特判i=1时,答案为0。$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;typedef long long ll;const int maxn=2e7+5;int phi[maxn];ll sum[maxn];void phi_table()&#123; memset(phi,0,sizeof(phi)); phi[1]=1; for(int i=2; i&lt;maxn; i++)if(!phi[i]) for(int j=i; j&lt;maxn; j+=i) &#123; if(!phi[j]) phi[j]=j; phi[j]=phi[j]/i*(i-1); &#125;&#125;int main()&#123; phi_table(); sum[1]=0; sum[2]=phi[2]; for(int i=3; i&lt;maxn; i++) if(i%2==1) sum[i]=sum[i-1]+phi[i]/2; else sum[i]=sum[i-1]+phi[i]; int t,n; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;sum[n]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu6434-Count/"},{"title":"Hdu6432 Cyclic","text":"描述:$1-n的n个数组成一个环,要求i后面不能放i+1，n后面不能放1 \\\\经旋转能得到的2种视为同一种方案,求所有本质不同的方案数。$ 思路:容斥计数。 1234567891011121314151617181920212223242526272829303132#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;typedef long long ll;const int mod=998244353;const int maxn=1e5+5;ll ans[maxn];int main()&#123; int t,n; cin&gt;&gt;t; ans[0]=1; ans[1]=0; ans[2]=0; ans[3]=1; ans[4]=1; for(int i=5; i&lt;maxn; i++) &#123; ans[i]=((i-3)*ans[i-1]%mod+(i-2)*(2*ans[i-2]+ans[i-3])%mod)%mod; &#125; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;ans[n]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu6432-Cyclic/"},{"title":"Hdu6060 RXD and dividing","text":"描述:$把树上2-n的结点分成k个集合且不能相交,然后每次取出一个集合 \\\\所有点与1号结点形成连通分量把连通分量里的所有边权相加后加 \\\\到ans上，求最大的ans。$ 思路:$一条边对于ans的贡献值应该是min\\{k,k的子孙的数量\\}*边权, \\\\然后又是经典的统计子树了。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;const int maxn=1e6+5;struct node&#123; int next,w;&#125;;vector&lt;node&gt;vec[maxn];node tem;int son[maxn],p[maxn];void dfs(int v,int u)&#123; son[v]=1; int len=vec[v].size(); for(int i=0; i&lt;len; i++) &#123; int t=vec[v][i].next; p[t]=vec[v][i].w; dfs(t,v); son[v]+=son[t]; &#125;&#125;int main()&#123; int n,k,u,v,value; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k)) &#123; for(int i=1; i&lt;=n; i++) &#123; vec[i].clear(); son[i]=0; p[i]=0; &#125; for(int i=1; i&lt;=n-1; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;value); tem.next=v; tem.w=value; vec[u].push_back(tem); &#125; dfs(1,0); ll ans=0; for(int i=2;i&lt;=n;i++) &#123; ans+=(ll)p[i]*min(son[i],k); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/Hdu6060-RXD-and-dividing/"},{"title":"Hdu5901","text":"描述:$求n以内素数个数,n最大(10)^{11}$。 思路: 论文题,套模板就好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cmath&gt;#define LL long longusing namespace std;const int N = 5e6 + 5;const int M = 7;const int PM = 2 * 3 * 5 * 7 * 11 * 13 * 17;int np[N];int prime[N], pi[N];int phi[PM+1][M+1], sz[M+1];int getprime()&#123; int cnt = 0; np[0] = np[1] = 1; pi[0] = pi[1] = 0; for(int i = 2; i &lt; N; ++i) &#123; if(!np[i]) prime[++cnt] = i; pi[i] = cnt; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j) &#123; np[i * prime[j]] = 1; if(i % prime[j] == 0) break; &#125; &#125; return cnt;&#125;void init()&#123; getprime(); sz[0] = 1; for(int i = 0; i &lt;= PM; ++i) phi[i][0] = i; for(int i = 1; i &lt;= M; ++i) &#123; sz[i] = prime[i] * sz[i-1]; for(int j = 1; j &lt;= PM; ++j) phi[j][i] = phi[j][i-1] - phi[j/prime[i]][i-1]; &#125;&#125;int sqrt2(LL x)&#123; LL r = (LL)sqrt(x - 0.1); while(r*r &lt;= x) ++r; return (int)(r-1);&#125;int sqrt3(LL x)&#123; LL r = (LL)cbrt(x - 0.1); //cbrt(x): x的立方根 while(r*r*r &lt;= x) ++r; return (int)(r-1);&#125;LL getphi(LL x, int s)&#123; if(s == 0) return x; if(s &lt;= M) return phi[x%sz[s]][s] + (x/sz[s]) * phi[sz[s]][s]; if(x &lt;= prime[s]*prime[s]) return pi[x] - s + 1; if(x &lt;= prime[s]*prime[s]*prime[s] &amp;&amp; x &lt; N) &#123; int s2x = pi[sqrt2(x)]; LL ans = pi[x] - (s2x+s-2)*(s2x-s+1)/2; for(int i = s+1; i &lt;= s2x; ++i) ans += pi[x/prime[i]]; return ans; &#125; return getphi(x, s-1) - getphi(x/prime[s], s-1);&#125;LL getpi(LL x)&#123; if(x &lt; N) return pi[x]; LL ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1; for(int i = pi[sqrt3(x)]+1, ed = pi[sqrt2(x)]; i &lt;= ed; ++i) ans -= getpi(x/prime[i]) - i + 1; return ans;&#125;LL lehmer_pi(LL x)&#123; if(x &lt; N) return pi[x]; int a = (int)lehmer_pi(sqrt2(sqrt2(x))); int b = (int)lehmer_pi(sqrt2(x)); int c = (int)lehmer_pi(sqrt3(x)); LL sum = getphi(x, a) + (LL)(b+a-2) * (b-a+1)/2; for (int i = a+1; i &lt;= b; ++i) &#123; LL w = x/prime[i]; sum -= lehmer_pi(w); if(i &gt; c) continue; LL lim = lehmer_pi(sqrt2(w)); for(int j = i; j &lt;= lim; ++j) sum -= lehmer_pi(w/prime[j]) - (j-1); &#125; return sum;&#125;int main()&#123; LL n; init(); while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; printf(&quot;%lld\\n&quot;, lehmer_pi(n)); &#125; return 0;&#125;","path":"2019/02/04/Hdu5901/"},{"title":"Hdu 1695","text":"描述:$求i \\in [1,m],j \\in [1,n],gcd(i,j)=k的pair数。$ 思路:莫比乌斯反演入门题,套个容斥去重。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;bool check[maxn];ll prime[maxn];ll mu[maxn];void mobius()&#123; memset(check,false,sizeof(check)); mu[1]=1; int tot=0; for(int i=2; i&lt;maxn; i++) &#123; if(!check[i]) &#123; prime[tot++]=i; mu[i]=-1; &#125; for(int j=0; j&lt;tot; j++) &#123; if(i*prime[j]&gt;=maxn) break; check[i*prime[j]]=true; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; else mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;ll t,a,b,c,d,k;__int64 ans,ans2;int main()&#123; mobius(); cin&gt;&gt;t; for(int i=1; i&lt;=t; i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k; if(!k) &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;0&lt;&lt;endl; continue; &#125; ans=0; ans2=0; int minn=min(b/k,d/k); for(int i=1; i&lt;=minn; i++) &#123; ans+=mu[i]*(b/k/i)*(d/k/i); &#125; for(int i=1;i&lt;=minn;i++) &#123; ans2+=mu[i]*(minn/i)*(minn/i); &#125; printf(&quot;Case %d: %I64d\\n&quot;,i,ans-ans2/2); //cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;ans-ans2/2&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu-1695/"},{"title":"2018ICPC徐州网络赛 Maze Designer 最大生成树+LCA","text":"描述:要求删除一些边以后使剩下一棵生成树,并且使得删除的边权和最小,然后询问树上2点的最短距离。 思路:$ 先求原图的最大生成树，然后求LCA。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N=250005;struct node&#123; int v,dis,next;&#125;edges[N&lt;&lt;1];int head[N],e;int id[N]; //节点第一次被遍历的顺序int dis[N]; //节点到根节点的距离int RMQ[N*3][20];int curID;//F[i]表示第i个遍历的节点//B[i]表示F[i]在树中的深度int F[N*3],B[N*3];int root;void init()&#123; e = 0; curID = 0; memset(head,-1,sizeof(head));&#125;void Add (int u,int v,int dis)&#123; edges[e].v=v; edges[e].dis=dis; edges[e].next=head[u]; head[u]=e++;&#125;void DFS (int u,int p,int Dep,int d)&#123; int i,v; curID++; F[curID]=u; B[curID]=Dep; id[u]=curID; dis[u]=d; for (i=head[u];i!=-1;i=edges[i].next)&#123; v=edges[i].v; if (v==p) continue; DFS(v,u,Dep+1,d+1); curID++; F[curID]=u; B[curID]=Dep; &#125;&#125;void initRMQ ()&#123; int i,j,x,y; for (i=1;i&lt;=curID;i++) RMQ[i][0]=i; for (j=1;(1&lt;&lt;j)&lt;=curID;j++) for (i=1;i+(1&lt;&lt;j)-1&lt;=curID;i++)&#123; x=RMQ[i][j-1]; y=RMQ[i+(1&lt;&lt;(j-1))][j-1]; RMQ[i][j]=B[x]&lt;B[y]?x:y; &#125;&#125;int getLCA (int a,int b)&#123; int k,x,y; a=id[a];b=id[b]; if (a&gt;b) k=a,a=b,b=k; k=log(1.0+b-a)/log(2.0); x=RMQ[a][k]; y=RMQ[b-(1&lt;&lt;k)+1][k]; return B[x]&lt;B[y]?F[x]:F[y];&#125;int dist(int x,int y)&#123; return dis[x] +dis[y] - 2*dis[getLCA(x,y)];&#125;struct Edg&#123; int u,v; LL dist; bool operator&lt;(const Edg &amp;rhs)const&#123;return dist&gt;rhs.dist;&#125;&#125;;struct Kruskal&#123; int n,m; Edg edges[N&lt;&lt;1]; int fa[N]; int findset(int x)&#123; return fa[x]==-1?x:fa[x]=findset(fa[x]); &#125; void init(int n)&#123; this-&gt;n=n; m=0; memset(fa,-1,sizeof(fa)); &#125; void AddEdge(int u,int v,LL dist)&#123; edges[m++] = (Edg)&#123;u,v,dist&#125;; &#125; void kruskal()&#123; LL sum=0; int cnt=0; sort(edges,edges+m); for(int i=0;i&lt;m;i++)&#123; int u=edges[i].u, v=edges[i].v; if(findset(u) != findset(v))&#123; Add(u,v,1); Add(v,u,1); sum +=edges[i].dist; fa[findset(u)] = findset(v); if(++cnt&gt;=n-1) return ; &#125; &#125; return ; &#125;&#125;G;int main()&#123; int n,m; char c1,c2; LL w1,w2; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; init(); G.init(n*m+1); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; scanf(&quot;\\n%c %lld %c %lld&quot;,&amp;c1,&amp;w1,&amp;c2,&amp;w2); if(c1==&apos;D&apos;)&#123; G.AddEdge((i-1)*m+j,i*m+j,w1); &#125; if(c2 == &apos;R&apos;)&#123; G.AddEdge((i-1)*m+j,(i-1)*m+j+1,w2); &#125; &#125; &#125; G.kruskal(); root=1; DFS(root,0,0,0); initRMQ(); int Q; scanf(&quot;%d&quot;,&amp;Q); int x1,y1,x2,y2; while(Q--)&#123; scanf(&quot;%d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); int u = (x1-1)*m+y1, v = (x2-1)*m+y2; printf(&quot;%d\\n&quot;,dist(u,v)); &#125; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC徐州网络赛-Maze-Designer-最大生成树-LCA/"},{"title":"2018牛客国庆训练营 day6","text":"C&amp;H签到。 G:对方格染色，使得在所有操作后，每种颜色的sum都相同。 12345678910111213141516171819202122232425262728293031323334include&lt;bits/stdc++.h&gt;using namespace std;int a[1005][1005];int color[1005][1005];int n,ans,tem,sum;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; scanf(&quot;%d&quot;,&amp;a[i][j]); color[i][j]=(i+j)%n; if(a[i][j]==-1) tem=color[i][j]; &#125; &#125; int _color,_sum=0; if(tem==n-1) _color=n-2; else _color=n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(color[i][j]==_color) _sum+=a[i][j]; if(color[i][j]==tem&amp;&amp;a[i][j]!=-1) sum+=a[i][j]; &#125; &#125; printf(&quot;%d\\n&quot;,_sum-sum);&#125; A:$拆点以后跑费用流,每个区域拆成n个点，一个蛋糕和第i层连边，其 \\\\费用是i*i-(i-1)*(i-1)。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;const int maxn=5005;const int maxm=50005;int s,t;int num=-1,tot,sum;int dis[maxn],b[maxn],xb[maxn],flow[maxn],fa[maxn];int head[maxm];struct Edge&#123; int from,to,dis,nxt,w;&#125; edge[maxm*2];void add_edge(int from,int to,int w,int dis)&#123; edge[++num].nxt=head[from]; edge[num].from=from; edge[num].to=to; edge[num].w=w; edge[num].dis=dis; head[from]=num;&#125;bool spfa()&#123; for(int i=0; i&lt;=maxn; i++) dis[i]=inf; memset(b,0,sizeof(b)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); memset(fa,-1,sizeof(fa)); b[s]=1; dis[s]=0; fa[s]=0; flow[s]=inf; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); b[u]=0; for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(edge[i].w&gt;0&amp;&amp;dis[v]&gt;dis[u]+edge[i].dis) &#123; dis[v]=dis[u]+edge[i].dis; fa[v]=u; xb[v]=i; flow[v]=min(flow[u],edge[i].w); if(!b[v]) &#123; b[v]=1; que.push(v); &#125; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;void max_flow()&#123; while(spfa()) &#123; int k=t; while(k!=s) &#123; edge[xb[k]].w-=flow[t]; edge[xb[k]^1].w+=flow[t]; k=fa[k]; &#125; tot+=flow[t]; sum+=flow[t]*dis[t]; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; for(int j=1; j&lt;=n; j++) &#123; add_edge(i,n+(j-1)*m+a,1,2*j-1); add_edge(n+(j-1)*m+a,i,0,1-2*j); add_edge(i,n+(j-1)*m+b,1,2*j-1); add_edge(n+(j-1)*m+b,i,0,1-2*j); &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; add_edge(0,i,1,0); add_edge(i,0,0,0); &#125; for(int i=n+1; i&lt;=n+n*m; i++) &#123; add_edge(i,n+n*m+1,1,0); add_edge(n+n*m+1,i,0,0); &#125; s=0; t=n+n*m+1; max_flow(); cout&lt;&lt;sum&lt;&lt;endl;&#125;","path":"2019/02/04/2018牛客国庆训练营-day6/"},{"title":"2018牛客国庆集训派对 day3","text":"D:签到。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;double a[1050];int b[1050];bool cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; int cnt=0; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; if(b[i]) cnt++; &#125; sort(a,a+n,cmp); double ans=0; cnt=min(cnt,m); for(int i=0;i&lt;cnt;i++) &#123; ans+=a[i]/2; &#125; for(int i=cnt;i&lt;n;i++) ans+=a[i]; printf(&quot;%.1f\\n&quot;,ans); &#125;&#125; H:发现和树的结构没有关系，只要考虑如何把树上的结点分成几部分，推完发现是个组合数取模，预处理阶乘，用乘法逆元即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;const int mod=1e9+7;ll fac[maxn];void init_fac()&#123; fac[0]=fac[1]=1; for(int i=2;i&lt;maxn;i++) fac[i]=i*fac[i-1]%mod;&#125; ll quickpow(ll a,ll n)&#123; ll ret=1; while(n) &#123; if(n&amp;1) ret=ret*a%mod; a=a*a%mod; n&gt;&gt;=1; &#125; return ret;&#125;ll C(ll a,ll b)&#123; return fac[a]*quickpow(fac[b],mod-2)%mod*quickpow(fac[a-b],mod-2)%mod;&#125; int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); init_fac(); while(t--) &#123; int n,m; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;n;i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); &#125; ll ans=C(n-1,m-1)*fac[m]%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125; A:马走日问题，因为棋盘太大，可以大范围贪心+小范围暴搜。题解是找规律。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x, y, ans; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;x&gt;&gt;y; x=abs(x); y=abs(y); if(x&gt;y)swap(x, y); if(y==x*2) &#123; printf(&quot;%d\\n&quot;, (x+y)/3); continue; &#125; if(y&lt;=2*x) &#123; if(x==1&amp;&amp;y==1) ans = 2; else if(x==2&amp;&amp;y==2) ans = 4; else ans = (x+y)/3+(x+y)%3; &#125; else &#123; ans=x; int c=(y-2*x)%4; ans+=c; ans+=(y-2*x-c)/2; if(y==1&amp;&amp;x==0) ans=3; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/2018牛客国庆集训派对-day3/"},{"title":"2018牛客国庆集训派对day1 J Princess Principal","text":"描述:给出一个括号序列，然后给出多组询问，每次判断一个区间里的括号是否是匹配的。 思路:$对于一个括号序列，如果想让所有的括号尽可能多的匹配，每个单 \\\\括号应该只对应唯一的另一个单括号与它匹配。那么就可以比较加入 \\\\a_l之前栈里留下的括号的状态和加入a_r以后栈里留下的括号的状态, \\\\如果一样，相当于这段区间的括号消掉了。$ $思路二，已知括号序列的匹配方式是唯一的，如果在区间里任意取出 \\\\一个单括号,与它匹配的单括号也必须在这个区间里。所以先预处理与 \\\\每一个位置单括号匹配的另一个单括号的编号x_i。 但是这时查询一个 \\\\区间的复杂度仍然是线性的。 但其实只需要查询这个区间里x_i的最大值 \\\\和最小值即可，最大值是右端点，最小值是左端点说明这个区间匹配。$ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,m,q;int a[maxn],x[maxn];stack&lt;int&gt;s;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); while(!s.empty()) s.pop(); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=n;i++) &#123; if(s.empty()||!(a[i]&amp;1)) s.push(i); else if(a[s.top()]+1==a[i]) s.pop(); else s.push(i); if(s.empty()) x[i]=0; else x[i]=s.top(); &#125; while(q--) &#123; int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); if(x[l-1]==x[r]) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,m,q;int a[maxn],b[maxn],x[maxn&lt;&lt;2],y[maxn&lt;&lt;2];stack&lt;int&gt;s;void build(int R,int l,int r)&#123; if(l==r) &#123; x[R]=b[l]; y[R]=b[l]; return; &#125; int mid=l+r&gt;&gt;1; build(R&lt;&lt;1,l,mid); build(R&lt;&lt;1|1,mid+1,r); x[R]=min(x[R&lt;&lt;1],x[R&lt;&lt;1|1]); y[R]=max(y[R&lt;&lt;1],y[R&lt;&lt;1|1]);&#125;void ask(int R,int l,int r,int ql,int qr,int &amp;u,int &amp;v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) &#123; u=min(u,x[R]); v=max(v,y[R]); return ; &#125; int mid=l+r&gt;&gt;1; if(ql&lt;=mid) ask(R&lt;&lt;1,l,mid,ql,qr,u,v); if(qr&gt;mid) ask(R&lt;&lt;1|1,mid+1,r,ql,qr,u,v);&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,a+i); b[i]=-1; if(s.empty()||!(a[i]&amp;1)) s.push(i); else if (a[s.top()]+1==a[i]) b[i]=s.top(),b[s.top()]=i,s.pop(); else s.push(i); &#125; build(1,1,n); while(q--) &#123; int ql,qr; scanf(&quot;%d %d&quot;,&amp;ql,&amp;qr); int _1=1e9,_2=-2; ask(1,1,n,ql,qr,_1,_2); if(_1==ql&amp;&amp;_2==qr) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;","path":"2019/02/04/2018牛客国庆集训派对day1-J-Princess-Principal/"},{"title":"2018牛客暑期多校训练四 A gpa 01分数规划","text":"描述:$给一个数列a和一个数列b，然后从这两个数列中中最多删除k个项, \\\\即同时删除a_i和b_i，求剩下来的\\sum (a_i*b_i)/\\sum a_i最大值。$ 思路:$设\\sum (a_i*b_i)/ \\sum a_i \\ge D $ $变形\\sum (a_i*b_i) \\ge (\\sum a_i)*D$ $变形\\sum (a_i*(b_i-D)) \\ge 0$ $然后二分D 把s_i排个序，至多删除k项，就把就k小的项都删除，判断 \\\\剩下来的项的和，把和与0比较进行二分。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;typedef long double ld;const double eps=1e-6;struct node&#123; double s,c;&#125; p[100005];double d[100005];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;p[i].s; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i].c; &#125; memset(d,0,sizeof(d)); double r=1000; double l=0; double mid; while(r-l&gt;eps) &#123; double sum=0; mid=(r+l)/2; for(int i=0; i&lt;n; i++) d[i]=p[i].s*p[i].c-p[i].s*mid; sort(d,d+n); for(int i=k; i&lt;n; i++) sum+=d[i]; if(sum&gt;=0) l=mid; else r=mid; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l&lt;&lt;endl;&#125;","path":"2019/02/04/2018牛客暑期多校训练四-A-gpa-01分数规划/"},{"title":"2018ICPC南京网络赛 分层图最短路","text":"描述:$考虑边带权的图，已知源点和终点，如果可以使的图里的k条边\\\\边权变成0，最短路是多少。$ 思路:$把图分成k层，每层仍然是n个点，每层的连边方式仍然和原图相同。\\\\除此以外，层与层之间该如何连边?假设现在在第i层，点u和点v之间\\\\有一条权值w的边，对于下一层，即i+1层，u’与v’之间仍是有一条\\\\权为w的边，且对于u与v’之间应该加上一条边权为0的边。$ $拆点以后在新图上跑最短路。另外此题卡SPFA，\\\\用优化后的dijkstra即可。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF=1e18;const int maxn=1200000;const int maxm=4500000;int t,n,m,k,a,b,c,cnt;bool done[maxn];ll d[maxn];struct Edge&#123; int u,v,nex; ll w;&#125; edge;Edge g[maxm];int head[maxn];void add(int u,int v,ll w)&#123; g[cnt].u=u; g[cnt].v=v; g[cnt].w=w; g[cnt].nex=head[u]; head[u]=cnt++;&#125;struct HeapNode&#123; int d,u; bool operator &lt; (const HeapNode&amp; rhs)const &#123; return d&gt;rhs.d; &#125;&#125; node;inline void dijkstra(int s)&#123; priority_queue&lt;HeapNode&gt;Q; memset(d,0x3f,sizeof(d)); d[s]=0; memset(done,false,sizeof(done)); Q.push(HeapNode&#123;0,s&#125;); while(!Q.empty()) &#123; HeapNode x=Q.top(); Q.pop(); int u=x.u; if(done[u]) continue; done[u]=true; for(int i=head[u]; i+1; i=g[i].nex) &#123; if(d[g[i].v]&gt;d[u]+g[i].w) &#123; d[g[i].v]=d[u]+g[i].w; Q.push(HeapNode&#123;d[g[i].v],g[i].v&#125;); &#125; &#125; &#125;&#125;inline int read()&#123; char c=getchar(); int x=0,f=1; while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;) &#123; if(c==&apos;-&apos;)f=-1; c=getchar(); &#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) &#123; x=x*10+c-&apos;0&apos;; c=getchar(); &#125; return x*f;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;t)) &#123; while(t--) &#123; //scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); n=read(); m=read(); k=read(); cnt=0; memset(head,-1,sizeof(head)); for(int i=1; i&lt;=m; i++) &#123; //scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); a=read(); b=read(); c=read(); add(a,b,c); for(int j=1; j&lt;=k; j++) &#123; add(j*n+a,j*n+b,c); add((j-1)*n+a,j*n+b,0); &#125; &#125; dijkstra(1); ll ans=INF; for(int i=1; i&lt;=k+1; i++) &#123; ans=min(ans,d[i*n]); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC南京网络赛-分层图最短路/"},{"title":"2018ICPC南京网络赛 AC Challenge 状压dp","text":"描述:$n个题，做每个题之前必须把限制的某几个题做完。\\\\做第i个题的得分是a*w_i+b,w_i是第i题权重，a,b$都是常数，问能得到的最高分。 思路:考虑到$n$最大只有20，且每个题只有做和不做两种状态，所以可以状压dp。 对于每个状态的枚举时，首先判断这种状态是否符合条件。如果这种状态是符合条件的，那考虑这种状态中所有已经做了的题，分别把它们状态设为没做，这样就找到所有能转移到目前状态的前驱状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;int t;struct Node&#123; int a,b,s;&#125; node[25];vector&lt;int&gt;vec[25];int dp[(1&lt;&lt;20)+1];int main()&#123; while(cin&gt;&gt;t) &#123; for(int i=1; i&lt;=t; i++) &#123; cin&gt;&gt;node[i].a&gt;&gt;node[i].b&gt;&gt;node[i].s; int tem; for(int j=1; j&lt;=node[i].s; j++) &#123; cin&gt;&gt;tem; vec[i].push_back(tem); &#125; &#125; memset(dp,0,sizeof(dp)); int ans=0; for(int i=0; i&lt;(1&lt;&lt;t); i++) &#123; bool ok=true; for(int j=1; j&lt;=t; j++) &#123; if(!(i&amp;(1&lt;&lt;(j-1)))) continue; for(int k=0;k&lt;vec[j].size();k++) &#123; int tmp=vec[j][k]; if(!(i&amp;(1&lt;&lt;(tmp-1)))) &#123; ok=false; break; &#125; &#125; if(!ok) break; &#125; if(!ok) continue;//如果不满足大条件 就丢掉 for(int j=1;j&lt;=t;j++) &#123; if(!(i&amp;(1&lt;&lt;(j-1)))) continue;//这题做过的才能继续这个算法 int s=i,cnt=0;//统计i的二进制里有几个1，也就是有几题做过 while(s) &#123; if(s&amp;1) cnt++; s/=2; &#125; dp[i]=max(dp[i],dp[i^(1&lt;&lt;(j-1))]+cnt*node[j].a+node[j].b);//让做过的这题没做就是前一个状态 &#125; ans=max(ans,dp[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC南京网络赛-AC-Challenge-状压dp/"},{"title":"2018ICPC北京网络赛D 80days 尺取法","text":"描述:传送门 思路:有环，易想到复制一份在后面，然后考虑枚举起点，尺取法双指针扫描即可，复杂度为线性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+5;int t;int n,k;int a[maxn],b[maxn],c[maxn&lt;&lt;1];int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) &#123; c[i]=a[i]-b[i]; c[n+i]=a[i]-b[i]; &#125; int l=1,r=1; ll tem=0; bool ok=true; while(l&lt;=n&amp;&amp;r-l+1&lt;=n) &#123; if(!ok) break; if(tem+c[r]+k&gt;=0) &#123; tem+=c[r]; r++; &#125; else &#123; tem+=c[r]; r++; while(tem+k&lt;0) &#123; tem-=c[l]; l++; if(l&gt;r) &#123; ok=false; break; &#125; &#125; &#125; &#125; if(!ok||l&gt;n) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;l&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC北京网络赛D-80days-尺取法/"},{"title":"2018Hdu 多校训练一 Time Zone","text":"描述:模拟时区，时区可以是小数。 思路:大力模拟。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int p,a,b,zs,xs;////直接从字符串里提取小数会有误差，所以这里分两部分提取出来char str[15];int main()&#123; scanf(&quot;%d&quot;,&amp;p); while(p--) &#123; scanf(&quot;%d%d%s&quot;,&amp;a,&amp;b,&amp;str); if(str[5]==&apos;.&apos;)zs=str[4]-&apos;0&apos;,xs=str[6]-&apos;0&apos;; else if(str[6]==&apos;.&apos;) zs=(str[4]-&apos;0&apos;)*10+str[5]-&apos;0&apos;,xs=str[7]-&apos;0&apos;; else if(str[5]==&apos;\\0&apos;) zs=str[4]-&apos;0&apos;,xs=0; else if(str[6]==&apos;\\0&apos;) zs=(str[4]-&apos;0&apos;)*10+str[5]-&apos;0&apos;,xs=0; if(str[3]==&apos;-&apos;) zs=-zs,xs=-xs; if(zs&gt;=8) &#123; if(xs*6+b&gt;=60) &#123; b=(xs*6+b)%60; a=(a+1+zs-8+24)%24; &#125; else b=xs*6+b,a=(a+zs-8+24)%24; if(a&gt;=10&amp;&amp;b&gt;=10) printf(&quot;%d:%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&lt;10) printf(&quot;0%d:0%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&gt;=10) printf(&quot;0%d:%d\\n&quot;,a,b); else if(a&gt;=10&amp;&amp;b&lt;10) printf(&quot;%d:0%d\\n&quot;,a,b); &#125; else if(zs&lt;8) &#123; int h=(80-(zs*10+xs))*6/60; int m=(80-(zs*10+xs))*6-h*60; if(m&gt;b) &#123; b=b+60-m; a=(a-1-h+24)%24; &#125; else b=b-m,a=(a-h+24)%24; if(a&gt;=10&amp;&amp;b&gt;=10) printf(&quot;%d:%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&lt;10) printf(&quot;0%d:0%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&gt;=10) printf(&quot;0%d:%d\\n&quot;,a,b); else if(a&gt;=10&amp;&amp;b&lt;10) printf(&quot;%d:0%d\\n&quot;,a,b); &#125; &#125;&#125;","path":"2019/02/04/2018Hdu-多校训练一-Time-Zone/"},{"title":"牛客练习赛22-C简单瞎搞题 bitset+dp","text":"描述:给出$n$个区间，然后分别给出区间的左右边界，可以在每个区间中选择一个整数，问这$n$个整数的平方和有多少种不同的取值。 思路:$ f_i $表示一个bitset，bitset里有几个1，就表示这i个区间所能得到的平方和的取值种数。 转移方程为 f[i]=f[i] | f[i-1]&lt;&lt;k^k (k from l to r) 状态转移的复杂度是n，每次操作对应的复杂度是l-r。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;bitset&gt;using namespace std;bitset&lt;1000000+10&gt;f[105];int main()&#123; int n,l,r; cin&gt;&gt;n; f[0][0]=1; for (int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;l, &amp;r); for(int j=l; j&lt;=r; j++) &#123; f[i]=f[i]|f[i-1]&lt;&lt;j*j; &#125; &#125; printf(&quot;%d\\n&quot;, f[n].count()); return 0;&#125;","path":"2019/02/04/牛客练习赛22-C简单瞎搞题-bitset-dp/"},{"title":"Poj 3281 Dining 最大流","text":"描述:有一些牛，食物，饮料，每头牛都有一个喜欢吃的食物和饮料集合，要求你找出一个最大匹配，能满足所有牛的需求。 思路:拆点以后跑最大流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500;const int maxm=210000;const int inf=1e9;int cnt=-1,f,d,n,s,t;int head[maxn],dep[maxn],cur[maxn];struct Edge&#123; int nxt; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; edge[++cnt].nxt=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=f+2*n+d+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; for(int i=0; i&lt;maxm*2; i++) edge[i].nxt=-1; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;f,&amp;d); s=f+2*n+d+1; t=f+2*n+d+2; for(int i=1; i&lt;=n; i++) &#123; int a,b,tem; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); for(int j=1;j&lt;=a;j++) &#123; scanf(&quot;%d&quot;,&amp;tem); add_edge(tem,f+i,1); add_edge(f+i,tem,0); &#125; for(int j=1;j&lt;=b;j++) &#123; scanf(&quot;%d&quot;,&amp;tem); add_edge(f+n+i,f+2*n+tem,1); add_edge(f+2*n+tem,f+n+i,0); &#125; add_edge(f+i,f+n+i,1); add_edge(f+n+i,f+i,0); &#125; for(int i=1;i&lt;=f;i++) &#123; add_edge(s,i,1); add_edge(i,s,0); &#125; for(int i=1;i&lt;=d;i++) &#123; add_edge(f+2*n+i,t,1); add_edge(t,f+2*n+i,0); &#125; printf(&quot;%d\\n&quot;,Dinic());&#125;","path":"2019/02/04/Poj-3281-Dining-最大流/"},{"title":"Poj 3041 Asteroids 最小点覆盖","text":"描述:有一个500*500的网格图，格点上有一些点，每次可以消除一行或者一列上所有的点，问消除所有的点最少需要几次。 思路:因为要消除一个点,只有2种方式，并且一行或者一列多次消除是没有意义的。可以考虑构建一个二分图，左边是所有的行，右边是所有的列，把待消除的点作为边，一个点会唯一连一条边，那么题意转化为了，选择二分图上的点，把与这个点连的边加入一个集合，这个集合应该包含了所有边，最少选择的点的个数，问题转化为了最小点覆盖。 二分图里最小点覆盖等于最大匹配，跑一遍最大流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1100;const int maxm=260000;const int inf=1e9;int cnt=-1,n,k,s,t;int head[maxn],dep[maxn],cur[maxn];struct Edge&#123; int nxt; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; edge[++cnt].nxt=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=2*n+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; //建图 左边点1-N(行) 右边点N+1， 2N 源点2N+1,汇点2N+2; for(int i=0;i&lt;maxm*2;i++) edge[i].nxt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); memset(head,-1,sizeof(head)); cnt=-1; for(int i=1;i&lt;=k;i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); add_edge(x,y+n,1); add_edge(y+n,x,0); &#125; for(int i=1;i&lt;=n;i++) &#123; add_edge(2*n+1,i,1); add_edge(i,2*n+1,0); add_edge(i+n,2*n+2,1); add_edge(2*n+2,i+n,0); &#125; s=2*n+1; t=2*n+2; printf(&quot;%d\\n&quot;,Dinic());&#125;","path":"2019/02/04/Poj-3041-Asteroids-最小点覆盖/"},{"title":"Poj 2135 Farm Tour 费用流","text":"描述:给出起点和终点，要求从起点走到终点，再从终点回来，走的路最短，且来回走的路中不能有相同的边。 思路:不要考虑来回，其实本质就是选择两条路，边权和最小，所以我们可以跑一个最大流是2的费用流。(选n条路就跑最大流是n的费用流) 本题所有边都是无向边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;const int maxn=2000;const int maxm=11000;int n,m,s,t;int cnt=-1,tot,sum;int dis[maxn],b[maxn],xb[maxn],flow[maxn],fa[maxn];int head[maxm];struct Edge&#123; int from,to,dis,nxt,w;&#125;edge[maxm*4];void add_edge(int from,int to,int w,int dis)&#123; edge[++cnt].nxt=head[from]; edge[cnt].from=from; edge[cnt].to=to; edge[cnt].w=w; edge[cnt].dis=dis; head[from]=cnt;&#125;bool spfa()&#123; for(int i=0;i&lt;=maxn;i++) dis[i]=inf; memset(b,0,sizeof(b)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); memset(fa,-1,sizeof(fa)); b[s]=1; dis[s]=0; fa[s]=0; flow[s]=inf; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); b[u]=0; for(int i=head[u];i!=-1;i=edge[i].nxt) &#123; int v=edge[i].to; if(edge[i].w&amp;&amp;dis[v]&gt;dis[u]+edge[i].dis) &#123; dis[v]=dis[u]+edge[i].dis; fa[v]=u; xb[v]=i; flow[v]=min(flow[u],edge[i].w); if(!b[v]) &#123; b[v]=1; que.push(v); &#125; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;void max_flow()&#123; while(spfa()) &#123; int k=t; while(k!=s) &#123; edge[xb[k]].w-=flow[t]; edge[xb[k]^1].w+=flow[t]; k=fa[k]; &#125; tot+=flow[t]; sum+=flow[t]*dis[t]; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); s=n+1; t=n+2; for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,1,c); add_edge(b,a,0,-c); add_edge(b,a,1,c); add_edge(a,b,0,-c); &#125; add_edge(s,1,2,0); add_edge(1,s,0,0); add_edge(n,t,2,0); add_edge(t,n,0,0); max_flow(); printf(&quot;%d\\n&quot;,sum);&#125;","path":"2019/02/04/Poj-2135-Farm-Tour-费用流/"},{"title":"Hdu1569 洛谷P2774方格取数 状压dp or 最小割","text":"描述:给一个$n*m$的方格，每个格子里有个正数，要求选择若干数，这些数所在方格不能有相邻的边，要求选择的数的和最大。 思路:状压dp玄学爆过去了,然而复杂度算下来不对。 正解是网络流。对方格染色，把方格变成二分图，把所有点的权相加，去掉最小割就是我们所要的答案了，所以具体的建图方式为：源点与黑色点连，汇点与白色点连，容量都是点权。然后又因为选了一个点以后会影响它相邻的点，这些边是不会出现在割集中的，所以把这些边的容量置inf。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=15000;const int maxm=50000;const int inf=1e9;int cnt=-1,n,m,s,t,sum;int head[maxn],dep[maxn],cur[maxn];struct P&#123; int id,w;&#125;;vector&lt;P&gt;_1,_2;struct Edge&#123; int next=-1; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; //cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].next) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].next) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=n*m+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; //1-n*n n*n+1,n*n+2m while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; _1.clear(); _2.clear(); sum=0; memset(head,-1,sizeof(head)); cnt=-1; s=n*m+1; t=n*m+2; int _cnt=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; P tem; scanf(&quot;%d&quot;,&amp;tem.w); sum+=tem.w; _cnt++; tem.id=_cnt; if((i+j)&amp;1) _1.push_back(tem); else _2.push_back(tem); &#125; &#125; for(int i=0; i&lt;_1.size(); i++) &#123; add_edge(s,_1[i].id,_1[i].w); add_edge(_1[i].id,s,0); &#125; for(int i=0; i&lt;_2.size(); i++) &#123; add_edge(_2[i].id,t,_2[i].w); add_edge(t,_2[i].id,0); &#125; for(int i=0; i&lt;_1.size(); i++) &#123; if(_1[i].id%m!=0) add_edge(_1[i].id,_1[i].id+1,inf),add_edge(_1[i].id+1,_1[i].id,0); if(_1[i].id%m!=1) add_edge(_1[i].id,_1[i].id-1,inf),add_edge(_1[i].id-1,_1[i].id,0); if(_1[i].id+m&lt;=n*m) add_edge(_1[i].id,_1[i].id+m,inf),add_edge(_1[i].id+m,_1[i].id,0); if(_1[i].id-m&gt;=1) add_edge(_1[i].id,_1[i].id-m,inf),add_edge(_1[i].id-m,_1[i].id,0); &#125; printf(&quot;%d\\n&quot;,sum-Dinic()); &#125;&#125;","path":"2019/02/04/Hdu1569-洛谷P2774方格取数-状压dp-or-最小割/"},{"title":"Hdu 1116 Play on Words 并查集+有向图的欧拉路","text":"描述:类似于成语接龙，给若干个单词，问能否组成一个排列，使得一个单词的尾字母和后面一个单词的首字母相同。例如acm，malform，mouse这三个单词就满足题意。 思路:把每个单词看成一条边，取首字母和尾字母，作为起点和终点。建图，图上有26个点，每输入一个单词，就在对应的两点间建立一条有向边。要判断输入的单词是否满足题意，其实就是判断图中是否存在一条欧拉路径。如果这个图不只包含一个连通分量，那么一定不满足题意。连通分量用并查集维护。 下面的问题就是判断有向图的欧拉路径。如果不是回路，那么图中只有一个点的出度比入度大1（起点），一个点的出度比入度小1（终点），其它点出度等于入度。如果是欧拉回路，则所有的点出度等于入度。并且如果存在出度入度的差值大于1的点也一定不能形成欧拉路。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int p[30];int Find(int x)&#123; if(x!=p[x]) p[x]=Find(p[x]); return p[x];&#125;void join(int a,int b)&#123; if(Find(a)!=Find(b)) p[Find(a)]=Find(b);&#125;int main()&#123; //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int t,num,num1,num2; cin&gt;&gt;t; int indeg[30],outdeg[30]; bool vis[30],flag; while(t--) &#123; num=num1=num2=0; flag=true; int n; cin&gt;&gt;n; char str[1000]; for(int i=0; i&lt;26; i++) &#123; p[i]=i; vis[i]=false; outdeg[i]=indeg[i]=0; &#125; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;str; join(str[0]-&apos;a&apos;,str[strlen(str)-1]-&apos;a&apos;); indeg[str[0]-&apos;a&apos;]++; outdeg[str[strlen(str)-1]-&apos;a&apos;]++; vis[str[0]-&apos;a&apos;]=true; vis[str[strlen(str)-1]-&apos;a&apos;]=true; &#125; for(int i=0; i&lt;26; i++) &#123; if(p[i]==i&amp;&amp;vis[i]) num++; if(indeg[i]-outdeg[i]==1) num1++; if(outdeg[i]-indeg[i]==1) num2++; if(indeg[i]-outdeg[i]&gt;1||outdeg[i]-indeg[i]&gt;1) flag=false; &#125; if(flag==true&amp;&amp;num==1&amp;&amp;(num1==num2==0||num1==num2==1)) &#123; cout&lt;&lt;&quot;Ordering is possible.&quot;&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;The door cannot be opened.&quot;&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Hdu-1116-Play-on-Words-并查集-有向图的欧拉路/"},{"title":"bzoj 1036 树的统计 树链剖分","text":"描述:三种操作，一是修改树上某结点的权，二是询问结点x到y路径上的最大点的权，三是询问结点x到y路径上所有点的权值和。 思路:先对树进行重链剖分，然后用线段树维护连续区间的最大值和区间和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=30005;const int maxm=60005;const int inf=1e9;int cnt,tot,n,q;int head[maxn],siz[maxn],dep[maxn],pre[maxn],fa[maxn],wson[maxn],dfn[maxn],top[maxn];int value[maxn];struct Tree&#123; int l,r,sum,mx;&#125; tree[4*maxn];struct Edge&#123; int nex,to;&#125; edge[maxm];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs1(int u,int f)&#123; siz[u]=1; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==fa[u]) continue; dep[v]=dep[u]+1; fa[v]=u; dfs1(v,u); siz[u]+=siz[v]; if(siz[wson[u]]&lt;siz[v]) wson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++tot; pre[tot]=u; top[u]=tp; if(wson[u]) dfs2(wson[u],tp); for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v!=fa[u]&amp;&amp;v!=wson[u]) dfs2(v,v); &#125;&#125;void build(int k,int l,int r)&#123; tree[k].l=l,tree[k].r=r; if(l==r) return ; int mid=l+r&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r);&#125;void change(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==r) &#123; tree[k].sum=tree[k].mx=y; return ; &#125; if(x&lt;=mid) change(k&lt;&lt;1,x,y); else change(k&lt;&lt;1|1,x,y); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; tree[k].mx=max(tree[k&lt;&lt;1].mx,tree[k&lt;&lt;1|1].mx);&#125;int querysum(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].sum; if(y&lt;=mid) return querysum(k&lt;&lt;1,x,y); else if(x&gt;mid) return querysum(k&lt;&lt;1|1,x,y); else return querysum(k&lt;&lt;1,x,mid)+querysum(k&lt;&lt;1|1,mid+1,y);&#125;int querymax(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].mx; if(y&lt;=mid) return querymax(k&lt;&lt;1,x,y); else if(x&gt;mid) return querymax(k&lt;&lt;1|1,x,y); else return max(querymax(k&lt;&lt;1,x,mid),querymax(k&lt;&lt;1|1,mid+1,y));&#125;int solvesum(int x,int y)&#123; int sum=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); sum+=querysum(1,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); sum+=querysum(1,dfn[x],dfn[y]); return sum;&#125;int solvemax(int x,int y)&#123; int mx=-inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); mx=max(mx,querymax(1,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); mx=max(mx,querymax(1,dfn[x],dfn[y])); return mx;&#125;void solve()&#123; build(1,1,n); for(int i=1; i&lt;=n; i++) change(1,dfn[i],value[i]); scanf(&quot;%d&quot;,&amp;q); char ch[10]; for(int i=1; i&lt;=q; i++) &#123; int x,y; scanf(&quot;%s%d%d&quot;,ch,&amp;x,&amp;y); if(ch[0]==&apos;C&apos;) &#123; value[x]=y; change(1,dfn[x],y); &#125; else &#123; if(ch[1]==&apos;M&apos;) printf(&quot;%d\\n&quot;,solvemax(x,y)); else printf(&quot;%d\\n&quot;,solvesum(x,y)); &#125; &#125;&#125;int main()&#123; cnt=-1; tot=0; memset(head,-1,sizeof(head)); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); add_edge(a,b); add_edge(b,a); &#125; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;value[i]); dfs1(1,0); dfs2(1,1); solve(); return 0;&#125;","path":"2019/02/04/bzoj-1036-树的统计-树链剖分/"},{"title":"bzoj 1008 越狱","text":"描述:有n个人排成一列，一共有m种势力，每个人可能属于一个势力，相邻的人势力相同则不合法，一共有多少种可能的不合法状态。 思路:所有的状态是$m^{n}$,正面很难求不合法的状态，所以想到先求合法状态，第一个人有$m$种选择，剩下的人都只有$m-1$种选择，所以答案就是$m^{n}-m*(m-1)^{n-1}$。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=100003;ll m,n;ll quick_pow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=(res*a)%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; while(~scanf(&quot;%lld %lld&quot;,&amp;m,&amp;n)) &#123; ll ans=(quick_pow(m,n)-(m*quick_pow(m-1,n-1))%mod+mod)%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","path":"2019/02/04/bzoj-1008-越狱/"},{"title":"bzoj1003 预处理最短路+区间dp","text":"描述:给一个图，让你跑n次最短路，第i次最短路有若干点是不能使用的，并且更改一次路线就又需要加k的额外花费，问跑完n次以后最小花费。 思路:想到把n次最短路分割成多个区间最短路的和，一个区间内最短路是不变的，对于每种最短路，我们可以预处理，因为只有n方的区间，n最大100，点最多只有20个，先跑n方的spfa。设dp[i][j]表示第i次到第j次最短路的所有花费的最小值。那么答案就是dp[1][n]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200;const int maxm=1000;int cnt=-1,n,m,k,e;int head[maxn],use[110][110],dist[maxn],dp[110][110];bool inq[maxn];struct Edge&#123; int nex; int to,w;&#125; edge[maxm];void add_edge(int u,int v,int w)&#123; edge[++cnt].nex=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool check(int x,int s,int t)&#123; for(int i=s; i&lt;=t; i++) if(!use[x][i]) return false; return true;&#125;int spfa(int s,int t)&#123; memset(dist,0x3f,sizeof(dist)); memset(inq,false,sizeof(inq)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); que.push(1); dist[1]=0; inq[1]=true; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=false; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(check(v,s,t)&amp;&amp;dist[v]&gt;dist[u]+edge[i].w) &#123; dist[v]=dist[u]+edge[i].w; if(!inq[v]) inq[v]=true,que.push(v); &#125; &#125; &#125; return dist[m]==0x3f3f3f3f ? 0x3f3f3f3f:dist[m]*(t-s+1);&#125;void solve()&#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=i; j&lt;=n; j++) dp[i][j]=spfa(i,j); &#125; int e; for(int len=2; len&lt;=n; len++) for(int s=1; (e=s+len-1)&lt;=n; s++) for(int p=s; p&lt;s+len-1; p++) &#123; dp[s][e]=min(dp[s][e],dp[s][p]+dp[p+1][e]+k); &#125; printf(&quot;%d\\n&quot;,dp[1][n]);&#125;int main()&#123; while(~scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;k,&amp;e)) &#123; memset(head,-1,sizeof(head)); cnt=-1; for(int i=1; i&lt;maxm; i++) edge[i].nex=-1; for(int i=1; i&lt;=e; i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,c); add_edge(b,a,c); &#125; memset(use,1,sizeof(use)); int tem; scanf(&quot;%d&quot;,&amp;tem); for(int i=1; i&lt;=tem; i++) &#123; int p,a,b; scanf(&quot;%d %d %d&quot;,&amp;p,&amp;a,&amp;b); for(int j=a; j&lt;=b; j++) use[p][j]=0; &#125; solve(); &#125;&#125;","path":"2019/02/04/bzoj1003-预处理最短路-区间dp/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/01/31/hello-world/"}]}
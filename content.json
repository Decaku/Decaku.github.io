{"pages":[{"title":"","text":"Al1yf5cTUE","path":"baidu_verify_Al1yf5cTUE.html"},{"title":"tags","text":"","path":"tags/index.html"},{"title":"about-me","text":"","path":"about-me/index.html"},{"title":"categories","text":"","path":"categories/index.html"}],"posts":[{"title":"后缀自动机学习笔记","text":"后缀自动机学习笔记 前言：本篇文章只是简单的记录一下自己对于SAM的理解，可能并不太准确，其中有些细节也没有详细的论证过程，详细证明可以参考陈立杰的PPT。 定义后缀自动机是能够识别一个字符串所有后缀的最小有限状态自动机。 几个术语endpos集合，也称为为right集合，对于一个字符串S，设它的任意一个子串为s，则endpos[s]指s在S中所有出现位置的右端点集合。trans边，和其它的自动机一样，是后缀自动机中的转移边。suffix—link边，其实不是自动机上的边，但可以使算法更加强大。 形态结点：因为一个字符串的子串个数是$O（n^2）$的，那么自动机上的结点实际上是一些等价类，后缀自动机把所有endpos集合相同的子串压缩成一个等价类，一个等价类就是自动机上的一个结点。 每个结点不会直接维护具体的字符串，而只是维护其中长度最长的子串的长度，对于一个结点u,称u代表的子串中长度最长的子串为$longest（u）$,有一个有趣的事实是，结点u所能代表的其它子串必定都是$longest(u)$的后缀，总结一下就是，每个结点代表的子串都是一段连续的字符串。 但并不是longest(u)的每个后缀都会与longest(u)在同一个结点里，因为可能某一个后缀会在其它地方多出现一次而导致endpos集合改变，我们把最早开始断开的那个longest(u)的后缀所在的结点称为fa(u)，u到fa(u)实际上有一条边，就是suffix-link边。我们进一步观察，从u沿着suffix-link边一直向上跳，实际上就是在遍历longest(u)的所有后缀集合，后缀自动机把这些后缀压缩了。 性质后缀自动机上任意两个结点所代表的endpos集合，要么是互为包含关系，要么必定完全不相交。 结点u的endpos集合只有两种可能，要么是u的所有儿子的endpos集合取并集，要么只比所有儿子的endpos集合并大1，并且这个大的1一定还是字符串的一个前缀。 所有suffix—link边构成了一个DAG，把它们反向就形成了后缀树。 设shortest(u)的长度为a，设longest(fa(u))的长度为b，那么有b+1=a,所以每个结点只维护能代表的子串的最长长度即可。 构建后缀自动机的时空复杂度都是O(n)的，构造采用在线增量构造的方式。 假设我们已把1到i的字符都插入后缀自动机中了，那么在插入第i+1个字符c时，所需要的步骤应该是，先新建一个结点，因为至少1到i+1的这个串没有在原来的自动机里出现过。 设新建的这个结点为np,然后我们假设1到i这个串所在的结点为p，我们让p不断沿着suffix-link边向上跳。这样做是有道理的，因为当你插入一个字符c时，endpos集合会变化的子串实际只有原串的所有后缀拼接上字符c，所以我们沿着suufix-link向上跳实际是在压缩遍历原串的所有后缀。 当我们一直跳到根停下时，发现这条链上没有一个结点有c这个trans转移时，这说明自动机上其实都没有c这个字符，我们把np的fa设为1即可。只要还在向上跳，那中途遇到的所有结点都没有c这个转移，我们把遇到的这些结点的trans边连一条向np结点。但我们只要跳的过程中遇到一个结点p有转移c就必须要停止了，因为p的所有祖先必然都有c这个转移了。 设p读入c以后转移到的结点为q，我们定义len[p]为longest(p)的长度。这里需要讨论两类情况。第一，len[p]+1=len[q],这说明q结点代表的所有串都是新串的后缀，这时什么也不用做，只需把让fa(np)=q即可，因为q是suffix-link上遇到的第一个np的后缀。 第二，当len[p]+1不等于len[q]时，其实就是len[p]+1小于len[q]这种情况最为复杂的，这说明q结点里必然存在不是新串后缀的字符串，简单证明一下，如果此时q里的所有串都是新串后缀，说明q去掉一个c以后的结点必然还都是旧串的后缀，但是因为len[p]+1小于len[q]，这说明这个结点一定不是p，但我们在跳的过程中并没有先遇到这个结点，说明这个结点不存在，于是可以证得q代表的字符串一定不全是新串的后缀。其实应该是长度比len[p]+1大的子串不是新串的后缀，而其它串是新串的后缀，那我们在读入c以后，是新串后缀的那些串，它们的endpos集合就都多了一个，于是这个结点的子串它们的endpos集合不再全部相同了，于是我们需要新建立一个结点nq，nq的trans边和q的trans边是相同的，因为nq只是我们从q里拆出来的一个点，fa(nq)就是原来的fa(q)，而把fa(q)设为nq，再把fa(np)设为nq，然后我们再继续在suffix——link链上向上跳，当遇到的结点有一个转移边c时指向q时，把这些结点的trans设为nq，理由是因为这些串的endpos必然都加了1。当结点的trans[p][c]不是q时,就不需要再向上了。至此，后缀自动机的构造就完成了。 应用判断一个串是不是另一个串的子串直接在后缀自动机上跑，能跑完就是子串。 本质不同的子串个数累加每个结点所能代表的子串个数就是答案。 字典序第K大的子串（相同的不同位置算多个)先在suffix树上dp处理出每个结点的endpos集合的大小，然后再dp一次处理出f[i],f[i]代表从i结点开始向后走能到达的子串个数，最后我们在自动机上走一次，每次沿着字典序最小边转移，走过的路径就是答案。 两个串的最长公共子串把一个串建立SAM，用另一个串在上面匹配，能走trans边就走，当发现不能匹配时，沿着suffix边向上跳即可。 扩展应用维护多个串，利用广义后缀自动机，广义的SAM就是建立在Trie树上的SAM.维护具体的endpos集合，使用线段树合并即可。","path":"2019/10/11/后缀自动机学习笔记/"},{"title":"2019 nowcoder Muti-school training","text":"$这是牛客暑期多校共十场的题单,会慢慢补题。\\\\代码都会放在github仓库 \\\\$ 一$\\checkmark A:给你两个数组，要求最长前缀的长度,满足对于任意一个子区间最小值位置相同 \\\\先单调栈预处理，然后枚举每一个位置i肯定是必须两个数组的l[i]都必须相同 \\\\然后右边肯定应该有个border,i必须小于border,维护时border更新为r[i]中较小值。 \\\\$ $\\checkmark B:让你算一个积分,发现可以裂项相减，然后可以推出公式。\\\\$ $C:算一个式子在限制条件下的最小值，不太懂。 \\\\$ $D:沃尔什变换，不太懂。\\\\$ $\\checkmark E:对序列计数，满足能拆成n个’AB’和m个’BA’的子序列。考虑贪心，如果能 \\\\满足要求一定是把前缀里的A先给’AB’用，同理B先给’BA’用，然后dp[i][j] \\\\表示i个A和j个B组成的合法序列数,合法时转移为dp[i][j]=dp[i-1][j]+dp[i][j-1] \\\\否则dp[i][j]=0。\\\\$ $\\checkmark F:在三角形内随机取一点把三角分成三部分，然后问最小部分面积的期望。 \\\\用微积分推倒一下发现36乘以期望等于22倍的三角形面积。\\\\$ $G:可持久化数组维护字符串后缀，不太懂。\\\\$ $\\checkmark H:给一个数集，询问所有能异或出0的子集大小的和。 \\\\考虑每个数出现在几个满足条件的集合中，所有数的贡献和就是答案。先求线性基, \\\\非线性基里的每个元素的贡献是2^{B-1}，B是非线性基空间大小。对于线性基中元素x, \\\\可以让其它n-1个元素再求一遍线性基如果其它n-1个元素不能异或出x，说明x没有贡献 \\\\否则贡献应该是2^{C}，C是新的n-1个元素消元后非线性基空间的大小。\\\\$ $\\checkmark I:给一些点，每种点有两类属性，要求你把点分成两部分，一部分只贡献第一属性，\\\\其它贡献第二属性，求最大值。首先满足条件的划分是单调不减的直线，为了方便 \\\\把它想成折线且轨迹是沿着一类点的边界画的,然后设dp[i]为排序后选到第i个点时 \\\\的答案,发现dp[i]可以由dp[1]到dp[i-1]转移,然后决策点是区间最值询问,更新需要 \\\\区间更新,我i们用线段树维护即可。\\\\$ $\\checkmark J:比较分数大小。交叉相乘即可.\\\\$ 二$\\checkmark A:有一个长度为n的环，开始时人在0号点，每次都等概率向左或向右移动一 \\\\走过所有点后就停下，询问最后停在m号点的概率。可以通过打表发现，一般结论是除了 \\\\起点以外其它点都是等概率停下的，证明可能较为复杂。\\\\$ $\\checkmark B:从0号点出发，给出一个k，每次有1/k的概率走1步，2步…k步，询问走到 \\\\n号点的概率，n很大。设dp[i]表示走到i号点的概率，不难推出dp[i]=\\sum_{j=i-k}^{i-1}dp[j]/k \\\\这个式子可以用BM线性递推优化，然后打表观察n为无穷大时答案是2/(k+1)。 \\\\$ $C:待补。 \\\\$ $\\checkmark D:有一个点带权的图，求第k大的完全子图，使用优先队列做BFS爆搜，用bitset \\\\或int128做位压，为了防止搜重复的子图，强制让后加入的点都比当前图里的点编号更大。 \\ $ $\\checkmark E:有一个n行m列的矩阵，m最大10，1表示不可通，0表示可通，每次只能向 \\\\左，右，下走一步且不可回头，询问从第一行x列走到第n行第y列的方案。设dp[i][j]表示 \\\\走到第i行j列的方案，发现dp[i][j]=\\sum_{k=l}^{k=r}dp[i-1][k],且必须满足区间[l,r] \\\\都是0，那把每行看成一个向量，相邻行之间的转移其实是乘了一个矩阵，因为还有单点修改， \\\\用线段树维护区间的矩阵乘积即可，注意下矩阵乘法的方向，wa惨了。 \\\\$ $\\checkmark F:把至多28人分成人数相同的两组，不同组之间两两对答案有贡献，求最大贡献。 \\\\用位压爆搜即可。 \\\\$ $\\checkmark G:有n条之间，求直线围成的第k大区域的面积。不会。 \\\\$ $\\checkmark H:有一个01矩阵，求只含1的第二大矩阵的面积。 \\\\固定下边界，然后就变成了广告牌问题，单调栈扫即可，第二大哈希和优先队列搞搞就好。 \\\\$ $I:待补。 \\\\$ $\\checkmark J:有一个长度为1e9的1和-1序列，给至多1e6个区间都包含1，1的数量总共最多1e7。 \\\\询问有多少子区间的和大于0。把子序列看成前缀和形式的话，就是看有多少(i,j)，满足i&lt;j且 \\\\sun[i]&lt;sum[j]，对每个子区间向左和右处理出各自能延展的最长位置，然后扫过去即可。 \\\\因为和不会很大，所以可以用桶计数。 \\\\$","path":"2019/08/24/2019-nowcoder-Muti-school-training/"},{"title":"快速傅里叶变换学习笔记","text":"$ 学了几遍的FFT,以前似乎都没有彻底弄懂,这次 \\\\应该是稍微会点了。$ 什么是快速傅里叶变换$ 快速傅里叶变换(FFT)是一种能在O(nlogn)时间内完成多项式转点值表达式的算法 \\ $ 多项式的点值表达式 $ 点值表达式：设A(x)是一个n-1次多项式，显然用n个不同的点可以 \\\\ 唯一确定A(x)，设出方程组以后解出系数即可,多项式点值表达即 \\\\ n个不同的点。 \\ $ $ 求值：把多项式转换成点值表达式,需要带入n个不同的点求出对应 \\\\ n个y，这部分复杂度是O(n^{2})的。 \\ $ $ 插值: 即把多项式的点值表达式转换成系数表达式，朴素的多项 \\\\ 式插值算法是O(n^{2})的,这里不再赘述。 \\ $ 多项式乘法$ 设有两个多项式A(x)和B(x)，把两个多项式相乘得到多项式C(x)，\\\\ 朴素的做法复杂度是O(n^{2})的，我们需要枚举每一项相乘。 \\\\ 但有趣的是，多项式的点值表达式乘法却是O(n)的，\\\\ 因为C(x_i)=A(x_i)*B(x_i),所以我们对A(x)和B(x)求值以后， \\\\ 对它们点值做乘法,再插值回去就可以得到C(x)的系数表达式了。\\\\ 我们发现多项式乘法的时间复杂度瓶颈在求值和插值上。$ 离散傅里叶变换$ 按照之前所讲，求点值表达时自变量是可以任选的,但是离散傅里叶变换 \\\\中的n个自变量是一个复平面上的单位圆周上的n等分点，这里为什么要这么 \\\\选择自变量我下面会讲。首先来普及一些复数的性质。 \\ $ $我们设这n个点从x轴正半轴开始，逆时针以此编号为0到n-1,设第k个点对应的 \\\\虚数为\\omega_{n}^{k},其对应的向量应该是(cos\\frac{n}{k}2\\pi,sin\\frac{n}{k}2\\pi), \\\\也就是说这个复数是cos\\frac{n}{k}2\\pi+i*sin\\frac{n}{k}2\\pi。 \\\\$ $\\omega_{n}^{k}=\\omega_{2n}^{2k}。把单位圆n等分取第k份等价于把单位圆2n等分取第2k份。 \\\\$ $\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}。两个点关于原点对称，向量等值反向。 \\\\$ 重要结论 $把多项式A(x)的求值结果作为系数构造另一个多项式B(x)，再把n个单位根的倒数\\\\ \\omega_{n}^{0},\\omega_{n}^{-1}…\\omega_{n}^{1-n}带入B(x)求值,得到的每个数再除以n ,就是A(x)的各项系数了，\\\\ 这样做实现了把插值变成了求值，这也是为什么我们选择单位复根的原因，\\\\ 具体证明以后再填坑了。$ 快速傅里叶变换$ 尽管离散傅里叶变换实现了把插值变成求值，但求值的时候复杂度仍然是O(n^{2})的, \\\\于是快速傅里叶变换应运而生了，它是一种分治的傅里叶变换。 \\\\我们设A(x)=a_0+a_{1}x+…+a_{n-1}x^{n-1} \\ 考虑把A(x)的每一项按照下标的奇偶 \\\\分成两部分: \\ A(x)=(a_0+a_{2}x^{2}+…+a_{n-2}x^{n-2})+(a_1x+ \\ a_3x^3+…+a_{n-1}x^{n-1}) \\\\设两个多项式: \\\\A_1(x)=a_0+a_2x+…+a_{n-2}x^{\\frac{n}{2}-1} \\\\A_2(x)=a_1+a_3x+…+a_{n-1}x^{\\frac{n}{2}-1} \\\\则A(x)=A_1(x^2)+xA_2(x^2) \\\\假设k&lt;\\frac{n}{2},现在要把x=\\omega_n^k带入 \\\\A(\\omega_n^k)=A_1(\\omega_n^{2k})+\\omega_n^kA_2(\\omega_n^{2k}) \\\\=A_1(\\omega_{\\frac{n}{2}}^k)+\\omega_n^kA_2(\\omega_{\\frac{n}{2}}^k) \\\\那么对于A(\\omega_n^{k+\\frac{n}{2}}) \\\\有A(\\omega_n^{k+\\frac{n}{2}})=A_1(\\omega_n^{2k+n})+\\omega_n^{k+\\frac{n}{2}}A_2(\\omega_n^{2k+n}) \\\\=A_1(\\omega_{\\frac{n}{2}}^k * \\omega_n^n)+\\omega_n^{k+\\frac{n}{2}}A_2(\\omega_{\\frac{n}{2}}^k * \\omega_n^n) \\\\=A_1(\\omega_{\\frac{n}{2}}^k)-\\omega_n^{k}A_2(\\omega_{\\frac{n}{2}}^k) \\\\所以，当我们知道两个多项式A_1(x)和A_2(x)分别在(\\omega_{\\frac{n}{2}}^0,…\\omega_{\\frac{n}{2}}^{\\frac{n}{2}-1})的 \\\\点值表示,就可以O(n)求出A(x)在(\\omega_n^0,…\\omega_n^{n-1})处的点值表示。 \\\\每次递归问题规模减小一般，分治边界为n=1。$ 快速傅里叶变换的优化$ 有几点优化，一种是递归转非递归形式，一种是蝴蝶操作，这里暂时先咕了，有空再更新。 $","path":"2019/08/24/快速傅里叶变换学习笔记/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/08/06/hello-world/"},{"title":"Codeforces 1175 F","text":"描述:传送门 $统计有多少区间[l,r]满足区间是1到r-l+1的排列。$ 思路：$对每个点i预处理r[i]，表示当[i,r[i]]这段区间的每一个前缀区间 \\\\里的数都是两两不重复的,这件事可以O(n)做，然后统计答案时对每个 \\\\点i都统计[i,r[i]]这段区间的前缀[i,j]，判断[i,j]区间最大值mx \\\\是否等于j-i+1即可,发现区间不成立时，我们可以让j=i+mx-1加速j \\\\的枚举，可以证明合法区间不会太多,所以这个算法的复杂度可以证 \\\\明是O(nlogn)。 $ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=3e5+5;#define ll long longint n,a[maxn],r[maxn],pos[maxn];int mm[maxn],rmq[maxn][20];void ini()&#123; mm[0]=-1; for(int i=1;i&lt;maxn;i++) mm[i]=((i&amp;i-1)==0)?mm[i-1]+1:mm[i-1]; for(int i=1;i&lt;=n;i++) rmq[i][0]=a[i]; for(int j=1;j&lt;=mm[n];j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) rmq[i][j]=max(rmq[i][j-1],rmq[i+(1&lt;&lt;(j-1))][j-1]);&#125;int query(int l,int r)&#123; int k=mm[r-l+1]; return max(rmq[l][k],rmq[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); r[n]=n; pos[a[n]]=n; for(int i=n-1;i&gt;=1;i--) &#123; if(pos[a[i]]) &#123; r[i]=min(pos[a[i]]-1,r[i+1]); &#125; else &#123; r[i]=r[i+1]; &#125; pos[a[i]]=i; &#125; ll ans=0; //for(int i=1;i&lt;=n;i++) // cout&lt;&lt;r[i]&lt;&lt;&quot; &quot;; //return 0; ini(); for(int i=1;i&lt;=n;i++) &#123; for(int j=i;j&lt;=r[i];) &#123; if(query(i,j)==j-i+1) ans++,j++; else &#123; int mx=query(i,j); j=i+mx-1; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;","path":"2019/06/09/Codeforces-1175-F/"},{"title":"Codeforces 1175 E","text":"描述:传送门 $给出许多线段，然后若干询问，每次询问覆盖一个区间至少要几条线段$ 思路：$首先考虑若有多个线段都能覆盖同一点时我们一定选择右端点最 \\\\远的，所以在每个点的决策都是固定的，所以直接倍增预处理 \\\\f[i][j]代表在i点跳2^{j}个线段能到的最右边的点，回答就是log 。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;const int mx=5e5+5;int n,m,nex[mx][22];vector&lt;int&gt;v[mx];int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); v[l].push_back(r); &#125; int tem=-1; for(int i=0; i&lt;mx; i++) &#123; for(int j=0; j&lt;v[i].size(); j++) &#123; tem=max(tem,v[i][j]); &#125; if(tem&gt;i) nex[i][0]=tem; else nex[i][0]=i; &#125; for(int i=mx; i&gt;=0; i--) &#123; for(int j=1; j&lt;22; j++) nex[i][j]=nex[nex[i][j-1]][j-1]; &#125; while(m--) &#123; int l,r,ans=1; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); int p=l; if(nex[p][20]&lt;r) ans=-1; else &#123; for(int j=20; j&gt;=0; j--) &#123; if(nex[p][j]&lt;r) ans+=(1&lt;&lt;j),p=nex[p][j]; &#125; &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","path":"2019/06/09/Codeforces-1175-E/"},{"title":"莫队题集(不定时更新)","text":"$普通莫队,主要用于解决一类无修改可离线的区间问题。$ 描述:$ 洛谷2709 $传送门 思路：$ 和国家集训队小Z的袜子这题一样,用莫队维护区间元素 \\\\出现次数即可。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=5e4+5;int n,m,k,a[maxn],block,c[maxn];ll ans[maxn],tem;struct Query&#123; int l,r,id;&#125; q[maxn];bool cmp(Query x,Query y)&#123; if(x.l/block==y.l/block) return x.r&lt;y.r; return x.l/block&lt;y.l/block;&#125;void add(int x)&#123; tem+=1LL*c[a[x]]*2+1; c[a[x]]++;&#125;void rem(int x)&#123; tem-=1LL*c[a[x]]*2-1; c[a[x]]--;&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); block=sqrt(n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d %d&quot;,&amp;q[i].l,&amp;q[i].r); q[i].id=i; &#125; sort(q+1,q+m+1,cmp); int l=1,r=0; tem=0; for(int i=1; i&lt;=m; i++) &#123; while(q[i].l&lt;l) add(--l); while(q[i].l&gt;l) rem(l++); while(q[i].r&lt;r) rem(r--); while(q[i].r&gt;r) add(++r); ans[q[i].id]=tem; &#125; for(int i=1; i&lt;=m; i++) printf(&quot;%lld\\n&quot;,ans[i]);&#125; 描述:$ bzoj1878 $传送门 思路：$ 莫队维护区间种类，虽然可以主席树。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;const int maxm=1e6+5;int n,m,l,r,cur,tem;int a[maxn],ans[maxn],num[maxn];struct query&#123; int l,r,pos;&#125; q[maxm];bool cmp(query q1,query q2)&#123; //if(q1.l/cur==q2.l/cur) return q1.r&lt;q2.r; return q1.l/cur == q2.l/cur ? (q1.l/cur &amp; 1) ? q1.r &lt; q2.r : q1.r &gt;q2.r : q1.l/cur &lt; q2.l/cur; //else return q1.l/cur&lt;q2.l/cur;&#125;void Add(int x)&#123; num[a[x]]++; if(num[a[x]]==1) tem++;&#125;void Remove(int x)&#123; num[a[x]]--; if(num[a[x]]==0)tem--;&#125;inline int read()&#123; char c=getchar(); int x=0,f=1; while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;) &#123; if(c==&apos;-&apos;)f=-1; c=getchar(); &#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) &#123; x=x*10+c-&apos;0&apos;; c=getchar(); &#125; return x*f;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; cur=sqrt(n); for(int i=1; i&lt;=n; ++i) a[i]=read(); //scanf(&quot;%d&quot;,&amp;a[i]); scanf(&quot;%d&quot;,&amp;m); for(int i=1; i&lt;=m; i++) &#123; q[i].l=read(); q[i].r=read(); //scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r); q[i].pos=i; &#125; sort(q+1,q+m+1,cmp); int nowl=0,nowr=0; for(int i=1;i&lt;=m;i++) &#123; while(nowl&lt;q[i].l) &#123; Remove(nowl); nowl++; &#125; while(nowr&gt;q[i].r) &#123; Remove(nowr); nowr--; &#125; while(nowl&gt;q[i].l) &#123; nowl--; Add(nowl); &#125; while(nowr&lt;q[i].r) &#123; nowr++; Add(nowr); &#125; ans[q[i].pos]=tem; &#125; for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0;&#125; 描述:$ bzoj4540&amp;codeforces $传送门 思路：$ 先预处理异或的前缀和sum，然后对于询问[l,r]来说等价于 \\\\询问sum[l-1]到sum[r]里异或为k的数对个数,莫队更新即可。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e5+5;int n,m,k,a[maxn],block,cnt[maxn*20];ll ans[maxn],tem;struct Query&#123; int l,r,id;&#125; q[maxn];bool cmp(Query x,Query y)&#123; if(x.l/block==y.l/block) return x.r&lt;y.r; return x.l/block&lt;y.l/block;&#125;void add(int x)&#123; tem+=cnt[k^a[x]]; cnt[a[x]]++;&#125;void del(int x)&#123; cnt[a[x]]--; tem-=cnt[k^a[x]];&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); block=sqrt(n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); a[i]^=a[i-1]; &#125; for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d %d&quot;,&amp;q[i].l,&amp;q[i].r); q[i].l--; q[i].id=i; &#125; sort(q+1,q+m+1,cmp); int l=0,r=-1; tem=0; for(int i=1; i&lt;=m; i++) &#123; while(l&lt;q[i].l) &#123; del(l++); &#125; while(l&gt;q[i].l) &#123; add(--l); &#125; while(r&lt;q[i].r) &#123; add(++r); &#125; while(r&gt;q[i].r) &#123; del(r--); &#125; ans[q[i].id]=tem; &#125; for(int i=1; i&lt;=m; i++) printf(&quot;%lld\\n&quot;,ans[i]);&#125; 描述:$ hdu5213$传送门 思路：$ 简单容斥一下,设f(l,r)为[l,r]内和为k的数对个数,对于询问 \\\\(l,r,u,v)，Ans=f(l,v)-f(l,u-1)-f(r+1,v)+f(r+1,u-1)。 $ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=30000+10;int n,m,k,a[maxn],block,ans[maxn],tem,cnt[maxn&lt;&lt;1];struct Query&#123; int l,r,id,op;&#125; q[maxn&lt;&lt;2];bool cmp(Query x,Query y)&#123; if(x.l/block==y.l/block) return x.r&lt;y.r; return x.l/block&lt;y.l/block;&#125;void add(int x)&#123; if(k&gt;=a[x]) tem+=cnt[k-a[x]]; cnt[a[x]]++;&#125;void del(int x)&#123; cnt[a[x]]--; if(k&gt;=a[x]) tem-=cnt[k-a[x]];&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; memset(cnt,0,sizeof(cnt)); memset(ans,0,sizeof(ans)); block=sqrt(n); scanf(&quot;%d&quot;,&amp;k); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); scanf(&quot;%d&quot;,&amp;m); int cnt=0; for(int i=1; i&lt;=m; i++) &#123; int l,r,u,v; scanf(&quot;%d %d %d %d&quot;,&amp;l,&amp;r,&amp;u,&amp;v); q[++cnt].l=l,q[cnt].r=v,q[cnt].id=i,q[cnt].op=1; q[++cnt].l=r+1,q[cnt].r=u-1,q[cnt].id=i,q[cnt].op=1; q[++cnt].l=l,q[cnt].r=u-1,q[cnt].id=i,q[cnt].op=-1; q[++cnt].l=r+1,q[cnt].r=v,q[cnt].id=i,q[cnt].op=-1; &#125; sort(q+1,q+cnt+1,cmp); int l=1,r=0; tem=0; for(int i=1; i&lt;=cnt; i++) &#123; while(l&lt;q[i].l) &#123; del(l++); &#125; while(l&gt;q[i].l) &#123; add(--l); &#125; while(r&lt;q[i].r) &#123; add(++r); &#125; while(r&gt;q[i].r) &#123; del(r--); &#125; ans[q[i].id]+=q[i].op*tem; &#125; for(int i=1; i&lt;=m; i++) printf(&quot;%d\\n&quot;,ans[i]); &#125;&#125; 描述:$ hdu4638$传送门 思路：$ 首先应该发现,让段数尽量少更优,设加进来的数为x，若x-1和x+1 \\\\都在区间中出现了,Ans—,只出现一个，Ans不变,都不出现,Ans++， \\\\减去一个数同理。 $ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int t,n,m,a[maxn],block,ans[maxn],tem,cnt[maxn];struct Query&#123; int l,r,id;&#125; q[maxn];bool cmp(Query x,Query y)&#123; if(x.l/block==y.l/block) return x.r&lt;y.r; return x.l/block&lt;y.l/block;&#125;void add(int x)&#123; if(cnt[a[x]-1]&amp;&amp;cnt[a[x]+1]) tem--; else if(!cnt[a[x]-1]&amp;&amp;!cnt[a[x]+1]) tem++; cnt[a[x]]++;&#125;void del(int x)&#123; cnt[a[x]]--; if(cnt[a[x]-1]&amp;&amp;cnt[a[x]+1]) tem++; else if(!cnt[a[x]-1]&amp;&amp;!cnt[a[x]+1]) tem--;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) cnt[i]=0; for(int i=0;i&lt;=m;i++) ans[i]=0; block=sqrt(n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d %d&quot;,&amp;q[i].l,&amp;q[i].r); q[i].id=i; &#125; sort(q+1,q+m+1,cmp); int l=1,r=0; tem=0; for(int i=1; i&lt;=m; i++) &#123; while(l&lt;q[i].l) &#123; del(l++); &#125; while(l&gt;q[i].l) &#123; add(--l); &#125; while(r&lt;q[i].r) &#123; add(++r); &#125; while(r&gt;q[i].r) &#123; del(r--); &#125; ans[q[i].id]=tem; &#125; for(int i=1; i&lt;=m; i++) printf(&quot;%d\\n&quot;,ans[i]); &#125;&#125; 描述:$ 洛谷4396$传送门 思路：$ 统计区间内权值在[u,v]之间的数的个数,在莫队转移的时候 \\\\把数插进树状数组里即可，复杂度O(n$sqrt{n}$logn)。 $ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e5+10;int n,m,a[maxn],block,b[maxn],tree[maxn],tree2[maxn],cnt[maxn],tem,tem2,mx;void change(int x,int d)&#123; while(x&lt;=maxn) &#123; tree[x]+=d; x+=(x&amp;-x); &#125;&#125;int query(int x)&#123; int res=0; while(x&gt;0) &#123; res+=tree[x]; x-=(x&amp;-x); &#125; return res;&#125;void change2(int x,int d)&#123; while(x&lt;=maxn) &#123; tree2[x]+=d; x+=(x&amp;-x); &#125;&#125;int query2(int x)&#123; int res=0; while(x&gt;0) &#123; res+=tree2[x]; x-=(x&amp;-x); &#125; return res;&#125;struct Query&#123; int l,r,low,high,id;&#125; q[maxn];bool cmp(Query x,Query y)&#123; if(b[x.l]==b[y.l]) return x.r&lt;y.r; return x.l&lt;y.l;&#125;struct Ans&#123; int ans1,ans2;&#125; ans[maxn];void add(int x)&#123; change(a[x],1); cnt[a[x]]++; if(cnt[a[x]]==1) change2(a[x],1);&#125;void rem(int x)&#123; change(a[x],-1); cnt[a[x]]--; if(cnt[a[x]]==0) change2(a[x],-1);&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); block=sqrt(n); mx=1e9; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]),mx=max(a[i],mx); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d %d %d %d&quot;,&amp;q[i].l,&amp;q[i].r,&amp;q[i].low,&amp;q[i].high); q[i].id=i; b[i]=(i-1)/block+1; &#125; sort(q+1,q+m+1,cmp); int l=1,r=0; tem=tem2=0; for(int i=1; i&lt;=m; i++) &#123; while(q[i].l&lt;l) add(--l); while(q[i].l&gt;l) rem(l++); while(q[i].r&lt;r) rem(r--); while(q[i].r&gt;r) add(++r); tem=query(q[i].high)-query(q[i].low-1); tem2=query2(q[i].high)-query2(q[i].low-1); ans[q[i].id].ans1=tem; ans[q[i].id].ans2=tem2; &#125; for(int i=1; i&lt;=m; i++) printf(&quot;%d %d\\n&quot;,ans[i].ans1,ans[i].ans2);&#125; 描述:$ hdu6534$传送门 思路：$ 和上面那题是一样的，莫队转移的时候维护一个树状数组即可 \\\\预处理把a[i],a[i]-k和a[i]+k离散。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=27000+10;int n,m,k,a[maxn],ans[maxn],block,c[maxn*3],tem,X[maxn],Y[maxn];struct Query&#123; int l,r,id;&#125; q[maxn];bool cmp(Query x,Query y)&#123; if(x.l/block!=y.l/block) return x.l/block&lt;y.l/block; return x.r&lt;y.r;&#125;void ins(int x,int d)&#123; while(x&lt;maxn*3) &#123; c[x]+=d; x+=(x&amp;-x); &#125;&#125;int query(int x)&#123; int res=0; while(x&gt;0) &#123; res+=c[x]; x-=(x&amp;-x); &#125; return res;&#125;void add(int x)&#123; tem+=query(X[x]); if(Y[x]-1&gt;=1) tem-=query(Y[x]-1); ins(a[x],1);&#125;void del(int x)&#123; ins(a[x],-1); tem-=query(X[x]); if(Y[x]-1&gt;=1) tem+=query(Y[x]-1);&#125;vector&lt;int&gt;disc,order;bool cmp2(int x,int y)&#123; return disc[x]&lt;disc[y];&#125;void discrete()&#123; order.clear(); int n=disc.size(); for(int i=0; i&lt;n; i++) order.push_back(i); sort(order.begin(),order.end(),cmp2); for(int i=0,j=1; i&lt;n; i++) &#123; if(i+1&lt;n&amp;&amp;disc[order[i]]!=disc[order[i+1]]) disc[order[i]]=j++; else disc[order[i]]=j; &#125;&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); block=sqrt(n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); disc.push_back(a[i]); disc.push_back(a[i]+k); disc.push_back(a[i]-k); &#125; discrete(); for(int i=0; i&lt;disc.size(); i+=3) &#123; a[i/3+1]=disc[i]; X[i/3+1]=disc[i+1]; Y[i/3+1]=disc[i+2]; &#125; for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d %d&quot;,&amp;q[i].l,&amp;q[i].r); q[i].id=i; &#125; sort(q+1,q+m+1,cmp); int l=1,r=0; tem=0; for(int i=1; i&lt;=m; i++) &#123; while(q[i].l&lt;l) &#123; add(--l); &#125; while(q[i].l&gt;l) &#123; del(l++); &#125; while(q[i].r&lt;r) &#123; del(r--); &#125; while(q[i].r&gt;r) &#123; add(++r); &#125; ans[q[i].id]=tem; &#125; for(int i=1; i&lt;=m; i++) printf(&quot;%d\\n&quot;,ans[i]);&#125; $hdu4676与fuzhou university 2226待补, 未完待续…$","path":"2019/05/23/莫队题集-不定时更新/"},{"title":"主席树题集(不定时更新)","text":"描述:$ hduoj 5678 $传送门 思路：$要求子树的中位数，直接根据dfs序建出主席树，然后求区间 \\\\第K大，观察到询问比答案种数多很多，所以先做预处理，double \\\\的取模用fmod函数。 $ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int M=40*maxn;const int mod=1e9+7;int T,n,m;int Time,w[maxn],cnt,head[maxn],in[maxn],out[maxn];int a[maxn],t[maxn],rt[maxn],lson[M],rson[M],c[M],tot,len;double ans[maxn];void ini_hash()&#123; for(int i=1; i&lt;=n; i++) t[i]=a[i]; sort(t+1,t+n+1); len=unique(t+1,t+n+1)-t-1;&#125;int build(int l,int r)&#123; int root=tot++; c[root]=0; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; lson[root]=build(l,mid); rson[root]=build(mid+1,r); &#125; return root;&#125;int Hash(int x)&#123; return lower_bound(t+1,t+len+1,x)-t;&#125;int update(int root,int pos,int val)&#123; int newroot=tot++,tmp=newroot; c[newroot]=c[root]+val; int l=1,r=len; while(l&lt;r) &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) &#123; lson[newroot]=tot++; rson[newroot]=rson[root]; newroot=lson[newroot]; root=lson[root]; r=mid; &#125; else &#123; rson[newroot]=tot++; lson[newroot]=lson[root]; newroot=rson[newroot]; root=rson[root]; l=mid+1; &#125; c[newroot]=c[root]+val; &#125; return tmp;&#125;int query(int u,int v,int k)&#123; int l=1,r=len; while(l&lt;r) &#123; int mid=l+r&gt;&gt;1; if(c[lson[u]]-c[lson[v]]&gt;=k) &#123; r=mid; u=lson[u]; v=lson[v]; &#125; else &#123; l=mid+1; k-=c[lson[u]]-c[lson[v]]; u=rson[u]; v=rson[v]; &#125; &#125; return l;&#125;struct Edge&#123; int to,nex;&#125; e[maxn&lt;&lt;1];void add_edge(int u,int v)&#123; e[++cnt].nex=head[u]; e[cnt].to=v; head[u]=cnt; e[++cnt].nex=head[v]; e[cnt].to=u; head[v]=cnt;&#125;void ini()&#123; cnt=-1; tot=Time=0; memset(head,-1,sizeof(head));&#125;void dfs(int u,int f)&#123; in[u]=++Time; for(int i=head[u]; ~i; i=e[i].nex) &#123; int v=e[i].to; if(v==f) continue; dfs(v,u); &#125; out[u]=Time;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); ini(); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;w[i]); for(int i=1; i&lt;n; i++) &#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add_edge(u,v); &#125; dfs(1,0); for(int i=1; i&lt;=n; i++) a[in[i]]=w[i]; ini_hash(); rt[n+1]=build(1,len); for(int i=n;i;i--) &#123; int pos=Hash(a[i]); rt[i]=update(rt[i+1],pos,1); &#125; for(int i=1; i&lt;=n; i++) &#123; int K=out[i]-in[i]+1; if(K&amp;1) ans[i]=1.0*t[query(rt[in[i]],rt[out[i]+1],K/2+1)]; else ans[i]=(1.0*t[query(rt[in[i]],rt[out[i]+1],K/2)]+1.0*t[query(rt[in[i]],rt[out[i]+1],K/2+1)])/2; &#125; double sum=0; while(m--) &#123; int q; scanf(&quot;%d&quot;,&amp;q); sum=fmod(sum*10+ans[q],1.0*mod); &#125; printf(&quot;%.1f\\n&quot;,sum); &#125;&#125; 描述:$ hduoj 6504 $传送门 思路：$根据dfs序建出主席树，然后枚举删的边，统计子树里元素种 \\\\类数，统计树另一边里元素种类数把序列倍增一份即可。 $ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int M=80*maxn;int n,head[maxn],cnt,w[maxn];int Time,in[maxn],out[maxn];int a[maxn&lt;&lt;1],T[maxn&lt;&lt;1],lson[M],rson[M],c[M],tot;int build(int l,int r)&#123; int root=tot++; c[root]=0; if(l!=r) &#123; int mid=l+r&gt;&gt;1; lson[root]=build(l,mid); rson[root]=build(mid+1,r); &#125; return root;&#125;int update(int root,int pos,int val)&#123; int newroot=tot++,tmp=newroot; c[newroot]=c[root]+val; int l=1,r=2*n; while(l&lt;r) &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) &#123; lson[newroot]=tot++; rson[newroot]=rson[root]; newroot=lson[newroot]; root=lson[root]; r=mid; &#125; else &#123; rson[newroot]=tot++; lson[newroot]=lson[root]; newroot=rson[newroot]; root=rson[root]; l=mid+1; &#125; c[newroot]=c[root]+val; &#125; return tmp;&#125;int query(int root,int pos)&#123; int ret=0; int l=1,r=2*n; while(pos&lt;r) &#123; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) &#123; r=mid; root=lson[root]; &#125; else &#123; ret+=c[lson[root]]; root=rson[root]; l=mid+1; &#125; &#125; return ret+c[root];&#125;struct Edge&#123; int to,nex;&#125; e[maxn&lt;&lt;1];void add_edge(int u,int v)&#123; e[++cnt].nex=head[u]; e[cnt].to=v; head[u]=cnt; e[++cnt].nex=head[v]; e[cnt].to=u; head[v]=cnt;&#125;void ini()&#123; cnt=-1; Time=0; tot=0; memset(head,-1,sizeof(head));&#125;void dfs(int u,int f)&#123; in[u]=++Time; for(int i=head[u]; ~i; i=e[i].nex) &#123; int v=e[i].to; if(v==f) continue; dfs(v,u); &#125; out[u]=Time;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; ini(); for(int i=2; i&lt;=n; i++) &#123; int p; scanf(&quot;%d&quot;,&amp;p); add_edge(i,p); &#125; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;w[i]); dfs(1,0); for(int i=1; i&lt;=n; i++) a[in[i]]=w[i],a[in[i]+n]=w[i]; T[2*n+1]=build(1,n*2); map&lt;int,int&gt;mp; for(int i=2*n; i&gt;=1; i--) &#123; if(mp.find(a[i])==mp.end()) &#123; T[i]=update(T[i+1],i,1); &#125; else &#123; int tmp=update(T[i+1],mp[a[i]],-1); T[i]=update(tmp,i,1); &#125; mp[a[i]]=i; &#125; int ans=-1; for(int i=2; i&lt;=n; i++) &#123; int l=in[i],r=out[i]; int tem=query(T[l],r)+query(T[r+1],n+l-1); ans=max(ans,tem); &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","path":"2019/05/10/主席树题集-不定时更新/"},{"title":"Codeforces Beta Round 80 E","text":"描述:传送门 $给一个序列s,多组询问,求 \\sum_{i=a+k*b}^{i \\leq n}s[i], \\\\a和b也是输入的。$ 思路：$这玩意看起来就没法数据结构加速,考虑b \\geq \\sqrt{n}时， \\\\可以直接暴力，当b \\leq \\sqrt{n}时，我们直接预处理 \\sqrt{n}种情况 \\\\然后O(1)就行,但是这样空间是O(n \\sqrt{n} )的，因为这题空间 \\\\卡的紧所以可以离线询问排序后让空间O(n)。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=3e5+5;ll n,p,a[maxn],sum[maxn],ans[maxn];struct Query&#123; ll x,y,id;&#125; q[maxn];bool cmp(Query a,Query b)&#123; if(a.y==b.y) return a.id&lt;b.id; return a.y&lt;b.y;&#125;int main()&#123; scanf(&quot;%lld&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); scanf(&quot;%lld&quot;,&amp;p); for(int i=1; i&lt;=p; i++) &#123; scanf(&quot;%lld %lld&quot;,&amp;q[i].x,&amp;q[i].y); q[i].id=i; &#125; sort(q+1,q+p+1,cmp); int l=1,r=1; while(1) &#123; if(l&gt;p) break; while(q[r+1].y==q[l].y) r++; if(q[r].y&gt;sqrt(n)) &#123; for(int i=l;i&lt;=r;i++) &#123; ll tem=0; for(int j=q[i].x;j&lt;=n;j+=q[i].y) &#123; tem+=a[j]; &#125; ans[q[i].id]=tem; &#125; l=r+1; continue; &#125; memset(sum,0,sizeof(sum)); for(int i=n;i&gt;=n-q[l].y+1;i--) &#123; sum[i]=a[i]; &#125; for(int i=n-q[l].y;i&gt;=1;i--) &#123; sum[i]+=sum[i+q[l].y]+a[i]; &#125; for(int i=l; i&lt;=r; i++) &#123; ans[q[i].id]=sum[q[i].x]; &#125; l=r+1; &#125; for(int i=1; i&lt;=p; i++) printf(&quot;%lld\\n&quot;,ans[i]);&#125;","path":"2019/04/24/‘Codeforces-Beta-Round-80-E/"},{"title":"Bzoj 4892 DNA","text":"描述:传送门 思路：$在第一个串里枚举每个位置,能匹配就向后跳lcp个单位，不能 \\\\匹配就向后跳一个单位并记录一下不匹配的次数，因为不匹配 \\\\次数是3就可以break了，所以复杂度十分优秀，lcp的话把两个 \\\\串拼接起来求SA然后rmq预处理以后可以O1查询。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/************************************************************** Problem: 4892 User: Decaku Language: C++ Result: Accepted Time:7540 ms Memory:22788 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+100;int n,m;int x[maxn],y[maxn],t[maxn],sa[maxn],rk[maxn],hg[20][maxn],lg[maxn];char s[maxn],s1[maxn];int a[maxn]; bool cmp(int i,int j,int k)&#123; return y[i]==y[j]&amp;&amp;y[i+k]==y[j+k];&#125; void get_sa()&#123; for(int i=0;i&lt;=m;i++) t[i]=0; //多样例注意清空 for(int i=1;i&lt;=n;i++) t[x[i]=a[i]]++; for(int i=1;i&lt;=m;i++) t[i]+=t[i-1]; for(int i=n;i&gt;=1;i--) sa[t[x[i]]--]=i; for(int k=1;k&lt;=n;k&lt;&lt;=1) &#123; int p=0; for(int i=0;i&lt;=m;i++) y[i]=0; for(int i=n-k+1;i&lt;=n;i++) y[++p]=i; for(int i=1;i&lt;=n;i++) if(sa[i]&gt;k) y[++p]=sa[i]-k; for(int i=0;i&lt;=m;i++) t[i]=0; for(int i=1;i&lt;=n;i++) t[x[y[i]]]++; for(int i=1;i&lt;=m;i++) t[i]+=t[i-1]; for(int i=n;i&gt;=1;i--) sa[t[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2;i&lt;=n;i++) x[sa[i]]=cmp(sa[i],sa[i-1],k)?p:++p; if(p&gt;=n) break; m=p; &#125;&#125;void get_rk()&#123; for(int i=1;i&lt;=n;i++) rk[sa[i]]=i;&#125; void get_height()&#123; for(int i=2;i&lt;maxn;i++) lg[i]=lg[i&gt;&gt;1]+1; for(int i=1,j=0;i&lt;=n;i++) &#123; if(j) --j; while(a[i+j]==a[sa[rk[i]-1]+j]) ++j; hg[0][rk[i]]=j; &#125; for(int j=1;j&lt;=lg[n];++j) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) hg[j][i]=min(hg[j-1][i],hg[j-1][i+(1&lt;&lt;(j-1))]);&#125; int lcp(int i,int j)&#123; i=rk[i];j=rk[j];if(i&gt;j) swap(i,j); if(i==j) return 1e9;++i; int l=lg[j-i+1]; return min(hg[l][i],hg[l][j-(1&lt;&lt;l)+1]);&#125; int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%s&quot;,s+1); scanf(&quot;%s&quot;,s1+1); int lens=strlen(s+1); int lent=strlen(s1+1); for(int i=1;i&lt;=lens;i++) a[i]=s[i]; for(int i=1;i&lt;=lent;i++) a[lens+i]=s1[i]; m=300; n=lens+lent; get_sa(); get_rk(); get_height(); int ans=0; for(int i=1;i&lt;=lens-lent+1;i++) &#123; int tt=0; for(int j=1;j&lt;=lent&amp;&amp;tt&lt;=3;) &#123; if(a[i+j-1]!=a[lens+j]) tt++,j++; else j+=lcp(i+j-1,lens+j); &#125; ans+=(tt&lt;=3); &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","path":"2019/04/15/Bzoj-4892-DNA/"},{"title":"莫比乌斯反演杜教筛题集","text":"描述:$cjoj2513 \\\\求\\sum_{i=1}^n\\sum_{j=1}^{m}gcd(i,j)),n \\leq 10^{7},m \\leq 1e7 $ 思路：$\\sum_{i=1}^{n} \\sum_{j=1}^{m}id(gcd(i,j)) \\\\由狄利克雷卷积的常用结论可知 \\\\=\\sum_{i=1}^{n}\\sum_{j=1}^{m}1*\\phi(gcd(i,j)) \\\\=\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{d|i,d|j}^{min(n,m)} \\phi(d) \\\\求和换序 \\\\=\\sum_{d=1}^{min(n,m)} \\lfloor(n/d)\\rfloor \\lfloor(m/d)\\rfloor \\phi(d) \\\\有两个下取整,预处理前缀和以后，可以分块O(\\sqrt{n}+\\sqrt{m})求解$ 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod=998244353;const ll maxn=1e7+5;ll n,m,euler[maxn],sum[maxn];void getEuler()&#123; memset(euler,0,sizeof(euler)); euler[1]=1; for(int i=2; i&lt;maxn; i++) if(!euler[i]) for(int j=i; j&lt;maxn; j+=i) &#123; if(!euler[j]) euler[j]=j; euler[j]=euler[j]/i*(i-1); &#125; for(int i=1; i&lt;maxn; i++) sum[i]=sum[i-1]+euler[i]%mod;&#125;int main()&#123; getEuler(); scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m); ll up=min(n,m); ll ans=0; for(int l = 1, r; l &lt;= up; l = r+1) &#123; r = min(n/(n/l), m/(m/l)); ans += 1LL*(n/l)%mod*(m/l)%mod*(sum[r]-sum[l-1])%mod; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; 描述:$洛谷P2257 \\\\求\\sum_{i=1}^{n}\\sum_{j=1}^{m}[gcd(i,j)是素数], n,m\\leq10^{7} \\\\T组询问,T\\leq10000 $ 思路：$设f(x)=\\begin{cases}1 (x是素数) \\\\0 (x不是素数)\\end{cases}，找一个g使得f=1*g $ $那么g=\\mu*f,所以有g(x)=\\sum_{p|x}\\mu(x/p) 其中p是素数 \\\\所以要求的\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{d|i,d|j}g(d) \\\\又是求和换序 \\\\=\\sum_{d=1}^{min(n,m)}g(d)\\lfloor(n/d)\\rfloor \\lfloor(m/d)\\rfloor \\\\形式和上面一题一样，预处理前缀和以后分块。 \\\\本题卡常，不要都用long long。 $ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=1e7+5;int mu[maxn],prime[maxn],t,n,m;ll g[maxn];bool vis[maxn];inline void ini()&#123; //memset(vis,false,sizeof(vis)); mu[1]=1; prime[0]=0; for(int i=2; i&lt;maxn; i++) &#123; if(!vis[i]) &#123; mu[i]=-1; prime[++prime[0]]=i; &#125; for(int j=1; j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;maxn; j++) &#123; vis[i*prime[j]]=true; if(i%prime[j]) mu[i*prime[j]]=-mu[i]; else &#123; mu[i*prime[j]]=0; break; &#125; &#125; &#125; for(int i=1; i&lt;=prime[0]; i++) &#123; for(int j=1; j*prime[i]&lt;maxn; j++) g[j*prime[i]]+=mu[j]; &#125; for(int i=1; i&lt;maxn; i++) g[i]+=g[i-1];&#125;int main()&#123; ini(); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ll ans=0; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); int up=min(n,m); for(int l = 1, r; l &lt;= up; l = r+1) &#123; r = min(n/(n/l), m/(m/l)); ans += 1LL*(n/l)*(m/l)*(g[r]-g[l-1]); &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125; 描述:$bzoj 3994 \\\\求\\sum_{i=1}^{m}\\sum_{j=1}^{m}d(ij),d(x)表示x的因子个数。$ 思路：$有个神奇的结论 d(i,j)=\\sum_{x|i}\\sum_{y|j}[gcd(x,y)=1] \\\\原式=\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{x|i}\\sum_{y|j}[gcd(x,y)=1] $ $设f(x)=\\begin{cases}1 (x=1) \\\\0 (x\\neq1)\\end{cases}，找一个g使得f=1*g $ $g=\\mu*f,发现g(x)=\\mu(x) \\\\所以原式=\\sum_{x=1}^{n}\\sum_{y=1}^{m} \\lfloor n/x \\rfloor \\lfloor m/y \\rfloor \\sum_{d|x,d|y}\\mu(d) \\\\然后又是求和换序，继续化简一波就是 \\\\\\sum_{d=1}^{min(n,m)}\\mu(d) \\sum_{x=1}^{n/d} \\sum_{y=1}^{m/d}\\lfloor n/dx \\rfloor \\lfloor m/dy \\rfloor \\\\预处理前缀和以后数学分块$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// bzoj3994#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#define LL long long#define inf 2147483640#define Pi acos(-1.0)#define free(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin),freopen(a&quot;.out&quot;,&quot;w&quot;,stdout);using namespace std; const int maxn=50010;LL n,m,s[maxn],mu[maxn],f[maxn];int p[maxn],vis[maxn]; int main() &#123; int T;scanf(&quot;%d&quot;,&amp;T); s[1]=mu[1]=1; for (int i=2;i&lt;maxn;i++) &#123; if (!vis[i]) p[++p[0]]=i,mu[i]=-1; for (int j=1;j&lt;=p[0] &amp;&amp; p[j]*i&lt;maxn;j++) &#123; vis[i*p[j]]=1; if (i%p[j]==0) &#123;mu[i*p[j]]=0;break;&#125; else mu[i*p[j]]=-mu[i]; &#125; s[i]=s[i-1]+mu[i]; &#125; for (int i=1;i&lt;maxn;i++) for (int j=1,k;j&lt;=i;j=k+1) &#123; k=i/(i/j); f[i]+=(LL)(k-j+1)*(i/j); &#125; while (T--) &#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); if (n&gt;m) swap(n,m); LL ans=0; for (int i=1,j;i&lt;=n;i=j+1) &#123; j=min(n/(n/i),m/(m/i)); ans+=f[n/i]*f[m/i]*(s[j]-s[i-1]); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/04/05/莫比乌斯反演杜教筛题集/"},{"title":"CometOJ contest#0 B","text":"描述:传送门 思路：$ 发现访问到的城市都是连续的，所以可以当成区间来考虑， \\\\设dp(i,x,y)表示第i天访问的城市左边有x个城市已被访问， \\\\右边有y个城市已被访问对答案做出的贡献,不难想到以下的 \\\\转移。 \\\\dp(i,x,y)\\cdot q \\to dp(i+1,max(x-1,0),y+1) \\\\dp(i,x,y)\\cdot p \\to dp(i+1,x+1,max(y-1,0) \\\\dp(i,x,y)\\cdot (100-p-q) \\to dp(i+1,x,y) \\\\要保证访问的城市能看作区间，所以要求 \\\\x+y+1 \\leq n-1 \\\\根据100^{m-1} f(i)=\\sum_{x+y+1=i} dp(m,x,y) \\\\即可计算f(1)到f(n-1)中的值，再根据和为定值计算f(n) \\\\这题就做完了。 $ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod=1e9+7;ll dp[505][505][505];ll f[505];ll n,m,k,p,q,t;ll quick_pow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(&quot;%lld&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld %lld %lld %lld %lld&quot;,&amp;n,&amp;m,&amp;k,&amp;p,&amp;q); for(int i=0; i&lt;=m; i++) &#123; for(int j=0; j&lt;=i; j++) &#123; for(int k=0; k&lt;=i; k++) dp[i][j][k]=0; &#125; &#125; memset(f,0,sizeof(f)); dp[1][0][0]=1; for(ll i=1; i&lt;m; i++) &#123; for(ll x=0; x&lt;=i; x++) &#123; for(ll y=0; y&lt;=i; y++) &#123; if(x+y+1&gt;=n) break; dp[i+1][max(x-1,0ll)][y+1]+=(dp[i][x][y]*q%mod); dp[i+1][max(x-1,0ll)][y+1]%=mod; dp[i+1][x+1][max(y-1,0ll)]+=(dp[i][x][y]*p%mod); dp[i+1][x+1][max(y-1,0ll)]%=mod; dp[i+1][x][y]+=(dp[i][x][y]*(100-p-q)%mod); dp[i+1][x][y]%=mod; &#125; &#125; &#125; for(ll i=1; i&lt;n; i++) &#123; for(ll x=0; x&lt;=i; x++) &#123; for(ll y=0; y&lt;=i; y++) &#123; if(x+y+1!=i) continue; f[i]+=dp[m][x][y]; f[i]%=mod; &#125; &#125; &#125; f[n]=quick_pow(100,m-1); for(ll i=1; i&lt;n; i++) &#123; f[n]-=f[i]; f[n]=(f[n]+mod)%mod; &#125; ll ans=0; for(ll i=1; i&lt;=n; i++) &#123; ans+=(quick_pow(i,k)*f[i])%mod; ans%=mod; &#125; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","path":"2019/04/03/CometOJ-contest-0-B/"},{"title":"Codeforces 550 Div.3 G","text":"描述:传送门 思路:官方标算是动规，但是有个比较简便的贪心的做法，分别维护一个递增和一个递减序列，然后枚举第i个元素，如果都能往两个序列里加的话，只要和第i+1个元素比较进行贪心就行,证明比较明显，具体看代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;const int inf=1e9;int n,a[maxn],vis[maxn];vector&lt;int&gt;p,q;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); p.push_back(inf); q.push_back(-1); for(int i=1; i&lt;=n; i++) &#123; int x=p.back(),y=q.back(); if(a[i]&gt;=x&amp;&amp;a[i]&lt;=y) &#123; puts(&quot;NO&quot;); return 0; &#125; else if(a[i]&lt;x&amp;&amp;a[i]&gt;y) &#123; if(i==n) vis[i]=1; else &#123; if(a[i]&gt;a[i+1]) &#123; p.push_back(a[i]); vis[i]=1; &#125; else q.push_back(a[i]); &#125; &#125; else if(a[i]&lt;x) &#123; p.push_back(a[i]); vis[i]=1; &#125; else q.push_back(a[i]); &#125; puts(&quot;YES&quot;); for(int i=1; i&lt;=n; i++) printf(&quot;%d &quot;,vis[i]); printf(&quot;\\n&quot;);&#125;","path":"2019/04/03/Codeforces-Round-550-Div-3-G/"},{"title":"偏序问题以及CDQ分治","text":"前置技能：$归并排序，分治，树状数组，逆序对$ 一维偏序：$一维偏序只需排序即可解决$ 二维偏序：$第一维排序，第二维使用数据结构维护，具体过程是：先对x排序， \\\\然后动态的把点的第二维加入树状数组或权值线段树里，因为当枚 \\\\举到i时，已经保证[1,i-1]里的点x都比i小,所以只需统计i之前的 \\\\点里y比i小的点个数即可。$ $例题：Hdu1541$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200000;struct star&#123; int x,y; bool operator&lt;(const star&amp; t)const &#123; if(x==t.x) return y&lt;t.y; return x&lt;t.x; &#125;&#125; a[maxn];int n,c[maxn],cnt[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;int sum(int x)&#123; int res=0; while(x&gt;0) &#123; res+=c[x]; x-=lowbit(x); &#125; return res;&#125;int add(int x,int y)&#123; while(x&lt;maxn) &#123; c[x]+=y; x+=lowbit(x); &#125;&#125;int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; memset(c,0,sizeof(c)); memset(cnt,0,sizeof(cnt)); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;a[i].x,&amp;a[i].y); a[i].y++; //树状数组里的点都是从1开始编号 &#125; sort(a+1,a+n+1); for(int i=1; i&lt;=n; i++) &#123; int tem=sum(a[i].y); cnt[tem]++; add(a[i].y,1); &#125; for(int i=0; i&lt;n; i++) &#123; printf(&quot;%d\\n&quot;,cnt[i]); &#125; &#125;&#125; 三维偏序：$第一维排序，第二维CDQ分治，第三维使用数据结构维护。 \\\\当对区间[l,r]按x排完序后，把区间分成[l,mid]和[mid+1,r] \\\\两部分,此时再对两区间分别按y排序，因为此时一定能保证 \\\\左区间的x是一定小于右区间,所以可以统计区间merge时对答案 \\\\的贡献，第三维z仍可使用树状数组来维护。$ $例题：bzoj3262$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define N 200005int n,k,acnt,bcnt,pa,pb,tot;struct hp&#123;int x,y,z,id,ans;&#125;f[N],a[N],b[N];int C[N],cnt[N],ch[N];int cmp1(hp a,hp b)&#123; return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y)||(a.x==b.x&amp;&amp;a.y==b.y&amp;&amp;a.z&lt;b.z);&#125;int cmp2(hp a,hp b)&#123; return a.y&lt;b.y;&#125;void add(int loc,int val)&#123; if (!loc) return; for (int i=loc;i&lt;=k;i+=i&amp;(-i)) C[i]+=val;&#125;int query(int loc)&#123; int ans=0; for (int i=loc;i&gt;=1;i-=i&amp;(-i)) ans+=C[i]; return ans;&#125;void cdq(int l,int r)&#123; if (l&gt;=r) return; int mid=(l+r)&gt;&gt;1; cdq(l,mid); acnt=0; for (int i=l;i&lt;=mid;++i) a[++acnt]=f[i]; sort(a+1,a+acnt+1,cmp2); bcnt=0; for (int i=mid+1;i&lt;=r;++i) b[++bcnt]=f[i]; sort(b+1,b+bcnt+1,cmp2); pa=pb=1;tot=0; while (pb&lt;=bcnt) &#123; while (pa&lt;=acnt&amp;&amp;a[pa].y&lt;=b[pb].y) &#123; add(a[pa].z,1); ch[++tot]=a[pa].z; ++pa; &#125; f[b[pb].id].ans+=query(b[pb].z); ++pb; &#125; for (int i=1;i&lt;=tot;++i) add(ch[i],-1); cdq(mid+1,r);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;++i) scanf(&quot;%d%d%d&quot;,&amp;f[i].x,&amp;f[i].y,&amp;f[i].z); sort(f+1,f+n+1,cmp1); for (int i=1;i&lt;=n;++i) f[i].id=i; cdq(1,n); for (int i=n-1;i&gt;=1;--i) if (f[i].x==f[i+1].x&amp;&amp;f[i].y==f[i+1].y&amp;&amp;f[i].z==f[i+1].z) f[i].ans=max(f[i].ans,f[i+1].ans); for (int i=1;i&lt;=n;++i) ++cnt[f[i].ans]; for (int i=0;i&lt;n;++i) printf(&quot;%d\\n&quot;,cnt[i]);&#125; 小结：$对于高维偏序问题，可以采取CDQ套CDQ的方式来解决，但当维度 \\\\高于五维时，CDQ分治的效率会差于n^2暴力，此外，CDQ分治无法 \\\\解决强制在线的题目，此时只能写树套树了。$","path":"2019/03/15/偏序问题以及CDQ分治/"},{"title":"Bzoj4919 [Lydsy1706月赛]大根堆","text":"描述:传送门 思路:$本质上就是求树上最长上升子序列,联想到序列LIS的nlogn做法, \\\\但是对于子树要进行合并,考虑到集合具有有序性,使用多重 \\\\集合来维护每个结点,在dfs回溯时合并子树,并采用启发式 \\\\合并来降低复杂度,总复杂度为nlognlogn。 $ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/************************************************************** Problem: 4919 User: Decaku Language: C++ Result: Accepted Time:864 ms Memory:22472 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;int n,w[maxn],head[maxn],cnt;multiset&lt;int&gt;m[maxn]; struct Node&#123; int nex,to;&#125; e[maxn&lt;&lt;1]; void ini()&#123; memset(head,-1,sizeof(head)); cnt=-1;&#125;void add_edge(int u,int v)&#123; e[++cnt].nex=head[u]; e[cnt].to=v; head[u]=cnt; e[++cnt].nex=head[v]; e[cnt].to=u; head[v]=cnt;&#125; void Merge(int a,int b)&#123; if(m[a].size()&lt;m[b].size()) swap(m[a],m[b]); multiset&lt;int&gt;::iterator it=m[b].begin(); while(it!=m[b].end()) &#123; m[a].insert(*it); it++; &#125;&#125; void dfs(int u,int f)&#123; for(int i=head[u]; i!=-1; i=e[i].nex) &#123; int v=e[i].to; if(v==f) continue; dfs(v,u); Merge(u,v); &#125; multiset&lt;int&gt;::iterator it; it=m[u].lower_bound(w[u]); if(it!=m[u].end()) m[u].erase(it); m[u].insert(w[u]); &#125; int main()&#123; scanf(&quot;%d&quot;,&amp;n); ini(); for(int i=1; i&lt;=n; i++) &#123; int v; scanf(&quot;%d %d&quot;,&amp;w[i],&amp;v); add_edge(i,v); &#125; dfs(1,0); printf(&quot;%d\\n&quot;,m[1].size());&#125;","path":"2019/02/20/Bzoj4919-Lydsy1706月赛-大根堆/"},{"title":"关于最长上升子序列nlogn做法的证明","text":"$ 笔者最近做题时，又遇到了常见的的最长上升子序列问题,之前在学习 \\\\过程中对这个问题只是知道了做法,但是原理却一知半解,今天正好来 \\\\整理一下。 $ $ LIS的定义：一段序列中最长的单调递增或单调不减的子序列。 $ $有关LIS的n^{2}的dp做法，网上已有相当多的解释，并且这种做法也比 \\\\较直观，这里就不再赘述了。 $ $但是对于nlogn的优化算法,许多blog只给出了算法阐述,但是并未解释 \\\\清楚原因,以下笔者将给出严格证明。 $ $先定义一下数组d,d[i]代表长度为i的上升子序列中最后一个元素的值, \\\\若有多个长度为i的上升子序列，则d[i]取所有子序列最后一个元素的 \\\\最小值。 $ $举个例子,对于序列1,4,3来说，长度为2的上升子序列有两个，分别 \\\\是1,3和1,4;由于3比4小,根据定义,d[2]=3。 $ $那么很明显数组d的大小就是LIS的长度,只要维护d数组即可。 $ $以下证明d数组是单调不减的,即对于i \\lt j,则有d[i] \\leq d[j]。 $ $使用反证法证明: \\\\ 假设存在i \\lt j,d[i] \\gt d[j]; \\\\ 设长度为i的上升子序列为x_1,x_2 \\cdots x_i; \\\\ 设长度为j的上升子序列为y_1,y_2 \\cdots y_i \\cdots y_j; \\\\ 则有y_i \\leq y_j \\lt x_i; \\\\ 那么以子序列y_1 \\cdots y_i的结尾y_i作为d[i]比x_i小。 \\\\ 这不符合d数组的定义,所以假设不成立,证毕。 $ $具体维护d数组的过程为: 设a为要求LIS的序列,若a[i]比d[i-1]大, \\\\更新d[i]为a[i]即可。否则,在d数组里寻找一个位置k,使得 \\\\d[k-1] \\lt a[i] \\leq d[k],根据d数组的定义,所有长度为k的上升 \\\\子序列最后一个元素的最小值应是a[i],使用a[i]更新d[k]即可。 $ $寻找k的过程可以二分,所以总复杂度为nlogn。$","path":"2019/02/20/关于最长上升子序列nlogn做法的证明/"},{"title":"2018 ICPC 南京站","text":"传送门$A.对称博弈,坑点是细节特别多。$ 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n,k;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); if(n==0) &#123; puts(&quot;Austin&quot;); return 0; &#125; if(k&gt;=n) &#123; puts(&quot;Adrien&quot;); return 0; &#125; if(k&gt;=2) &#123; puts(&quot;Adrien&quot;); return 0; &#125; if(k==1) &#123; if(n&amp;1) puts(&quot;Adrien&quot;); else puts(&quot;Austin&quot;); &#125;&#125; $J. 先做质因子分解,然后枚举每个质因子 \\\\对答案的贡献 $ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e6+5;bool no_prime[maxn];int minfac[maxn];int prime[maxn/10],prime_;void find_prime()&#123; minfac[1]=1; minfac[2]=2; no_prime[1]=true; int n=maxn; for(int i=2; i&lt;n; i++) &#123; if(!no_prime[i]) &#123; prime[prime_++]=i; minfac[i]=i; &#125; for(int j=0; j&lt;prime_&amp;&amp;prime[j]*i&lt;n; j++) &#123; no_prime[prime[j]*i]=true; minfac[prime[j]*i]=prime[j]; if(i%prime[j]==0) break; &#125; &#125;&#125;int fac[100][2],fac_;vector&lt;int&gt;v[maxn];//v[i] 代表void getfac(int x)&#123; fac_=0; while(x!=1) &#123; int little=minfac[x]; fac[fac_][0]=little; fac[fac_][1]=0; while(little!=1&amp;&amp;minfac[x]==little) &#123; x/=little; fac[fac_][1]++; &#125; fac_++; &#125;&#125;int n,a[maxn];int main()&#123; find_prime(); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) &#123; //memset(fac,0,sizeof(fac)); getfac(a[i]); for(int j=0; j&lt;fac_; j++) &#123; v[fac[j][0]].push_back(i); &#125; &#125; ll ans=0; for(int i=0; i&lt;prime_; i++) &#123; for(int j=0; j&lt;v[prime[i]].size(); j++) &#123; if(j==v[prime[i]].size()-1) &#123; ans+=1ll*v[prime[i]][j]*(n-v[prime[i]][j]+1); continue; &#125; ans+=1ll*v[prime[i]][j]*(v[prime[i]][j+1]-v[prime[i]][j]); &#125; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;//1 5 9 10 2的贡献//4+20+9+10=43 43+42+31=116//1 6 7 10 3的贡献//5+6+21+10=42//3 4 5的贡献//3+28=31//2 =2 7的贡献/*a1 a2 a3 ... ai a(i+1) 1 5 8 1*(4)=3 [1,1] [1,2] 5 (8-5)*/ $I.建图跑最大流$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;const int eps=1e-12;struct dinic&#123; static const int maxn=2000; static const int maxm=3e5; static const int inf=1e9; int cnt; struct edge &#123; int v,nex; int c; &#125; g[maxm*2]; int lv[maxn],current[maxn],head[maxn]; void add_edge(int u,int v,int c) &#123; g[cnt].v=v; g[cnt].c=c; g[cnt].nex=head[u]; head[u]=cnt++; g[cnt].v=u; g[cnt].c=0; g[cnt].nex=head[v]; head[v]=cnt++; &#125; void ini() &#123; memset(head,-1,sizeof(head)); cnt=0; &#125; void bfs(int s) &#123; memset(lv,-1,sizeof(lv)); lv[s]=0; queue&lt;int&gt;q; q.push(s); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u]; ~i; i=g[i].nex) &#123; edge &amp;e=g[i]; if(e.c&lt;=0||lv[e.v]&gt;=0) continue; lv[e.v]=lv[u]+1; q.push(e.v); &#125; &#125; &#125; int dfs(int u,int t,int f) &#123; if(u==t) return f; for(int &amp;i=current[u]; ~i; i=g[i].nex) &#123; edge &amp;e=g[i],&amp;rev=g[i^1]; if(e.c&lt;=0||lv[u]&gt;=lv[e.v]) continue; int d=dfs(e.v,t,min(f,e.c)); if(d&lt;=0) continue; e.c-=d; rev.c+=d; return d; &#125; return 0; &#125; int maxflow(int s,int t) &#123; int flow=0; while(1) &#123; memmove(current,head,sizeof(head)); bfs(s); if(lv[t]&lt;0) return flow; int f; while((f=dfs(s,t,inf))&gt;0) flow+=f; &#125; &#125;&#125; g;int n,m,k;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); g.ini(); int t=n+m+1; int s=n+m+2,a=n+m+3,b=n+m+4; for(int i=1; i&lt;=n; i++) &#123; int ct; scanf(&quot;%d&quot;,&amp;ct); for(int j=1; j&lt;=ct; j++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); g.add_edge(i,n+x,1); &#125; &#125; for(int i=n+1; i&lt;=n+m; i++) g.add_edge(i,t,1); for(int i=1; i&lt;=n; i++) g.add_edge(a,i,1),g.add_edge(b,i,1); g.add_edge(s,a,1e9); g.add_edge(s,b,k); printf(&quot;%d\\n&quot;,g.maxflow(s,t));&#125; $G. 公式不太好推，先爆搜出前几项，然后 \\\\连续做几次差分才能发现数列有规律。$ 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod=1e9+7;ll t,n;int main()&#123; scanf(&quot;%lld&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld&quot;,&amp;n); ll ans=n*(n+1)%mod*(n+2)%mod*(n+3)%mod*41666667%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125; $K.逗你玩，直接随机化输出答案，卡不住。$ 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;char str[30];int main()&#123; srand(time(0)); int n,m; char a[4]= &#123;&apos;U&apos;,&apos;D&apos;,&apos;L&apos;,&apos;R&apos;&#125;; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) scanf(&quot;%s&quot;,str); for(int i=1; i&lt;=50000; i++) printf(&quot;%c&quot;,a[rand()%4]); printf(&quot;\\n&quot;);&#125; $D.最小球覆盖，几何法与模拟退火法两种做法，模拟退火的step要 \\\\调大才能满足精度。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const double eps=1e-14;struct point3D&#123; double x,y,z;&#125; data[105];int n;double dis(point3D a,point3D b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));&#125;double solve()&#123; double step=10000,ans=1e30,mt; point3D z; z.x=z.y=z.z=0; int s=0; while(step&gt;eps) &#123; for(int i=0; i&lt;n; i++) if(dis(z,data[s])&lt;dis(z,data[i])) s=i; mt=dis(z,data[s]); ans=min(ans,mt); z.x+=(data[s].x-z.x)/mt*step; z.y+=(data[s].y-z.y)/mt*step; z.z+=(data[s].z-z.z)/mt*step; step*=0.98; &#125; return ans;&#125;int main()&#123; // freopen(&quot;t.txt&quot;,&quot;r&quot;,stdin); double ans; scanf(&quot;%d&quot;,&amp;n); for(int i=0; i&lt;n; i++) scanf(&quot;%lf%lf%lf&quot;,&amp;data[i].x,&amp;data[i].y,&amp;data[i].z); ans=solve(); printf(&quot;%.15f\\n&quot;,ans); return 0;&#125; $M.这份题解讲的很明白了，快速幂记得预处理，不然会T飞。$传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=1e6+100;const ll p=101;const ll mod=1e9+7;char s[maxn],t[maxn],str[maxn&lt;&lt;1];ll hs[maxn],ht[maxn],hw[maxn&lt;&lt;1],pre[maxn];ll len,qpow[maxn];/*inline ll qpow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;*/inline bool ok(ll mid,ll i,ll j)&#123; ll h1=(hs[i]-hs[i-mid]*qpow[mid]%mod+mod)%mod; ll h2=(ht[j]-ht[j-mid]*qpow[mid]%mod+mod)%mod; return h1==h2;&#125;inline void init()&#123; str[1]=&apos;@&apos;; str[2]=&apos;#&apos;; for(ll i=1; i&lt;=len; i++) &#123; str[i*2+1]=s[i]; str[i*2+2]=&apos;#&apos;; &#125; len=len*2+2;&#125;inline void manacher()&#123; ll maxright=0,mid; for(ll i=1; i&lt;=len; i++) &#123; if(i&lt;maxright) hw[i]=min(hw[(mid&lt;&lt;1)-i],hw[mid]+mid-i); else hw[i]=1; for(; str[i+hw[i]]==str[i-hw[i]]; ++hw[i]); if(hw[i]+i&gt;maxright) &#123; maxright=hw[i]+i; mid=i; &#125; &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,s+1); scanf(&quot;%s&quot;,t+1); ll len_s=strlen(s+1); ll len_t=strlen(t+1); qpow[0]=1; for(int i=1;i&lt;=min(len_s,len_t)+2;++i) qpow[i]=qpow[i-1]*101%mod; len=len_s; for(ll i=1,j=len_t; i&lt;j; i++,j--) swap(t[i],t[j]); hs[1]=s[1]-&apos;a&apos;; ht[1]=t[1]-&apos;a&apos;; for(ll i=1; i&lt;=len_s; i++) hs[i]=(hs[i-1]*p+s[i]-&apos;a&apos;)%mod; for(ll i=1; i&lt;=len_t; i++) ht[i]=(ht[i-1]*p+t[i]-&apos;a&apos;)%mod; init(); manacher(); for(ll i=1; i&lt;=len; i++) &#123; ll r=(hw[i]-1)/2; if(!(i&amp;1)) &#123; //@#a#a# pre[i/2-r]++; pre[i/2]--; &#125; else &#123; //@#a#b#a# pre[(i-1)/2-r]++; pre[(i-1)/2+1]--; &#125; &#125; for(ll i=1; i&lt;=len_s; i++) pre[i]+=pre[i-1]; ll ans=0; for(ll i=1; i&lt;len_s; i++) &#123; if(s[i]!=t[len_t]) continue; ll l=0,r=min(i,len_t); while(l+1&lt;r) &#123; ll mid=(l+r)/2; if(ok(mid,i,len_t)) l=mid; else r=mid-1; &#125; if(ok(l+1,i,len_t)) l++; // cout&lt;&lt;l&lt;&lt;endl; ans+=l*pre[i+1]; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; 未完待续。。。","path":"2019/02/08/2018-ICPC-南京站/"},{"title":"Bzoj 1717 产奶的模式","text":"描述:传送门$求可重叠k次重复子串的最大长度。$ 思路:$具有相同公共前缀的后缀集合,它们的排名应该在一段连续 \\\\区间内，由这个思路可以二分,或者，对于一个height[i],找 \\\\一段连续区间，这个位置的height[i]最小，区间长度+1就是 \\\\子串出现次数，这不是单调栈的经典应用吗?$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//#include&lt;bits/stdc++.h&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=1e5+5;int n,m;int x[maxn],y[maxn],t[maxn],sa[maxn],rk[maxn],height[maxn];int l[maxn],r[maxn];stack&lt;int&gt;st;char s[maxn];int a[maxn];bool cmp(int i,int j,int k)&#123; return y[i]==y[j]&amp;&amp;y[i+k]==y[j+k];&#125;void get_sa()&#123; for(int i=1; i&lt;=n; ++i) t[x[i]=a[i]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[i]]--]=i; for(int k=1; k&lt;=n; k&lt;&lt;=1) &#123; int p=0; for(int i=0; i&lt;=m; ++i) y[i]=0; for(int i=n-k+1; i&lt;=n; ++i) y[++p]=i; for(int i=1; i&lt;=n; ++i) if(sa[i]&gt;k) y[++p]=sa[i]-k; for(int i=0; i&lt;=m; ++i) t[i]=0; for(int i=1; i&lt;=n; ++i) t[x[y[i]]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2; i&lt;=n; ++i) x[sa[i]]=cmp(sa[i],sa[i-1],k)?p:++p; if(p&gt;=n) break; m=p; &#125;&#125;void get_rk()&#123; for(int i=1; i&lt;=n; ++i) rk[sa[i]]=i;&#125;void get_height()&#123; for(int i=1,j=0; i&lt;=n; ++i) &#123; if(j) j--; while(a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; &#125;&#125;void ini()&#123; memset(sa,0,sizeof(sa)); memset(rk,0,sizeof(rk)); memset(height,0,sizeof(height)); memset(x,0,sizeof(x)); memset(y,0,sizeof(y)); memset(t,0,sizeof(t)); memset(a,0,sizeof(a));&#125;int main()&#123; int k; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); m=n; for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; get_sa(); get_rk(); get_height(); //height[1]=n-sa[1]+1; l[1]=1; st.push(1); for(int i=2; i&lt;=n; i++) &#123; while(!st.empty()&amp;&amp;height[st.top()]&gt;=height[i]) st.pop(); if(st.empty()) l[i]=1; else l[i]=st.top()+1; st.push(i); &#125; while(!st.empty()) st.pop(); r[n]=n; st.push(n); for(int i=n-1; i&gt;=1; i--) &#123; while(!st.empty()&amp;&amp;height[st.top()]&gt;=height[i]) st.pop(); if(st.empty()) r[i]=n; else r[i]=st.top()-1; st.push(i); &#125; int ans=-1; for(int i=1; i&lt;=n; i++) &#123; if(r[i]-l[i]+2&gt;=k) //这里是加2 ans=max(ans,height[i]); &#125; printf(&quot;%d\\n&quot;,ans);&#125;","path":"2019/02/07/Bzoj-1717-产奶的模式/"},{"title":"SPOJ - DISUBSTR","text":"描述:求字符串中本质不同的子串个数。 思路:$枚举每个排名的后缀对答案的贡献,排名为i的后缀里有n-sa[i]+1个前 \\\\缀,其中前缀被重复算贡献的次数是LCP(sa[i],sa[i-1]),所以答案是 \\\\\\sum n-sa[i]+1-height[i]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e3+5;int n,m;int x[maxn],y[maxn],t[maxn],sa[maxn],rk[maxn],height[maxn];char s[maxn];int a[maxn];bool cmp(int i,int j,int k)&#123; return y[i]==y[j]&amp;&amp;y[i+k]==y[j+k];&#125;void get_sa()&#123; for(int i=1; i&lt;=n; ++i) t[x[i]=a[i]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[i]]--]=i; for(int k=1; k&lt;=n; k&lt;&lt;=1) &#123; int p=0; for(int i=0; i&lt;=m; ++i) y[i]=0; for(int i=n-k+1; i&lt;=n; ++i) y[++p]=i; for(int i=1; i&lt;=n; ++i) if(sa[i]&gt;k) y[++p]=sa[i]-k; for(int i=0; i&lt;=m; ++i) t[i]=0; for(int i=1; i&lt;=n; ++i) t[x[y[i]]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2; i&lt;=n; ++i) x[sa[i]]=cmp(sa[i],sa[i-1],k)?p:++p; if(p&gt;=n) break; m=p; &#125;&#125;void get_rk()&#123; for(int i=1; i&lt;=n; ++i) rk[sa[i]]=i;&#125;void get_height()&#123; for(int i=1,j=0; i&lt;=n; ++i) &#123; if(j) j--; while(a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; &#125;&#125;void ini()&#123; memset(sa,0,sizeof(sa)); memset(rk,0,sizeof(rk)); memset(height,0,sizeof(height)); memset(x,0,sizeof(x)); memset(y,0,sizeof(y)); memset(t,0,sizeof(t)); memset(a,0,sizeof(a));&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ini(); scanf(&quot;%s&quot;,s+1); n=strlen(s+1); m=300; for(int i=1; i&lt;=n; i++) a[i]=s[i]; get_sa(); get_rk(); get_height(); int ans=0; for(int i=1; i&lt;=n; i++) &#123; ans+=(n-sa[i]+1-height[i]); &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;","path":"2019/02/05/SPOJ-DISUBSTR/"},{"title":"Bzoj 1031 字符加密","text":"描述:传送门 思路:把字符串倍增一份，然后求后缀数组就好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/************************************************************** Problem: 1031 User: Decaku Language: C++ Result: Accepted Time:1336 ms Memory:29612 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,m;int x[maxn],y[maxn],t[maxn],sa[maxn],rk[maxn],height[maxn];char s[maxn];int a[maxn];bool cmp(int i,int j,int k)&#123; return y[i]==y[j]&amp;&amp;y[i+k]==y[j+k];&#125;void get_sa()&#123; //int m=30; for(int i=1; i&lt;=n; ++i) t[x[i]=a[i]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[i]]--]=i; for(int k=1; k&lt;=n; k&lt;&lt;=1) &#123; int p=0; for(int i=0; i&lt;=m; ++i) y[i]=0; for(int i=n-k+1; i&lt;=n; ++i) y[++p]=i; for(int i=1; i&lt;=n; ++i) if(sa[i]&gt;k) y[++p]=sa[i]-k; for(int i=0; i&lt;=m; ++i) t[i]=0; for(int i=1; i&lt;=n; ++i) t[x[y[i]]]++; for(int i=1; i&lt;=m; ++i) t[i]+=t[i-1]; for(int i=n; i&gt;=1; --i) sa[t[x[y[i]]]--]=y[i]; swap(x,y); x[sa[1]]=p=1; for(int i=2; i&lt;=n; ++i) x[sa[i]]=cmp(sa[i],sa[i-1],k)?p:++p; if(p&gt;=n) break; m=p; &#125;&#125; void get_rk()&#123; for(int i=1; i&lt;=n; ++i) rk[sa[i]]=i;&#125;void get_height()&#123; for(int i=1,j=0; i&lt;=n; ++i) &#123; if(j) j--; while(a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=n+1;i&lt;=2*n;i++) s[i]=s[i-n]; for(int i=1;i&lt;=2*n;i++) a[i]=s[i]; n*=2; m=500; get_sa(); for(int i=1;i&lt;=n;i++) &#123; if(sa[i]&lt;=n/2) &#123; printf(&quot;%c&quot;,s[sa[i]+n/2-1]); &#125; &#125; printf(&quot;\\n&quot;); &#125;","path":"2019/02/05/Bzoj-1031-字符加密/"},{"title":"Codeforces Round 533 Div2","text":"A:暴力。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint a[1005];int n;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); int t,ans=1e9; for(int i=1;i&lt;=100;i++) &#123; int p=0; for(int j=1;j&lt;=n;j++) &#123; if(a[j]&lt;i-1) p+=i-1-a[j]; else if(a[j]&gt;i+1) p+=a[j]-(i+1); &#125; if(p&lt;ans) &#123; ans=p; t=i; &#125; &#125; printf(&quot;%d %d\\n&quot;,t,ans);&#125; B:$统计26个字母的level，然后比较。$ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=2e5+5;int cnt[30];char str[maxn];int n,k;vector&lt;char&gt;v;int main()&#123; memset(cnt,0,sizeof(cnt)); v.clear(); scanf(&quot;%d %d&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,str); //int tem=0; for(int i=0; i&lt;n; i++) &#123; //tem++; //v.push_back(str[i]); if(v.empty()||v[0]==str[i]) &#123; v.push_back(str[i]); if(v.size()==k) &#123; cnt[v[0]-&apos;a&apos;]++; v.clear(); &#125; &#125; else if(v[0]!=str[i]) &#123; v.clear(); v.push_back(str[i]); &#125; &#125; int ans=-1; for(int i=0; i&lt;=26; i++) ans=max(ans,cnt[i]); printf(&quot;%d\\n&quot;,ans);&#125; D:$计数dp，dp[i][j]表示前i个数的和模3等于j的方案数，答案是dp[n][0]。$ 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=2e5+5;const int mod=1e9+7;ll a[maxn],n,l,r;ll dp[maxn][3];int main()&#123; scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;l,&amp;r); ll a=r/3-(l-1)/3; ll b=(r+2)/3-(l+2-1)/3; ll c=(r+1)/3-(l+1-1)/3; dp[1][0]=a; dp[1][1]=b; dp[1][2]=c; for(int i=2;i&lt;=n;i++) &#123; dp[i][0]=(dp[i-1][0]*a%mod+dp[i-1][1]*c%mod+dp[i-1][2]*b%mod)%mod; dp[i][1]=(dp[i-1][0]*b%mod+dp[i-1][1]*a%mod+dp[i-1][2]*c%mod)%mod; dp[i][2]=(dp[i-1][0]*c%mod+dp[i-1][1]*b%mod+dp[i-1][2]*a%mod)%mod; &#125; printf(&quot;%lld&quot;,dp[n][0]);&#125; D:$bfs,用vector[i]维护第i个人走了第j步以后增加的格子。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,p;int s[11],a[1100][1100];int d[4][2]= &#123;1,0, -1,0, 0,1, 0,-1&#125;;char str[1100];vector&lt;pair&lt;int,int&gt; &gt;v[1100],t;int ans[11];bool bfs(int x)&#123; t.clear(); for(int i=0; i&lt;v[x].size(); i++) t.push_back(v[x][i]); v[x].clear(); int sz=t.size(); for(int i=0; i&lt;sz; i++) &#123; for(int j=0; j&lt;4; j++) &#123; int X=t[i].first,Y=t[i].second; if(X+d[j][0]&lt;1||X+d[j][0]&gt;n) continue; if(Y+d[j][1]&lt;1||Y+d[j][1]&gt;m) continue; if(a[X+d[j][0]][Y+d[j][1]]==0) &#123; a[X+d[j][0]][Y+d[j][1]]=x; v[x].push_back(make_pair(X+d[j][0],Y+d[j][1])); &#125; &#125; &#125; if(!v[x].size()) return 0; return 1;&#125;int main()&#123; memset(a,0,sizeof(a)); scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;p); for(int i=1; i&lt;=p; i++) scanf(&quot;%d&quot;,&amp;s[i]); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%s&quot;,str+1); for(int j=1; j&lt;=m; j++) &#123; if(str[j]==&apos;#&apos;) a[i][j]=-1; else if(str[j]!=&apos;.&apos;) &#123; a[i][j]=str[j]-&apos;0&apos;; v[str[j]-&apos;0&apos;].push_back(make_pair(i,j)); &#125; &#125; &#125; while(1) &#123; bool ok=false; for(int i=1; i&lt;=p; i++) for(int j=1; j&lt;=s[i]; j++) &#123; if(!bfs(i)) break; //只要有一次为真 就会为真 else ok=true; &#125; if(!ok) break; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(a[i][j]&gt;0) ans[a[i][j]]++; &#125; &#125; for(int i=1; i&lt;=p; i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n&quot;);&#125; E:$对于两个type1之间的朋友，只会选择一个朋友去修改名字，那么 \\\\可以把朋友作为结点，对于两个type1之间的结点，两两之间建立无 \\\\向边，最后即求尽量多的点，之间没有边，问题转化为最大独立集。 \\\\最大独立集等于补图最大团。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=45;int g[maxn][maxn];int ans,cnt[maxn],group[maxn],n,m,vis[maxn];bool dfs(int u,int pos)&#123; int i,j; for( i=u+1; i&lt;=m; i++) &#123; if(cnt[i]+pos&lt;=ans) return 0; if(g[u][i]) &#123; for( j=0; j&lt;pos; j++) if(!g[i][vis[j]]) break; if(j==pos) &#123; vis[pos]=i; if(dfs(i,pos+1)) return 1; &#125; &#125; &#125; if(pos&gt;ans) &#123; for(int i=0; i&lt;pos; i++) group[i]=vis[i]; ans=pos; return 1; &#125; return 0;&#125;void maxclique()&#123; ans=-1; for(int i=m; i&gt;0; i--) &#123; vis[0]=i; dfs(i,1); cnt[i]=ans; &#125;&#125;vector&lt;string&gt;v;map&lt;string,int&gt; mp;int tot;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; int type; scanf(&quot;%d&quot;,&amp;type); if(type==2) &#123; string str; cin&gt;&gt;str; v.push_back(str); if(mp[str]==0) mp[str]=++tot; //mp[str]=++tot; &#125; else &#123; for(int i=0; i&lt;v.size(); i++) &#123; for(int j=0; j&lt;i; j++) &#123; g[mp[v[i]]][mp[v[j]]]=1; g[mp[v[j]]][mp[v[i]]]=1; &#125; &#125; v.clear(); //mp.clear(); &#125; &#125; if(v.size()) &#123; for(int i=0; i&lt;v.size(); i++) &#123; for(int j=0; j&lt;i; j++) &#123; g[mp[v[i]]][mp[v[j]]]=1; g[mp[v[j]]][mp[v[i]]]=1; &#125; &#125; &#125; /*for(int i=1; i&lt;=m; i++) &#123; for(int j=1; j&lt;=m; j++) cout&lt;&lt;g[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; // return 0;*/ for(int i=1; i&lt;=m; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if(i!=j) g[i][j]^=1; &#125; &#125; maxclique(); printf(&quot;%d\\n&quot;,ans);&#125;","path":"2019/02/05/Codeforces-Round-533-Div2/"},{"title":"Bzoj 2115","text":"描述:$一个无向图，可能有自环与重边，选择一条从1到n的路径， \\\\每个点和边都可以重复经过，使边权异或和最大。$ 思路:$找出所有环，简单证明一下，先任意找一条路径,再找到环， \\\\如果环不在路径上，路径到环的这段距离会被走两次，异或 \\\\以后对答案不产生贡献，再证路径的任意性，如果存在一条 \\\\更优路径，更优路径与当前路径必然形成环，该环与当前选 \\\\择的路径进行异或即可得到更优路径。异或之和最大，即求 \\\\环的异或的线性基。在dfs过程中求环的异或时预处理一个 \\\\sz数组，sz[i]代表从1到i路径上的边权异或和$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/************************************************************** Problem: 2115 User: Decaku Language: C++ Result: Accepted Time:892 ms Memory:17572 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=5e4+5;const ll maxm=5e5+5;vector&lt;pair&lt;ll,ll&gt; &gt;g[maxn];ll n,m;ll vis[maxn],Xor[maxm],sz[maxm],cnt;ll p[65]; void dfs2(ll s,ll f)&#123; vis[s]=1; //for(ll i=g[s].size()-1;i&gt;=0;i--) for(ll i=0; i&lt;=g[s].size()-1; i++) &#123; ll v=g[s][i].first,w=g[s][i].second; if(v==f) continue; if(vis[v]) &#123; Xor[++cnt]=(sz[s]^sz[v]^w); continue; &#125; else &#123; sz[v]=(sz[s]^w); dfs2(v,s); &#125; &#125;&#125; int main()&#123; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m); for(ll i=1; i&lt;=m; i++) &#123; ll u,v,w; scanf(&quot;%lld %lld %lld&quot;,&amp;u,&amp;v,&amp;w); g[u].push_back(make_pair(v,w)); g[v].push_back(make_pair(u,w)); &#125; memset(vis,0,sizeof(vis)); dfs2(1,0); for(int i=1; i&lt;=cnt; i++) &#123; for(int j=62; j&gt;=0; j--) &#123; if(!(Xor[i]&gt;&gt;j)) continue; if(!(p[j])) &#123; p[j]=Xor[i]; break; &#125; else Xor[i]^=p[j]; &#125; &#125; ll ans=sz[n]; for(int i=62; i&gt;=0; i--) &#123; if((ans^p[i])&gt;ans) ans^=p[i]; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","path":"2019/02/05/Bzoj-2115/"},{"title":"Codeforces Round #529 (Div. 3)","text":"A&amp;B:$A模拟,B两个case比较。$ 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int n; string str; scanf(&quot;%d&quot;,&amp;n); cin&gt;&gt;str; string ans=&quot;&quot;; int ct=1; for(int i=0; i&lt;n; i+=ct) &#123; ans+=str[i]; ct++; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e5+5;int a[maxn];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); int ans=0; ans=min(a[n-1]-a[1],a[n]-a[2]); printf(&quot;%d\\n&quot;,ans);&#125; C:所有数都是可以拆的,贪心的不断把大数除2直到变成1，特判输入是1,1的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint n,k;vector&lt;int&gt;ans,v,t;void ini()&#123; for(int i=1; i&lt;=n; i*=2) &#123; v.push_back(i); &#125;&#125;bool solve()&#123; while(1) &#123; int tem=*(upper_bound(v.begin(),v.end(),n)-1); t.push_back(tem); n-=tem; if(!n) break; &#125; if(t.size()&gt;k) return false; else &#123; int sz=t.size(); while(sz&lt;k) &#123; t[0]/=2; if(t[0]==1) &#123; ans.push_back(t[0]); ans.push_back(t[0]); t.erase(t.begin()); sz++; &#125; else &#123; t.push_back(t[0]); t.push_back(t[0]); t.erase(t.begin()); sz++; &#125; &#125; &#125; return true;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); ini(); if(n&amp;1) &#123; ans.push_back(1); n--; k--; &#125; if(n==0&amp;&amp;k==0) &#123; puts(&quot;YES&quot;); puts(&quot;1&quot;); &#125; else if(k&gt;n) &#123; puts(&quot;NO&quot;); &#125; else &#123; if(!solve()) puts(&quot;NO&quot;); else &#123; puts(&quot;YES&quot;); for(int i=0; i&lt;ans.size(); i++) printf(&quot;%d &quot;,ans[i]); for(int i=0; i&lt;t.size(); i++) printf(&quot;%d &quot;,t[i]); &#125; &#125;&#125; D:$如果i的两个临接数是a和b且i的下一个数就是a,那么a的两个 \\\\邻接数里一定有b，然后就可以建图了，输出答案一遍dfs即可。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=4e5+5;vector&lt;int&gt;v[maxn];int n;struct Edge&#123; int nex,to;&#125; e[maxn];int head[maxn],cnt,vis[maxn];void ini()&#123; memset(head,-1,sizeof(head)); memset(vis,0,sizeof(vis)); cnt=-1;&#125;void add_edge(int u,int v)&#123; e[++cnt].nex=head[u]; e[cnt].to=v; head[u]=cnt;&#125;void dfs(int u)&#123; printf(&quot;%d &quot;,u); vis[u]=1; for(int i=head[u]; i!=-1; i=e[i].nex) &#123; int v=e[i].to; if(vis[v]) continue; dfs(v); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); v[i].push_back(x); v[i].push_back(y); &#125; ini(); for(int i=1; i&lt;=n; i++) &#123; int x=v[i][0],y=v[i][1]; if(v[x][0]==y||v[x][1]==y) &#123; add_edge(i,x); add_edge(x,y); &#125; else &#123; add_edge(i,y); add_edge(y,x); &#125; &#125; dfs(1); printf(&quot;\\n&quot;);&#125; E:正着反着各扫描一遍字符串处理4个数组，然后对于每个位置判断一下把它反转以后是否能使得字符串平衡。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e6+5;char str[maxn];int n;int pre[maxn],prec[maxn],suf[maxn],sufc[maxn];//pre[i]前i个字符的封闭度//prec[i]前i个字符是否可以作前缀//suf[i] i到n的字符封闭度//sufc[i] i到n的字符是否可以做后缀int main()&#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,str+1); if(str[1]==&apos;(&apos;) &#123; pre[1]=1; prec[1]=1; &#125; else &#123; pre[1]=-1; prec[1]=0; &#125; for(int i=2; i&lt;=n; i++) &#123; if(str[i]==&apos;(&apos;) pre[i]=pre[i-1]+1; else pre[i]=pre[i-1]-1; if(prec[i-1]&amp;&amp;pre[i]&gt;=0) prec[i]=1; else prec[i]=0; &#125; if(str[n]==&apos;)&apos;) &#123; suf[n]=1; sufc[n]=1; &#125; else &#123; suf[n]=-1; sufc[n]=0; &#125; for(int i=n-1; i&gt;=1; i--) &#123; if(str[i]==&apos;)&apos;) suf[i]=suf[i+1]+1; else suf[i]=suf[i+1]-1; if(sufc[i+1]&amp;&amp;suf[i]&gt;=0) sufc[i]=1; else sufc[i]=0; &#125; int ans=0; prec[0]=sufc[n+1]=1; for(int i=1; i&lt;=n; i++) &#123; if(prec[i-1]&amp;&amp;sufc[i+1]) &#123; if(str[i]==&apos;)&apos;&amp;&amp;suf[i+1]-pre[i-1]==1) ans++; if(str[i]==&apos;(&apos;&amp;&amp;pre[i-1]-suf[i+1]==1) ans++; &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;//( ( ( ( ) ) F:$直接求MST复杂度会爆炸,但是容易发现只有n条边可能在MST里。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=2e5+5;ll n,m;ll f[maxn],W[maxn];void ini()&#123; for(ll i=0;i&lt;maxn;i++) f[i]=i;&#125;ll Find(ll x)&#123; return f[x]==x?x:f[x]=Find(f[x]);&#125;void join(ll a,ll b)&#123; f[Find(a)]=Find(b);&#125;struct edge&#123; ll u,v,w;&#125; e[maxn&lt;&lt;2];bool cmp(edge a,edge b)&#123; return a.w&lt;b.w;&#125;ll cnt;int main()&#123; ini(); scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m); ll pos=1; for(ll i=1; i&lt;=n; i++) &#123; scanf(&quot;%lld&quot;,&amp;W[i]); if(W[i]&lt;W[pos]) pos=i; &#125; for(ll i=1; i&lt;=n; i++) &#123; if(i!=pos) &#123; e[++cnt].u=pos; e[cnt].v=i; e[cnt].w=W[pos]+W[i]; &#125; &#125; for(ll i=1; i&lt;=m; i++) &#123; ll u,v,w; scanf(&quot;%lld %lld %lld&quot;,&amp;u,&amp;v,&amp;w); e[++cnt].u=u; e[cnt].v=v; e[cnt].w=w; &#125; sort(e+1,e+cnt+1,cmp); ll ans=0; for(ll i=1; i&lt;=cnt; i++) &#123; ll u=e[i].u,v=e[i].v,w=e[i].w; if(Find(u)!=Find(v)) &#123; join(u,v); ans+=w; &#125; &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","path":"2019/02/05/Codeforces-Round-529-Div-3/"},{"title":"Poj 2104 Kth number","text":"描述:$多组询问，每次求给定区间里第k小的数。$ 思路:划分树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int tree[20][maxn];int sorted[maxn];int toleft[20][maxn];void build(int l,int r,int dep)&#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; int same=mid-l+1; for(int i=l; i&lt;=r; i++) if(tree[dep][i]&lt;sorted[mid]) same--; int lpos=l; int rpos=mid+1; for(int i=l; i&lt;=r; i++) &#123; if(tree[dep][i]&lt;sorted[mid]) tree[dep+1][lpos++]=tree[dep][i]; else if(tree[dep][i]==sorted[mid]&amp;&amp;same&gt;0) &#123; tree[dep+1][lpos++]=tree[dep][i]; same--; &#125; else tree[dep+1][rpos++]=tree[dep][i]; toleft[dep][i]=toleft[dep][l-1]+lpos-l; &#125; build(l,mid,dep+1); build(mid+1,r,dep+1);&#125;int query(int L,int R,int l,int r,int dep,int k)&#123; if(l==r) return tree[dep][l]; int mid=(L+R)&gt;&gt;1; int cnt=toleft[dep][r]-toleft[dep][l-1]; if(cnt&gt;=k) &#123; int newl=L+toleft[dep][l-1]-toleft[dep][L-1]; int newr=newl+cnt-1; return query(L,mid,newl,newr,dep+1,k); &#125; else &#123; int newr=r+toleft[dep][R]-toleft[dep][r]; int newl=newr-(r-l-cnt); return query(mid+1,R,newl,newr,dep+1,k-cnt); &#125;&#125;int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2) &#123; memset(tree,0,sizeof(tree)); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;tree[0][i]); sorted[i]=tree[0][i]; &#125; sort(sorted+1,sorted+n+1); build(1,n,0); int s,t,k; while(m--) &#123; scanf(&quot;%d %d %d&quot;,&amp;s,&amp;t,&amp;k); printf(&quot;%d\\n&quot;,query(1,n,s,t,0,k)); &#125; &#125; return 0;&#125;","path":"2019/02/05/Poj-2104-Kth-number/"},{"title":"Codeforces Round #521 Div3","text":"A:模拟。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); ll a,b,k,ans; while(t--) &#123; scanf(&quot;%lld %lld %lld&quot;,&amp;a,&amp;b,&amp;k); ans=0; ans+=(k+1)/2*a; ans-=(k-(k+1)/2)*b; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; B:贪心。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;int n,a[200],vis[200];vector&lt;int&gt;v;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=2; i&lt;=n-1; i++) &#123; if(!a[i]&amp;&amp;a[i-1]&amp;&amp;a[i+1]) v.push_back(i); &#125; int k; if(v.empty()) k=0; else &#123; k=1; vis[v[0]]=1; for(int i=1; i&lt;v.size(); i++) &#123; if(v[i]-v[i-1]==2&amp;&amp;vis[v[i-1]]) continue; k++; vis[v[i]]=1; &#125; &#125; printf(&quot;%d\\n&quot;,k);&#125; C:作为和的数一定最大。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;const int maxn=2e5+5;int n;struct Node&#123; int id,w;&#125;a[maxn];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;ll sum;vector&lt;int&gt;v;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i].w),sum+=a[i].w,a[i].id=i; sort(a,a+n+1,cmp); ll ans=0; for(int i=1;i&lt;n;i++) &#123; ll tem=sum; if(tem-a[i].w-a[n].w==a[n].w) v.push_back(a[i].id),ans++; &#125; if(sum-a[n].w-a[n-1].w==a[n-1].w) v.push_back(a[n].id),ans++; printf(&quot;%d\\n&quot;,ans); for(int i=0;i&lt;v.size();i++) printf(&quot;%d &quot;,v[i]); printf(&quot;\\n&quot;);&#125; D:二分删掉的数在原数组里出现的次数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;int a[maxn],cnt[maxn],n,k,_cnt;vector&lt;int&gt;v;bool check(int mid)&#123; int res=0; for(int i=1; i&lt;=n;) &#123; if(res&gt;=k) return true; res+=cnt[a[i]]/mid; i+=cnt[a[i]]; &#125; if(res&gt;=k) return true; return false;&#125;bool cmp(int x,int y)&#123; if(cnt[x]==cnt[y]) return x&lt;y; return cnt[x]&gt;cnt[y];&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); _cnt=n/k; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]),cnt[a[i]]++; sort(a+1,a+n+1,cmp); int l=1,r=_cnt; while((r-l)&gt;1) &#123; int mid=(l+r)/2; if(check(mid)) &#123; l=mid; &#125; else r=mid-1; &#125; if(check(r)) l=r; int res=0; for(int i=1; i&lt;=n;) &#123; if(res&gt;=k) break; for(int j=1; j&lt;=cnt[a[i]]/l; j++) &#123; v.push_back(a[i]); &#125; res+=cnt[a[i]]/l; i+=cnt[a[i]]; &#125; for(int i=0; i&lt;k; i++) &#123; printf(&quot;%d &quot;,v[i]); &#125; printf(&quot;\\n&quot;);&#125; E:$记录每个数的次数后sort,对每个位置的查找都二分。$ 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5+5;int a[maxn],n;map&lt;int,int&gt;mp;vector&lt;int&gt;v;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); mp[a[i]]++; &#125; for(map&lt;int,int&gt;::iterator it=mp.begin(); it!=mp.end(); it++) &#123; v.push_back(it-&gt;second); &#125; sort(v.begin(),v.end()); int ans=-1; for(int i=1; i&lt;=n; i++) &#123; int x=i; int d=0,tem=0; while(1) &#123; int pos=lower_bound(v.begin()+d,v.end(),x)-v.begin(); if(pos==v.size()) break; tem+=x; x&lt;&lt;=1; d=pos+1; &#125; ans=max(ans,tem); &#125; printf(&quot;%d\\n&quot;,ans);&#125; F&amp;G:$dp过程中要用到滑窗最值,hard version用单调队列优化就好。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll inf=1e15;const ll maxn=5005;ll n,k,x;ll a[maxn],dp[maxn][maxn];//dp[i][j]前j个数选i个且必选第j个数能取得的最大值ll q[maxn][maxn],l,r; //q[i-1][l]代表dp[i-1][j]到dp[i-1][j-k+1]的最大值//dp[i][j]=max(dp[i-1][t])+a[j] (j-k+1&lt;=t&lt;j)int main()&#123; scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;k,&amp;x); for(ll i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(ll i=1; i&lt;maxn; i++) for(ll j=1; j&lt;maxn; j++) dp[i][j]=-inf; for(ll j=1; j&lt;=k; j++) dp[1][j]=a[j]; for(ll i=2; i&lt;=x; i++) &#123; l=0,r=-1; for(ll j=1; j&lt;=n; j++) &#123; if(l&lt;=r) dp[i][j]=dp[i-1][q[i-1][l]]+a[j]; while(l&lt;=r&amp;&amp;dp[i-1][j]&gt;=dp[i-1][q[i-1][r]]) r--; q[i-1][++r]=j; if(l&lt;=r&amp;&amp;q[i-1][l]&lt;j-k+1) l++; &#125; &#125; ll ans=-1; for(ll j=n; j&gt;n-k&amp;&amp;j&gt;=1; j--) ans=max(ans,dp[x][j]); if(ans) printf(&quot;%lld\\n&quot;,ans); else puts(&quot;-1&quot;);&#125;","path":"2019/02/05/Codeforces-Round-521-Div3/"},{"title":"Bzoj 1069 最大土地面积","text":"描述:给出若干个点，取四个点，求最大四边形面积。 思路:很明显这四个点都在凸包上，所以先做个凸包，然后枚举对角线，在两边旋转卡壳求两个最大三角的面积。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/************************************************************** Problem: 1069 User: Decaku Language: C++ Result: Accepted Time:152 ms Memory:1356 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;int n,top;struct P&#123; double x,y;&#125; p[2005],s[2005]; double dis(P a,P b)&#123; return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);&#125; P operator -(P a,P b)&#123; P t; t.x=a.x-b.x; t.y=a.y-b.y; return t;&#125; double operator *(P a,P b)&#123; return a.x*b.y-a.y*b.x;&#125; bool operator &lt;(P a,P b)&#123; double t=(a-p[1])*(b-p[1]); if(t==0) return dis(a,p[1])&lt;dis(b,p[1]); return t&lt;0;&#125; void graham()&#123; int k=1; for(int i=2; i&lt;=n; i++) if(p[k].y&gt;p[i].y||(p[k].y==p[i].y&amp;&amp;p[k].x&gt;p[i].x)) k=i; swap(p[1],p[k]); sort(p+2,p+n+1); s[++top]=p[1]; s[++top]=p[2]; for(int i=3; i&lt;=n; i++) &#123; while(top&gt;1&amp;&amp;(p[i]-s[top-1])*(s[top]-s[top-1])&lt;=0) top--; s[++top]=p[i]; &#125; s[top+1]=p[1];&#125; double RC()&#123; double ans=0; int a,b; for(int x=1; x&lt;=top; x++) &#123; a=x%top+1; b=(x+2)%top+1; for(int y=x+2; y&lt;=top; y++) &#123; while(a%top+1!=y&amp;&amp;(s[y]-s[x])*(s[a+1]-s[x])&gt;(s[y]-s[x])*(s[a]-s[x])) a=a%top+1; while(b%top+1!=x&amp;&amp;(s[b+1]-s[x])*(s[y]-s[x])&gt;(s[b]-s[x])*(s[y]-s[x])) b=b%top+1; ans=max((s[y]-s[x])*(s[a]-s[x])+(s[b]-s[x])*(s[y]-s[x]),ans); &#125; &#125; return ans/2;&#125; int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%lf %lf&quot;,&amp;p[i].x,&amp;p[i].y); graham(); printf(&quot;%.3lf\\n&quot;,RC());&#125;","path":"2019/02/05/Bzoj-1069-最大土地面积/"},{"title":"Codeforces Round #522 ","text":"A:贪心。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int cnt[101];int main()&#123; memset(cnt,0,sizeof(cnt)); int n,k; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); for(int i=1; i&lt;=n; i++) &#123; int tem; scanf(&quot;%d&quot;,&amp;tem); cnt[tem]++; &#125; int _cnt=-1e9; for(int i=1; i&lt;=100; i++) &#123; _cnt=max(_cnt,cnt[i]); &#125; int tem=ceil(1.0*_cnt/k); int ans=0; for(int i=1; i&lt;=100; i++) &#123; if(!cnt[i]) continue; ans+=tem*k-cnt[i]; &#125; printf(&quot;%d\\n&quot;,ans);&#125; B:贪心。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;string str;int main()&#123; cin&gt;&gt;str; int len=str.length(); int _len=len; bool ok=false; int _1,_2=inf; while(1) &#123; for(int i=1; i&lt;=len; i++) &#123; if(len/i&gt;20||len%i!=0||i&gt;5) //i是组数 continue; else if(i&lt;_2) &#123; _1=len; _2=i; &#125; &#125; if(len==100) break; len++; &#125; int a=_1-_len; int b=a; printf(&quot;%d %d\\n&quot;,_2,_1/_2);//_1/_2是每行的长度,_2是行数 for(int i=1; i&lt;=_2; i++) &#123; for(int j=1; j&lt;=_1/_2; j++) &#123; if(j==_1/_2&amp;&amp;a&gt;0) &#123; cout&lt;&lt;&quot;*&quot;; a--; break; &#125; int pos=(i-1)*(_1/_2)+j-1-(b-a); cout&lt;&lt;str[pos]; &#125; cout&lt;&lt;endl; &#125;&#125; C:$dp[i][j]代表第i个位置能否放j,直接转移 \\\\因为要打印路径，再记录一下每个状态的前驱。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int n;int a[maxn],dp[maxn][6],pre[maxn][6];//pre[i][j]保存dp[i][j]的前一个状态void dfs(int i,int j)//i个位置选j&#123; if(i==1) &#123; cout&lt;&lt;j&lt;&lt;&quot; &quot;; return ; &#125; dfs(i-1,pre[i][j]); cout&lt;&lt;j&lt;&lt;&quot; &quot;;&#125;int main()&#123; memset(dp,0,sizeof(dp)); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int j=1;j&lt;=5;j++) dp[1][j]=1; for(int i=2; i&lt;=n; i++) &#123; if(a[i]==a[i-1]) &#123; for(int j=1; j&lt;=5; j++) &#123; for(int k=1; k&lt;=5; k++)//k是前一个 if(dp[i-1][k]&amp;&amp;j!=k) dp[i][j]=1, pre[i][j]=k; //pre[i][j]= &#125; &#125; else if(a[i]&gt;a[i-1]) &#123; for(int j=1; j&lt;=5; j++) &#123; for(int k=1; k&lt;=5; k++) if(dp[i-1][k]&amp;&amp;j&gt;k) dp[i][j]=1, pre[i][j]=k; &#125; &#125; else if(a[i]&lt;a[i-1]) &#123; for(int j=1; j&lt;=5; j++) &#123; for(int k=1; k&lt;=5; k++) if(dp[i-1][k]&amp;&amp;j&lt;k) dp[i][j]=1, pre[i][j]=k; &#125; &#125; &#125; int ans=0,tem; for(int j=1; j&lt;=5; j++) if(dp[n][j]) ans=1,tem=j; if(!ans) cout&lt;&lt;-1&lt;&lt;endl; else &#123; dfs(n,tem); cout&lt;&lt;endl; &#125;&#125; D:$猜了一下，应该只有五种case,都算出来取最小值即可。$ 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;double a,b,c;double x_1,y_1,x_2,y_2;double dis(double a,double b,double c,double d)&#123; return sqrt((a-c)*(a-c)+(b-d)*(b-d));&#125;int main()&#123; scanf(&quot;%lf %lf %lf&quot;,&amp;a,&amp;b,&amp;c); scanf(&quot;%lf %lf %lf %lf&quot;,&amp;x_1,&amp;y_1,&amp;x_2,&amp;y_2); double ans=abs(x_1-x_2)+abs(y_1-y_2); double p=(-1*c-b*y_1)/a,q=(-1*c-a*x_1)/b,r=(-1*c-b*y_2)/a,s=(-1*c-a*x_2)/b; double tem=abs(p-x_1)+abs(r-x_2)+dis(p,y_1,r,y_2); ans=min(ans,tem); tem=abs(p-x_1)+abs(s-y_2)+dis(p,y_1,x_2,s); ans=min(ans,tem); tem=abs(q-y_1)+abs(r-x_2)+dis(x_1,q,r,y_2); ans=min(ans,tem); tem=abs(q-y_1)+abs(s-y_2)+dis(x_1,q,x_2,s); ans=min(ans,tem); printf(&quot;%.10lf\\n&quot;,ans);&#125; E:$如果只有2种物品，ans最大可能是n，超过两种，能够鉴别出 \\\\的砝码必须质量都相等。所以可以先做一次背包，求出i个砝码 \\\\组成质量为j的方案数，有一个优化是dp过程中方案超过2就没意 \\\\义了，它不可能是答案。然后对每种物品枚举数量，检查方案数 \\\\是否只有一种，更新答案。要注意的是ans是n的情况要加特判。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[110],dp[10005][110];//dp[i][j]表示用j个物品正好装满容量为i的背包的方案数。map&lt;int,int&gt;m;vector&lt;pair&lt;int,int&gt; &gt;v;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); m[a[i]]++; &#125; for(map&lt;int,int&gt;::iterator it=m.begin(); it!=m.end(); it++) &#123; v.push_back(*it); &#125; dp[0][0]=1; for(vector&lt;pair&lt;int,int&gt; &gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; int tem=it-&gt;first; int cnt=it-&gt;second; for(int v=10000; v&gt;0; v--) &#123; for(int i=1; i&lt;=n; i++) &#123; for(int t=1; t&lt;=cnt&amp;&amp;t&lt;=i&amp;&amp;v-tem*t&gt;=0; t++) dp[v][i]+=dp[v-tem*t][i-t],dp[v][i]=min(dp[v][i],2); &#125; &#125; &#125; int ans=1; for(vector&lt;pair&lt;int,int&gt; &gt;::iterator it=v.begin(); it!=v.end(); it++) &#123; int tem=it-&gt;first; int cnt=it-&gt;second; for(int t=1; t&lt;=cnt; t++) &#123; if(dp[tem*t][t]==1) &#123; if(v.size()==2&amp;&amp;t==cnt) &#123; printf(&quot;%d\\n&quot;,n); return 0; &#125; else ans=max(ans,t); &#125; &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125;","path":"2019/02/05/Codeforces-Round-522/"},{"title":"2014 ICPC 北京站","text":"A:$sort一下，注意除法转乘法因为浮点数的运算误差$ 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct Node&#123; int t,p;&#125; e[10005],e_2[10005];bool cmp(Node x, Node y)&#123; return x.t&lt;y.t;&#125;bool cmp2(Node x,Node y)&#123; return 1ll*x.p*y.t&gt;1ll*y.p*x.t;&#125;int main()&#123; int T,n; scanf(&quot;%d&quot;,&amp;T); for(int Time=1; Time&lt;=T; Time++) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d %d&quot;,&amp;e[i].t,&amp;e[i].p); sort(e+1,e+n+1,cmp); for(int i=2; i&lt;=n; i++) &#123; e_2[i].t=e[i].t-e[i-1].t; e_2[i].p=abs(e[i].p-e[i-1].p); &#125; sort(e_2+2,e_2+1+n,cmp2); double x=1; printf(&quot;Case #%d: %.2lf\\n&quot;,Time,x*e_2[2].p/e_2[2].t); &#125;&#125; K:树状数组差分乱搞。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,tree[maxn];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int k,int d)&#123; for(int i=k; i&lt;=n; i+=lowbit(i)) &#123; tree[i]+=d; &#125;&#125;int sigma(int k)&#123; int res=0; while(k&gt;0) &#123; res+=tree[k]; k-=lowbit(k); &#125; return res;&#125;int t,tem,ans,id[maxn];int main()&#123; scanf(&quot;%d&quot;,&amp;t); for(int time=1; time&lt;=t; time++) &#123; memset(tree,0,sizeof(tree)); ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;tem); id[tem]=i; add(i,1); &#125; for(int i=n; i&gt;0; i--) &#123; if(sigma(id[i])!=i) &#123; ans++; add(id[i],-1); &#125; &#125; printf(&quot;Case #%d: %d\\n&quot;,time,ans); &#125;&#125; H:$两数异或以后不会大于它们的和，直接暴力dp。$ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll maxn=1&lt;&lt;20;ll a[1&lt;&lt;21],dp[2][1&lt;&lt;21];ll t,n,m;int main()&#123; scanf(&quot;%lld&quot;,&amp;t); for(ll time=1; time&lt;=t; time++) &#123; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m); memset(a,0,sizeof(a)); for(ll i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(ll i=0; i&lt;maxn*2; i++) &#123; if(a[1]==i) dp[1][i]=1; else dp[1][i]=0; &#125; dp[1][0]=1; ll tem=0,ans=0; for(ll i=2; i&lt;=n; i++) &#123; for(ll j=0; j&lt;maxn*2; j++) &#123; dp[tem][j]=dp[1-tem][j]+dp[1-tem][j^a[i]]; &#125; tem=1-tem; &#125; for(ll i=m;i&lt;maxn;i++) ans+=dp[1-tem][i]; printf(&quot;Case #%lld: %lld\\n&quot;,time,ans); &#125;&#125; I:算圆环的交转换到算圆的交，然后套模板就好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-8;const double pi=acos(-1.0);int t;double R,r,x_1,y_1,x_2,y_2;int sgn(double x)&#123; if(fabs(x)&lt;eps) return 0; if(x&lt;0) return -1; else return 1;&#125;struct Point&#123; double x,y; Point() &#123;&#125; Point(double _x,double _y) &#123; x=_x; y=_y; &#125; double distance(Point p) &#123; return hypot(x-p.x,y-p.y); &#125;&#125;;struct circle&#123; Point p; double r; circle() &#123;&#125; double area() &#123; return pi*r*r; &#125; int relationship(circle v) &#123; double d=p.distance(v.p); if(sgn(d-r-v.r)&gt;0) return 5; if(sgn(d-r-v.r)==0) return 4; double l=fabs(r-v.r); if(sgn(d-r-v.r)&lt;0 &amp;&amp; sgn(d-l)&gt;0) return 3; if(sgn(d-l)==0) return 2; if(sgn(d-l)&lt;0) return 1; &#125; double areacircle(circle v) &#123; int rel=relationship(v); if(rel&gt;=4) return 0.0; if(rel&lt;=2) return min(area(),v.area()); double d=p.distance(v.p); double hf=(r+v.r+d)/2.0; double ss=2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d)); double a1=acos((r*r+d*d-v.r*v.r)/(2.0*r*d)); a1=a1*r*r; double a2=acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d)); a2=a2*v.r*v.r; return a1+a2-ss; &#125;&#125;;int main()&#123; scanf(&quot;%d&quot;,&amp;t); circle A,a,B,b; for(int time=1; time&lt;=t; time++) &#123; scanf(&quot;%lf %lf&quot;,&amp;r,&amp;R); scanf(&quot;%lf %lf&quot;,&amp;x_1,&amp;y_1); scanf(&quot;%lf %lf&quot;,&amp;x_2,&amp;y_2); A.p=a.p=Point(x_1,y_1); B.p=b.p=Point(x_2,y_2); A.r=B.r=R; a.r=b.r=r; double ans=0; ans=ans+A.areacircle(B)-A.areacircle(b)*2+a.areacircle(b); printf(&quot;Case #%d: %.6lf\\n&quot;,time,ans); &#125;&#125; D:$区间dp$ 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=2e9;int t,n;int dp[205][205],a[205],b[205];int main()&#123; scanf(&quot;%d&quot;,&amp;t); for(int time=1;time&lt;=t;time++) &#123; for(int i=0; i&lt;205; i++) for(int j=i; j&lt;205; j++) dp[i][j]=inf; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;b[i]); a[0]=b[0]=a[n+1]=b[n+1]=0; for(int len=1; len&lt;=n; len++) &#123; for(int s=1; s+len-1&lt;=n; s++) &#123; int e=s+len-1; for(int mid=s; mid&lt;=e; mid++) &#123; dp[s][e]=min(dp[s][e],dp[s][mid-1]+dp[mid+1][e]+a[mid]+b[s-1]+b[e+1]); &#125; &#125; &#125; printf(&quot;Case #%d: %d\\n&quot;,time,dp[1][n]); &#125;&#125; 未完待续。。。","path":"2019/02/05/2014-ICPC-北京站/"},{"title":"2012 ICPC 杭州站","text":"I:模拟。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;int dat[256];#pragma warning(disable:4996)int main()&#123; dat[&apos;A&apos;] = 16; dat[&apos;B&apos;] = 7; dat[&apos;C&apos;] = 8; dat[&apos;D&apos;] = 1; dat[&apos;E&apos;] = 1; dat[&apos;F&apos;] = 2; dat[&apos;G&apos;] = 3; int T; int A, B; cin &gt;&gt; T; for (int tim = 1; tim &lt;= T; tim++) &#123; cin &gt;&gt; A; int flagA = 0; int flagA1 = 0; int flagB = 0; int flagB1 = 0; int sum = 0; char tmp; for (int i = 0; i &lt; A; i++) &#123; cin &gt;&gt; tmp; if (tmp == &apos;B&apos;)flagA = 1; else if (tmp == &apos;C&apos;)flagA1 = 1; sum += dat[tmp]; &#125; if ((!flagA||!flagA1)&amp;&amp;sum&gt;1)sum--; cin &gt;&gt; B; int sumB = 0; for (int i = 0; i &lt; B; i++) &#123; cin &gt;&gt; tmp; sumB += dat[tmp]; if (tmp == &apos;B&apos;)flagB = 1; else if (tmp == &apos;C&apos;)flagB1 = 1; &#125; if ((!flagB1||!flagB)&amp;&amp;sumB&gt;1)sumB--; if (sum &gt; sumB)puts(&quot;red&quot;); else if (sum == sumB)puts(&quot;tie&quot;); else puts(&quot;black&quot;); &#125; return 0;&#125; K:$MST。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int f[60];double ans=0;int Find(int a)&#123; return f[a]==a?a:f[a]=Find(f[a]);&#125;int join(int a,int b)&#123; f[Find(a)]=Find(b);&#125;struct edge&#123; int u,v; double w;&#125; e[3000];bool cmp(edge a,edge b)&#123; return a.w&lt;b.w;&#125;void join(edge &amp;e)&#123; if(Find(e.u)!=Find(e.v)) &#123; f[Find(e.u)]=Find(e.v); ans+=e.w; &#125;&#125;struct Point&#123; int x,y;&#125; point[60];int n,a,b;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(n==0) break; for(int i=0; i&lt;60; i++) f[i]=i; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;point[i].x,&amp;point[i].y); &#125; int cnt=0; for(int i=1; i&lt;=n; i++) for(int j=i; j&lt;=n; j++) &#123; e[++cnt].u=i; e[cnt].v=j; e[cnt].w=sqrt((point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y)); &#125; sort(e+1,e+cnt+1,cmp); ans=0; f[a]=b; ans+=sqrt((point[a].x-point[b].x)*(point[a].x-point[b].x)+(point[a].y-point[b].y)*(point[a].y-point[b].y)); for(int i=1; i&lt;=cnt; i++) join(e[i]); printf(&quot;%.2lf\\n&quot;,ans); &#125;&#125; H:$对每个点跑一边堆优化的Dij。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt;mp;int f[1005];int Find(int a)&#123; return f[a]==a?a:f[a]=Find(f[a]);&#125;void join(int a,int b)&#123; f[Find(a)]=Find(b);&#125;struct dijkstra&#123; static const int maxn=1005; static const int maxm=20010; struct edge &#123; int v,w,nex; &#125; g[maxm]; int head[maxn],d[maxn]; bool done[maxn]; int n,cnt; void ini(int newn) &#123; n=newn; cnt=0; memset(head,-1,sizeof(head)); &#125; void add_edge(int u,int v,int w) &#123; g[cnt].v=v; g[cnt].w=w; g[cnt].nex=head[u]; head[u]=cnt++; &#125; struct HeapNode &#123; int d,u; bool operator &lt; (const HeapNode&amp; rhs)const &#123; return d&gt;rhs.d; &#125; &#125;; int short_path(int s) &#123; int ret=s; priority_queue&lt;HeapNode&gt;q; //memset(d,0,sizeof(d)); fill(d,d+n+1,1e9); d[s]=0; memset(done,0,sizeof(done)); q.push(HeapNode&#123;d[s],s&#125;); while(!q.empty()) &#123; HeapNode x=q.top(); q.pop(); int u=x.u; if(done[u]) continue; done[u]=true; for(int i=head[u]; ~i; i=g[i].nex) &#123; if(d[g[i].v]&gt;d[u]+g[i].w) &#123; d[g[i].v]=d[u]+g[i].w; if(d[g[i].v]&gt;d[ret]) ret=g[i].v; q.push(HeapNode&#123;d[g[i].v],g[i].v&#125;); &#125; &#125; &#125; return ret; &#125;&#125; g;int main()&#123; int n,m; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; mp.clear(); srand(time(NULL)); if(n==0) break; g.ini(n+1); string c,d; for(int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;c; mp[c]=i; f[i]=i; &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=1; i&lt;=m; i++) &#123; cin&gt;&gt;c&gt;&gt;d; join(mp[c],mp[d]); g.add_edge(mp[c],mp[d],1); g.add_edge(mp[d],mp[c],1); &#125; int cnt=0; for(int i=1; i&lt;=n; i++) &#123; if(f[i]==i) cnt++; &#125; if(cnt&gt;1) puts(&quot;-1&quot;); else &#123; int ans=-1; for(int i=1; i&lt;=n; i++) &#123; int s=i; //int s=(rand()%n)+1; int t=g.short_path(s); ans=max(ans,g.d[t]); //s=g.short_path(t); //ans=max(ans,g.d[s]); &#125; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125; C:队友写的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+5;int w[maxn];//okint cntsuf[maxn];//okint len[maxn];//okint pre[maxn];//okll dp[maxn];bool vis[maxn];//okint main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n))&#123; if(n==0)break; for(int i=0;i&lt;maxn;i++)&#123; pre[i]=-1; &#125; for(int i=0;i&lt;maxn;i++)&#123; len[i]=0; &#125; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,w+i); len[i-pre[w[i]]-1]++; pre[w[i]]=i; &#125; memset(vis,0,sizeof(vis)); cntsuf[n]=0; for(int i=n-1;i&gt;=0;i--)&#123; if(!vis[w[i]])&#123; cntsuf[i]=cntsuf[i+1]+1; vis[w[i]]-=true; &#125; else cntsuf[i]=cntsuf[i+1]; &#125; int sum=0; for(int i=n-1;i&gt;=1;i--)&#123; sum=sum+len[i]; &#125; dp[1]=n; for(int i=2;i&lt;n;i++)&#123; dp[i]=dp[i-1]-cntsuf[n-i+1]+sum; sum-=len[i-1]; &#125; int q; scanf(&quot;%d&quot;,&amp;q); while(q--)&#123; int tmp; scanf(&quot;%d&quot;,&amp;tmp); printf(&quot;%lld\\n&quot;,dp[tmp]); &#125; &#125;&#125; J:观察数据大小，直接枚举子集然后验证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;vector&lt;int&gt;v;int m[55][55],d[15];int n,k,ans;struct Node&#123; int x,y;&#125;node[11];bool check(int a,int b,int i)&#123; if(a&lt;1||a&gt;n||b&lt;1||b&gt;n) return false; int dis=abs(node[v[i]].x-a)+abs(node[v[i]].y-b); if(dis&gt;d[v[i]]) return false; return true;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; if(!m[i][j]) &#123; return false; &#125; &#125; &#125; return true;&#125;void color()&#123; for(int i=0;i&lt;v.size();i++) &#123; for(int a=1;a&lt;=n;a++) &#123; for(int b=1;b&lt;=n;b++) &#123; if(check(a,b,i)) m[a][b]=1; &#125; &#125; &#125;&#125;void solve()&#123; for(int i=0; i&lt;(1&lt;&lt;k); i++) &#123; v.clear(); memset(m,0,sizeof(m)); for(int j=1;j&lt;=k;j++) m[node[j].x][node[j].y]=1; for(int j=0; j&lt;k; j++) &#123; if(i&amp;(1&lt;&lt;j)) v.push_back(j+1); &#125; color(); if(check()) ans=min(ans,(int)v.size()); &#125;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(!n) break; memset(m,0,sizeof(m)); memset(d,0,sizeof(d)); scanf(&quot;%d&quot;,&amp;k); for(int i=1; i&lt;=k; i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); m[x][y]=1; node[i].x=x, node[i].y=y; &#125; for(int i=1; i&lt;=k; i++) scanf(&quot;%d&quot;,&amp;d[i]); ans=inf; solve(); if(ans==inf) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;,ans); &#125;&#125; 未完待续。。。","path":"2019/02/05/2012-ICPC-杭州站/"},{"title":"2016 ICPC 青岛站","text":"A:暴力打表,二分查询询问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longvector&lt;ll&gt;v;ll qpow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res*=a; a=a*a; b&gt;&gt;=1; &#125; return res;&#125;void init()&#123; v.clear(); for(int i=0; i&lt;=30; i++) &#123; for(int j=0; j&lt;=30; j++) &#123; for(int k=0; k&lt;=30; k++) &#123; for(int l=0; l&lt;=30; l++) &#123; ll tem=qpow(2,i); if(tem&gt;1e9) break; tem*=qpow(3,j); if(tem&gt;1e9) break; tem*=qpow(5,k); if(tem&gt;1e9) break; tem*=qpow(7,l); if(tem&gt;1e9) break; v.push_back(tem); &#125; &#125; &#125; &#125; sort(v.begin(),v.end());&#125;int main()&#123; init(); int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,*lower_bound(v.begin(),v.end(),x)); &#125;&#125; B:$该级数收敛于 \\pi^2/6,对1000万以下的询问预处理即可。$ 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const double PI=acos(-1.0);double a[1000000+5];string str;int init(string s)&#123; int res=0,len=s.length(),w=1; for(int i=len-1;i&gt;=0;i--) &#123; res+=(s[i]-&apos;0&apos;)*w; w*=10; &#125; return res;&#125;void init()&#123; for(int i=1;i&lt;=1000000;i++) &#123; a[i]=a[i-1]+1.0/(1.0*i*i); &#125;&#125;int main()&#123; init(); while(cin&gt;&gt;str) &#123; if(str.length()&gt;=7) printf(&quot;%.5f\\n&quot;,PI*PI/6); else &#123; int value=init(str); printf(&quot;%.5f\\n&quot;,a[value]); &#125; &#125;&#125; E:$当(n * (n-1)/2) \\mod 2=0时游戏平衡 \\\\所以n是偶数游戏就平衡。$ 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); if(x&amp;1) puts(&quot;Balanced&quot;); else puts(&quot;Bad&quot;); &#125;&#125; F:$先判图是否连通。因为异或满足交换律,所以如果是欧拉通路 \\\\答案是定值,如果是欧拉回路那就枚举起点，因为起点会被多 \\\\算一次，否则答案都是NO。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int maxm=5e5+5;int t,n,m,u,v,ans;int a[maxn],deg[maxn],cnt[maxn],f[maxn];int Find(int a)&#123; return f[a]==a?a:f[a]=Find(f[a]);&#125;void join(int a,int b)&#123; int pa=Find(a),pb=Find(b); if(pa!=pb) f[pb]=pa;&#125;void init()&#123; for(int i=1; i&lt;=n; i++) &#123; f[i]=i; deg[i]=cnt[i]=0; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); ans=0; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); deg[u]++; deg[v]++; join(u,v); &#125; int _cnt=0; for(int i=1; i&lt;=n; i++) &#123; cnt[i]=(deg[i]+1)/2; if(f[i]==i) _cnt++; &#125; if(_cnt!=1) &#123; puts(&quot;Impossible&quot;); continue; &#125; _cnt=0; for(int i=1; i&lt;=n; i++) &#123; if(deg[i]&amp;1) _cnt++; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=cnt[i]; j++) ans^=a[i]; &#125; if(_cnt==2) &#123; printf(&quot;%d\\n&quot;,ans); continue; &#125; if(_cnt==0) &#123; int tem=ans; ans^=a[1]; for(int i=2; i&lt;=n; i++) ans=max(ans,tem^a[i]); printf(&quot;%d\\n&quot;,ans); continue; &#125; puts(&quot;Impossible&quot;); &#125;&#125; K:$先跑spfa抠出最短路，然后在最短路上跑最大流即可。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e3+5;const int maxm=1e4+5;const int inf=1e9;int cnt,s,t,n,m;int head[maxn],dep[maxn],cur[maxn],dis[maxn],inq[maxn];int g[maxn][maxn],e[maxn][maxn];struct Edge&#123; int nex,to,w;&#125; edge[2*maxm];void add_edge(int u,int v,int w)&#123; edge[++cnt].nex=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;void init()&#123; memset(head,-1,sizeof(head)); memset(dep,0,sizeof(dep)); memset(cur,0,sizeof(cur)); memset(inq,0,sizeof(inq)); memset(g,0,sizeof(g)); memset(e,0,sizeof(e)); cnt=-1;&#125;bool bfs()&#123; queue&lt;int&gt;que; memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if((dep[v]==0)&amp;&amp;edge[i].w&gt;0) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;(edge[i].w!=0)) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=n; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;void spfa(int s)&#123; fill(dis,dis+1+n,1e9); memset(inq,0,sizeof(inq)); queue&lt;int&gt;que; que.push(s); inq[s]=1; dis[s]=0; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=0; for(int v=1; v&lt;=n; v++) &#123; int w=g[u][v]; if(!w) continue; if(dis[v]&gt;dis[u]+w) &#123; dis[v]=dis[u]+w; if(!inq[v]) &#123; inq[v]=1; que.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; //起点是1 终点是n int time; scanf(&quot;%d&quot;,&amp;time); while(time--) &#123; init(); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); g[a][b]=1; g[b][a]=1; e[a][b]=e[b][a]=c; &#125; spfa(1); for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(dis[j]-dis[i]==1&amp;&amp;e[i][j]!=0) add_edge(i,j,e[i][j]),add_edge(j,i,0); &#125; &#125; s=1,t=n; cout&lt;&lt;Dinic()&lt;&lt;endl; &#125; return 0;&#125; D:$对R \\le 1, R \\le 2, (R-L) \\le 2,L=0分开讨论 \\\\其它情况都有一种最优策略。$ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; ll l,r; while(~scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r)) &#123; if(r&lt;=1) &#123; puts(&quot;0&quot;); continue; &#125; if(r&lt;=2) &#123; puts(&quot;1&quot;); continue; &#125; if(r-l&lt;=2) &#123; puts(&quot;2&quot;); continue; &#125; if(l==0) &#123; ll ans=(r-3)/2+2; printf(&quot;%lld\\n&quot;,ans); continue; &#125; else &#123; ll ans=2; if((r-l-2)&amp;1) ans+=(r-l-3)/2; else ans+=(r-l-2)/2; printf(&quot;%lld\\n&quot;,ans); &#125; &#125;&#125; L:$二分+优先队列的做法会被卡常,做些预处理可以水过， \\\\正解是利用单调性模拟优先队列优化掉一个log。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;#define ll long longint n;ll cost;ll num[maxn];ll pre[maxn];bool check(int x)&#123; priority_queue&lt; ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;q; ll ans=0,sum=0; ll d=(n-1)%(x-1)+1; if(d&gt;1) &#123; ans=pre[d]; q.push(pre[d]); for(int i=d+1; i&lt;=n; i++) q.push(num[i]); &#125; else &#123; for(int i=1; i&lt;=n; i++) q.push(num[i]); &#125; while(!q.empty()) &#123; sum=0; for(int i=1; i&lt;=x; i++) &#123; sum+=q.top(); q.pop(); &#125; ans+=sum; if(ans&gt;cost) return false; if(!q.empty()) q.push(sum); &#125; if(ans&lt;=cost) return true; else return false;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%lld&quot;,&amp;n,&amp;cost); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%lld&quot;,&amp;num[i]); &#125; sort(num+1,num+1+n); pre[1]=num[1]; for(int i=2; i&lt;=n; i++) pre[i]=pre[i-1]+num[i]; int l=2,r=n; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) r=mid; else l=mid+1; &#125; printf(&quot;%d\\n&quot;,l); &#125;&#125; L:$本质不同的排列远小于询问数量，所以先预处理，预处理时用 \\\\bitset加速01背包。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint num[60];int ans[55][55][55];int tem[5];int t,n,q;bitset&lt;90&gt;b[15];void read(ll&amp; x)&#123; int f = 1; x = 0; char ch = getchar(); while (ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123; if (ch == &apos;-&apos;) f = -1; ch = getchar(); &#125; while (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) &#123; x = x * 10 + ch - &apos;0&apos;; ch = getchar(); &#125; x *= f;&#125;void read(int&amp; x)&#123; int f = 1; x = 0; char ch = getchar(); while (ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123; if (ch == &apos;-&apos;) f = -1; ch = getchar(); &#125; while (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) &#123; x = x * 10 + ch - &apos;0&apos;; ch = getchar(); &#125; x *= f;&#125;///--------------head--------------------///inline void solve(int x,int y,int z)&#123; for(int i=0; i&lt;=11; i++) b[i].reset(); b[0][0]=1; for(int i=1; i&lt;=n; i++) &#123; if(num[i]&gt;87||i==x||i==y||i==z) continue; for(int j=10; j&gt;=1; j--) b[j]|=b[j-1]&lt;&lt;num[i]; &#125; if(b[10][87]==1) ans[x][y][z]=1;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(ans,0,sizeof(ans)); read(n); for(int i=1; i&lt;=n; i++) read(num[i]); for(int i=1; i&lt;=n; i++) for(int j=i; j&lt;=n; j++) for(int k=j; k&lt;=n; k++) &#123; solve(i,j,k); &#125; read(q); while(q--) &#123; read(tem[1]),read(tem[2]),read(tem[3]); sort(tem+1,tem+4); if(ans[tem[1]][tem[2]][tem[3]]) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125;&#125;","path":"2019/02/05/2016-ICPC-青岛站/"},{"title":"Bzoj 1026 windy数","text":"描述:求区间里满足相邻数位差值的绝对值不小于2的数的个数。 思路:$数位dp,对有无前导0分情况讨论。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/************************************************************** Problem: 1026 User: Decaku Language: C++ Result: Accepted Time:48 ms Memory:1288 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;int dp[15][15];void init()&#123; for(int i=0; i&lt;=9; i++) dp[1][i]=1; for(int i=2; i&lt;=10; i++) for(int j=0; j&lt;=9; j++) for(int k=0; k&lt;=9; k++) &#123; if(abs(j-k)&gt;=2) dp[i][j]+=dp[i-1][k]; &#125;&#125; int query(int x)&#123; int d[15]= &#123;&#125;,cnt=0,ret=0; while(x) &#123; d[++cnt]=x%10; x/=10; &#125; for(int i=1; i&lt;cnt; i++) for(int j=1; j&lt;10; j++) ret+=dp[i][j]; for(int i=1; i&lt;d[cnt]; i++) ret+=dp[cnt][i]; for(int i=cnt-1; i&gt;=1; i--) &#123; for(int j=0; j&lt;d[i]; j++) &#123; if(abs(j-d[i+1])&gt;=2) ret+=dp[i][j]; &#125; if(abs(d[i]-d[i+1])&lt;2) break; &#125; return ret;&#125; int main()&#123; init(); int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,query(b+1)-query(a));&#125;","path":"2019/02/05/Bzoj-1026-windy数/"},{"title":"Edu Codeforces Round 53","text":"A:扫描长度为2的字符串就好。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int a[30];int main()&#123; bool flag=true; int n; string str; cin&gt;&gt;n; cin&gt;&gt;str; for(int i=0;i&lt;n-1;i++) &#123; if(str[i]!=str[i+1]) &#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; cout&lt;&lt;str[i]&lt;&lt;str[i+1]&lt;&lt;endl; flag=false; break; &#125; &#125; if(flag) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; B:用栈模拟。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int a[30];int main()&#123; bool flag=true; int n; string str; cin&gt;&gt;n; cin&gt;&gt;str; for(int i=0;i&lt;n-1;i++) &#123; if(str[i]!=str[i+1]) &#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; cout&lt;&lt;str[i]&lt;&lt;str[i+1]&lt;&lt;endl; flag=false; break; &#125; &#125; if(flag) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; C:$先记录两个数组a,b,a_i表示从起点开始i条指令能到达的位置,b_i \\\\记录从终点开始对i条指令反向后能够到达的位置。二分修改 \\\\区间的长度,所以区间左端点扫描,对区间右端点二分,check的时 \\\\候只要根据区间长度是否比区间首尾的曼哈顿距离大且差值是偶 \\\\数来二分即可,复杂度是nlog(n)。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 200005char str[maxn];struct Point&#123; int x,y;&#125; s[maxn],e[maxn];int main()&#123; int n,x,y; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,str); scanf(&quot;%d %d&quot;,&amp;x,&amp;y); if((abs(x)+abs(y))&gt;n||(n-abs(x)-abs(y))%2!=0) printf(&quot;%d\\n&quot;,-1); else &#123; int s_x=0,s_y=0; s[0].x=0,s[0].y=0; for(int i=0; i&lt;n; i++) &#123; if(str[i]==&apos;U&apos;) s_y++, s[i+1].x=s_x, s[i+1].y=s_y; if(str[i]==&apos;D&apos;) s_y--, s[i+1].x=s_x, s[i+1].y=s_y; if(str[i]==&apos;L&apos;) s_x--, s[i+1].x=s_x, s[i+1].y=s_y; if(str[i]==&apos;R&apos;) s_x++, s[i+1].x=s_x, s[i+1].y=s_y; &#125; if(s[n].x==x&amp;&amp;s[n].y==y) printf(&quot;0\\n&quot;); else &#123; s_x=x,s_y=y; e[0].x=x,e[0].y=y; int cnt=0; for(int i=n-1; i&gt;=0; i--) &#123; if(str[i]==&apos;U&apos;) s_y--, e[++cnt].x=s_x, e[cnt].y=s_y; if(str[i]==&apos;D&apos;) s_y++, e[++cnt].x=s_x, e[cnt].y=s_y; if(str[i]==&apos;L&apos;) s_x++, e[++cnt].x=s_x, e[cnt].y=s_y; if(str[i]==&apos;R&apos;) s_x--, e[++cnt].x=s_x, e[cnt].y=s_y; &#125; int ans=1e9; for(int i=1; i&lt;=n; i++) &#123; int l=i,r=n,mid; while(l&lt;r) &#123; int mid=(l+r)/2; int p_x=s[i-1].x,p_y=s[i-1].y; int q_x=e[n-mid].x,q_y=e[n-mid].y; int dis=abs(p_x-q_x)+abs(p_y-q_y); if(mid-i+1&gt;=dis&amp;&amp;(mid-i+1-dis)%2==0) r=mid; else l=mid+1; &#125; int p_x=s[i-1].x,p_y=s[i-1].y; int q_x=e[n-l].x,q_y=e[n-l].y; int dis=abs(p_x-q_x)+abs(p_y-q_y); if(l-i+1&gt;=dis&amp;&amp;(l-i+1-dis)%2==0) ans=min(ans,l-i+1); &#125; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125; D:经过一次循环以后可以取模,所以可以暴力莽过去。 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=2e5+5;ll n,t,ans,sum,_;int a[maxn];int main()&#123; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;t); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); while(1) &#123; ll tem=t,cnt=0,sum=0; for(int i=1;i&lt;=n;i++) &#123; if(tem&gt;=a[i]) &#123; cnt++; tem-=a[i]; sum+=a[i]; &#125; &#125; if(cnt==0) break; ans+=t/sum*cnt; t%=sum; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; 未完待续。。。","path":"2019/02/05/Edu-Codeforces-Round-53/"},{"title":"Codeforces Round #519 Div2","text":"A:签到题。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int sum,n,tem,mx;int main()&#123; scanf(&quot;%d&quot;,&amp;n); mx=-1; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;tem); mx=max(tem,mx); sum+=tem; &#125; int ans=max((2*sum)/n+1,mx); printf(&quot;%d\\n&quot;,ans);&#125; B:差分数组后就是求字符串可能的循环节长度，暴力。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[1005],b[1005],ans[1005],_ans;int main()&#123; scanf(&quot;%d&quot;,&amp;n); a[0]=0; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) b[i]=a[i]-a[i-1]; for(int i=1;i&lt;=n;i++) &#123; bool ok=true; for(int j=i+1;j&lt;=n;j+=i) &#123; for(int k=j;k&lt;=j+i-1&amp;&amp;k&lt;=n;k++) &#123; if(b[k]!=b[k-i]) &#123; ok=false; break; &#125; &#125; if(!ok) break; &#125; if(ok) ans[++_ans]=i; &#125; printf(&quot;%d\\n&quot;,_ans); for(int i=1;i&lt;=_ans;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;\\n&quot;);&#125; C:$操作完了以后一定可以让所有a在b的前面,所以假设 \\\\前i长的字符串已经是最小字典序了,那么如果第i+1个 \\\\字符是a,前i个字符就要倒过来,再反转前i+1个字符. \\\\$ 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int ans[1005];int main()&#123; string str; cin&gt;&gt;str; for(int i=1;i&lt;str.size();i++) &#123; if(str[i]==&apos;a&apos;) ans[i-1]^=1, ans[i]^=1; &#125; for(int i=0;i&lt;str.size()-1;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;%d\\n&quot;,ans[str.size()-1]);&#125; D:$预处理一个a数组,a_i=j代表在所有字符串中i的后一个字符 \\\\都是j,然后根据a数组建一棵树,在树上统计每一条链上的结点 \\\\个数就行。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int a[maxn],head[maxn],vis[maxn];int n,m,tem,pre,cnt;struct Edge&#123; int to,nex;&#125; edge[2*maxn];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt; edge[++cnt].to=u; edge[cnt].nex=head[v]; head[v]=cnt;&#125;int dfs(int u)&#123; vis[u]=1; int ret=0; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(vis[v]) continue; ret+=dfs(v)+1; &#125; return ret;&#125;int main()&#123; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d&quot;,&amp;pre); for(int j=2; j&lt;=n; j++) &#123; scanf(&quot;%d&quot;,&amp;tem); if(a[pre]==0) a[pre]=tem; else if(a[pre]!=tem) a[pre]=-1; pre=tem; &#125; a[pre]=-1; &#125; for(int i=1; i&lt;=n; i++) &#123; if(a[i]!=-1) add_edge(i,a[i]); &#125; long long ans=0; for(int i=1; i&lt;=n; i++) &#123; if(!vis[i]) &#123; int tem =dfs(i)+1+1; ans+=1ll*tem*(tem-1)/2; &#125; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; 未完待续。。。","path":"2019/02/05/Codeforces Round 519/"},{"title":"Bzoj 1257 余数之和","text":"描述:$求\\sum _{i=1}^nk \\mod i, i \\le n,k \\le (10)^9$ 思路:$原式=\\sum _{i=1}^n(k-k/i * i)=n * k-\\sum _{i=1}^n(k/i*i) \\\\k/i只有 \\sqrt k个，所以可以整除分块。 \\\\复杂度是 \\sqrt n。$ 12345678910111213141516171819202122232425262728/************************************************************** Problem: 1257 User: Decaku Language: C++ Result: Accepted Time:72 ms Memory:1288 kb****************************************************************/ #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n,k,sum;int main()&#123; ll ans=0; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;k); sum=n*k; if(n&gt;k) n=k; for(ll l=1,r; l&lt;=n; l=r+1) &#123; r=k/(k/l); if(r&gt;n) r=n; ll tem=r*(r+1)/2-(l-1)*l/2; ans+=tem*(k/l); &#125; printf(&quot;%lld\\n&quot;,sum-ans);&#125;","path":"2019/02/05/Bzoj-1257-余数之和/"},{"title":"Poj2796 Feel Good","text":"描述:$一串数字序列,定义value为某一区间的最小值乘该区间的和, \\\\再除以区间长度,求最大的value。 $ 思路:$预处理a_i为最小值时的区间,使用单调栈从前向后和 \\\\从后向前扫描两次。 $ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;using namespace std;#define ll long long#define maxn 100005ll st[maxn],top;ll a[maxn],sum[maxn],l[maxn],r[maxn];int main()&#123; top=0; int n; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%lld&quot;,&amp;a[1]); sum[0]=0; sum[1]=a[1]; for(int i=2; i&lt;=n; i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); sum[i]=sum[i-1]+a[i]; &#125; st[top++]=1; l[1]=1; for(int i=2; i&lt;=n; i++) &#123; while(top&amp;&amp;a[st[top-1]]&gt;=a[i]) &#123; top--; &#125; if(!top) l[i]=1; else l[i]=st[top-1]+1; st[top++]=i; &#125; top=0; st[top++]=n; r[n]=n; for(int i=n-1; i&gt;=1; i--) &#123; while(top&amp;&amp;a[st[top-1]]&gt;=a[i]) &#123; top--; &#125; if(!top) r[i]=n; else r[i]=st[top-1]-1; st[top++]=i; &#125; ll ans=-1; ll _l,_r; for(int i=1; i&lt;=n; i++) &#123; if((a[i])*(sum[r[i]]-sum[l[i]-1])&gt;ans) &#123; ans=(a[i])*(sum[r[i]]-sum[l[i]-1]); _l=l[i]; _r=r[i]; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); printf(&quot;%lld %lld\\n&quot;,_l,_r);&#125;","path":"2019/02/05/Poj2796-Feel-Good/"},{"title":"Poj4045 Power Station","text":"描述:找到树上一个结点,树上其它结点与它距离之和最小。 思路:$枚举每一条树边,儿子的值可以由父亲转移过来, \\\\统计完所有结点以后比较即可。所以需要做两遍dfs, \\\\第一遍统计每个结点子树的数量和根节点的值。 \\\\第二遍dfs更新其它结点的值。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e4+5;const int inf=1e9;vector&lt;int&gt;ans;struct Edge&#123; int to,nex;&#125; edge[maxn*2];int head[maxn],cnt,siz[maxn],dis[maxn],tem;int n,I,R;void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs1(int u,int f,int dep)&#123; siz[u]=1; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==f) continue; tem+=dep; dfs1(v,u,dep+1); siz[u]+=siz[v]; &#125;&#125;void dfs2(int u,int f)&#123; if(u!=1) dis[u]=dis[f]-siz[u]+n-siz[u]; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==f) continue; dfs2(v,u); &#125;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ans.clear(); memset(head,-1,sizeof(head)); cnt=-1; tem=0; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;I,&amp;R); for(int i=1; i&lt;n; i++) &#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); &#125; dfs1(1,0,1); dis[1]=tem; dfs2(1,0); int mi=inf; for(int i=1; i&lt;=n; i++) &#123; if(dis[i]&lt;mi) &#123; mi=dis[i]; ans.clear(); ans.push_back(i); &#125; else if(dis[i]==mi) ans.push_back(i); &#125; printf(&quot;%lld\\n&quot;,1ll*mi*I*I*R); printf(&quot;%d&quot;,ans[0]); for(int i=1; i&lt;ans.size(); i++) printf(&quot; %d&quot;,ans[i]); printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); &#125;&#125;","path":"2019/02/05/Poj4045-Power-Station/"},{"title":"Hdu1520 Anniversary party","text":"描述:从树上选择一些结点,使被选择的结点的权值和最大,儿子与父亲结点最多选一个。 思路:$设dp[0][i],表示以i为根节点,且i结点不选能取得的最大值, \\\\dp[1][i]表示以i为根节点且i结点选择的最大值,答案为 \\\\max\\{dp[0][1],dp[1][1]\\}。 \\\\转移方程是 dp[0][u]=dp[0][u]+max\\{dp[1][v],dp[0][v]\\}; \\\\dp[1][u]+=dp[0][v]; 其中v是u的儿子。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=6000+10;int head[maxn],cnt,value[maxn];int dp[2][maxn];struct Edge&#123; int to,nex;&#125; edge[maxn*2];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int f)&#123; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==f) continue; dfs(v,u); dp[0][u]=dp[0][u]+max(dp[1][v],dp[0][v]); dp[1][u]+=dp[0][v]; &#125;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; memset(head,-1,sizeof(head)); cnt=-1; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;value[i]); int u,v; while(~scanf(&quot;%d %d&quot;,&amp;u,&amp;v)) &#123; if(!u&amp;&amp;!v) break; add_edge(u,v); add_edge(v,u); &#125; memset(dp[0],0,sizeof(dp[0])); for(int i=1; i&lt;=n; i++) dp[1][i]=value[i]; dfs(1,0); printf(&quot;%d\\n&quot;,max(dp[0][1],dp[1][1])); &#125;&#125;","path":"2019/02/05/Hdu1520-Anniversary-party/"},{"title":"Codeforces Round #514 (Div. 2)","text":"A:$模拟时特判一下n为0即可$ 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n,l,a,ans;int main()&#123; ans=0; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;l,&amp;a); if(n==0) ans=l/a; else &#123; int s,t,_; scanf(&quot;%d %d&quot;,&amp;s,&amp;t); ans+=s/a; _=s+t; for(int i=2; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;s,&amp;t); ans+=(s-_)/a; _=s+t; &#125; ans+=(l-_)/a; &#125; printf(&quot;%d\\n&quot;,ans);&#125; B:对地图染色以后暴力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;char mp[1005][1005];bool vis[1005][1005];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof(vis)); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=m; j++) cin&gt;&gt;mp[i][j]; for(int i=2; i&lt;=n-1; i++) for(int j=2; j&lt;=m-1; j++) &#123; if(mp[i-1][j-1]==&apos;.&apos;||mp[i-1][j]==&apos;.&apos;||mp[i-1][j+1]==&apos;.&apos;||mp[i][j-1]==&apos;.&apos;||mp[i][j+1]==&apos;.&apos; ||mp[i+1][j-1]==&apos;.&apos;||mp[i+1][j]==&apos;.&apos;||mp[i+1][j+1]==&apos;.&apos;) continue; else &#123; vis[i-1][j-1]=1; vis[i-1][j]=1; vis[i-1][j+1]=1; vis[i][j-1]=1; vis[i][j+1]=1; vis[i+1][j-1]=1; vis[i+1][j]=1; vis[i+1][j+1]=1; &#125; &#125; bool ans=true; for(int i=1; i&lt;=n; i++) &#123; if(ans==false) break; for(int j=1; j&lt;=m; j++) &#123; if((mp[i][j]==&apos;#&apos;&amp;&amp;!vis[i][j])||(mp[i][j]==&apos;.&apos;&amp;&amp;vis[i][j])) &#123; ans=false; break; &#125; &#125; &#125; if(ans) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0;&#125; C:$采取贪心策略尽早使gcd比1大,又相邻的奇数和偶数 \\\\一定互素,所以先删奇数，剩下偶数不断除2变成奇数 \\\\删掉，递归即可$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int ans[maxn],ans_;int seq[maxn];void solve(int n,int t)&#123; if(n==1) &#123; ans[ans_++]=t; return; &#125; if(n==2) &#123; ans[ans_++]=t; ans[ans_++]=t*2; return; &#125; if(n==3) &#123; ans[ans_++]=t; ans[ans_++]=t; ans[ans_++]=3*t; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if(seq[i]&amp;1) ans[ans_++]=t; &#125; for(int i=1;i&lt;=n/2;i++) &#123; seq[i]=seq[i*2]/2; &#125; solve(n/2,t*2);&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) seq[i]=i; solve(n,1); for(int i=0;i&lt;ans_-1;i++) printf(&quot;%d &quot;,ans[i]); printf(&quot;%d\\n&quot;,ans[ans_-1]);&#125; 未完待续。。。","path":"2019/02/05/Codeforces-Round-514-Div-2/"},{"title":"Codeforces Round #513 Div1+Div2","text":"A:签到题。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;string str;int main()&#123; int n; cin&gt;&gt;n; cin&gt;&gt;str; int cnt=0; for(int i=0;i&lt;n;i++) &#123; if(str[i]==&apos;8&apos;) cnt++; &#125; cnt=min(cnt,n/11); cout&lt;&lt;cnt&lt;&lt;endl;&#125; B:$ 考虑从n的最低位开始更新答案，如果最低位小于等于8, \\\\就从下一位拿1过来，ans+10。$ 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll solve(ll n)&#123; ll ans=0; while(n)&#123; int d=n%10; n/=10; if(d&lt;=8&amp;&amp;n)&#123; d=10; n--; &#125; ans+=d; &#125; return ans;&#125;int main()&#123; ll n; while(cin&gt;&gt;n)&#123; cout&lt;&lt;solve(n)&lt;&lt;endl; &#125;&#125; C:$ C矩阵的每一个子矩阵的和都是数组A和B的一个连续子段和相乘所得。 \\\\所以可以考虑预处理A和B的所有连续子段和，然后把B的子段和按从小 \\\\到大排序，每次枚举A的一个子段和a,可以在B的子段和里二分找x/a。 \\\\然后就是询问子段和在0-x/a里最长的一段是多少，这个询问可以预处 \\\\理，询问的时候是O(1)。所以总的复杂度是O(n^2log(n))。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2005;int a[maxn],b[maxn];int n,m,cnta,cntb;int suma[maxn],sumb[maxn];struct node&#123; int len,w; bool operator &lt;(const node&amp;other)const&#123; return w&lt;other.w; &#125;;&#125;nodea[maxn*(maxn+1)/2],nodeb[maxn*(maxn+1)/2];int lenb[maxn*(maxn+1)/2];inline void ini()&#123; for(int i=1;i&lt;=n;i++)suma[i]=suma[i-1]+a[i]; for(int i=1;i&lt;=m;i++)sumb[i]=sumb[i-1]+b[i]; cnta=cntb=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=i;j&lt;=n;j++)&#123; nodea[cnta].len=j-i+1; nodea[cnta].w=suma[j]-suma[i-1]; cnta++; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=i;j&lt;=m;j++)&#123; nodeb[cntb].len=j-i+1; nodeb[cntb].w=sumb[j]-sumb[i-1]; cntb++; &#125; &#125; sort(nodeb,nodeb+cntb); for(int i=0;i&lt;cntb;i++)lenb[i]=max(lenb[i-1],nodeb[i].len); &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=m;i++)scanf(&quot;%d&quot;,b+i); int x;cin&gt;&gt;x; ini(); int ans=0; for(int i=0;i&lt;cnta;i++)&#123; int t=upper_bound(nodeb,nodeb+cntb,node&#123;0,x/nodea[i].w&#125;)-1-nodeb; ans=max(ans,lenb[t]*nodea[i].len); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 未完待续。。。","path":"2019/02/05/Codeforces-Round-513-Div1-Div2/"},{"title":"Codeforces #512 div2","text":"A:签到题。 B:判断点是否在矩形内,利用外积即可。 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int n,d,m;int main()&#123; cin&gt;&gt;n&gt;&gt;d; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; int _1=(n-d)*(y-d)-(n-d)*x; int _2=(d-n)*(y-n+d)-(d-n)*(x-n); int _3=(-d)*y-d*(x-d); int _4=d*(y-n)-(-d)*(x-n+d); if(_1*_2&gt;=0&amp;&amp;_3*_4&gt;=0) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;&#125; C:暴力。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n;string a;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;a; int sum=0; string str=&quot;&quot;; for(int i=0; i&lt;n; i++) &#123; if(a[i]!=&apos;0&apos;) str+=a[i]; sum+=a[i]-&apos;0&apos;; &#125; bool ok=true; bool flag=false; for(int i=1; i&lt;=sum; i++) &#123; int tem=0; int cnt=0; ok=true; for(int j=0; j&lt;str.length(); j++) &#123; tem+=str[j]-&apos;0&apos;; if(tem&gt;i) &#123; ok=false; break; &#125; if(tem==i) &#123; tem=0; cnt++; if(j==str.length()-1) flag=true; continue; &#125; &#125; if(ok&amp;&amp;cnt&gt;1&amp;&amp;flag) &#123; break; &#125; if(!flag) ok=false; if(cnt==1) ok=false; &#125; if(ok) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; D:$由皮克定理可知，该三角形底乘高为整数 \\\\则有2m/k \\le b \\le m \\\\2n/k \\le a \\le n \\\\观察2n/k，因为k \\ge 2,令t=gcd(2n,k) \\\\若t \\ge 2,令a=2n/t,若t=1,令a=n。 $ 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;long long n,m,k;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; if(2*n*m%k!=0) &#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; &#125; int t=__gcd(2*n,k); int a=2*n/t; int b=m*t/k; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; if(t!=1) &#123; cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;2*m/k&lt;&lt;endl; &#125; return 0;&#125; 未完待续。。。","path":"2019/02/05/Codeforces-512-div2/"},{"title":"Codeforces Round＃498 E","text":"描述:$给出一个有根树，多组询问，求编号为u的结点的dfs序的第k个儿子。$ 思路:$dfs预处理树上一些信息乱搞就行了。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 2e5+10;queue&lt;int&gt;que[maxn];int a[maxn],b[maxn],sum[maxn];////a存dfs序号,b存序号对应的结点编号int cnt1=1;void dfs(int k)&#123; int cnt2=0; while(que[k].empty()==false) &#123; int t=que[k].front(); cnt2++; que[k].pop(); cnt1++; a[t]=cnt1; b[cnt1]=t; dfs(t); cnt2+=sum[t]; &#125; sum[k]+=cnt2; return;&#125;int main()&#123; memset(sum,0,sizeof(sum)); int n,q,tem,x,y; cin&gt;&gt;n&gt;&gt;q; for(int i=1; i&lt;n; i++) &#123; cin&gt;&gt;tem; que[tem].push(i+1); &#125; dfs(1); a[1]=1; b[1]=1; while(q--) &#123; cin&gt;&gt;x&gt;&gt;y; if(sum[x]+1&lt;y) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;b[a[x]+y-1]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/05/Codeforces-Round＃498（Div-3）E/"},{"title":"Codeforces #511 div2 D. Bicolorings","text":"描述:$ 有个2行n列的格子图,用2种颜色给格子涂色,相邻格子颜色 \\\\不能相同,求不同的染色方案数。$ 思路:$类似状压dp的思路，只有两行，所以每一列只有4个状态, \\\\所以可以考虑枚举每一列，这样复杂度是O(n^4)，n只有1000, \\\\题目又要求把方格分成k个连通块，我们在dp中再加一维即可, \\\\k最大是2n的，所以最多做8 * (10)^6次循环。$ 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=998244353;long long dp[5][1100][2100];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; memset(dp,0,sizeof(dp)); dp[0][1][1]=1; dp[1][1][1]=0; dp[2][1][1]=0; dp[3][1][1]=1; dp[0][1][2]=0; dp[1][1][2]=1; dp[2][1][2]=1; dp[3][1][2]=0; for(int j=2; j&lt;=n; j++) for(int i=0; i&lt;=3; i++) for(int t=1; t&lt;=k; t++) &#123; if(i==0) dp[i][j][t]=(dp[0][j-1][t]+dp[1][j-1][t]+dp[2][j-1][t]+dp[3][j-1][t-1])%mod; else if(i==1) dp[i][j][t]=(dp[0][j-1][t-1]+dp[1][j-1][t]+dp[2][j-1][t-2]+dp[3][j-1][t-1])%mod; else if(i==2) dp[i][j][t]=(dp[0][j-1][t-1]+dp[1][j-1][t-2]+dp[2][j-1][t]+dp[3][j-1][t-1])%mod; else dp[i][j][t]=(dp[0][j-1][t-1]+dp[1][j-1][t]+dp[2][j-1][t]+dp[3][j-1][t])%mod; &#125; cout&lt;&lt;(dp[0][n][k]+dp[1][n][k]+dp[2][n][k]+dp[3][n][k])%mod&lt;&lt;endl;&#125;","path":"2019/02/05/Codeforces-511-div2-D-Bicolorings/"},{"title":"Hdu1005 Number Sequence","text":"描述:$ f(1)=1, f(2)=1, f(n) = (A * f(n - 1) + B * f(n - 2)) \\mod 7. \\\\然后计算f(n),n很大。$ 找循环节，循环节长度最大是49，但是发现前几项可能不出现在循环节里，所以舍弃前50项即可。 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int x,y,n,tem;int ans[100];int main()&#123; while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;n&amp;&amp;(x+y+n)) &#123; ans[1]=ans[2]=1; for(int i=3; i&lt;=100; i++) ans[i]=(ans[i-1]*x+ans[i-2]*y)%7; int a=ans[50]; int b=ans[51]; for(int i=52; i&lt;=99; i++) if(ans[i]==a&amp;&amp;ans[i+1]==b) &#123; tem=i; break; &#125; if(n&lt;50) cout&lt;&lt;ans[n]&lt;&lt;endl; else cout&lt;&lt;ans[(n-49)%(tem-50)+49]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/05/Hdu1005-Number-Sequence/"},{"title":"Hdu 6440 Dream","text":"描述:$重新定义加法和乘法，使得对于p是素数时(a+b)^{p}=a^{p}+b^{p}。$ 思路:$根据费马小定理有x^{p-1}与1在模p的意义下同余(p是素数)。 \\\\ 于是做如下定义：a+b=(a+b) \\mod p \\\\ ab=ab \\mod p \\\\ 易证 (a+b)^{p}=a^{p}+b^{p}=(a+b) \\mod p $ 12345678910111213141516171819202122232425262728293031323334include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;queue&gt;using namespace std;int t,p;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;p); for(int i=1; i&lt;=p; i++) &#123; for(int j=1; j&lt;=p; j++) &#123; printf(&quot;%d &quot;,((i-1)%p+(j-1)%p)%p); &#125; printf(&quot;\\n&quot;); &#125; for(int i=1; i&lt;=p; i++) &#123; for(int j=1; j&lt;=p; j++) &#123; printf(&quot;%d &quot;,((i-1)%p*(j-1)%p)%p); &#125; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125;","path":"2019/02/04/Hdu-6440-Dream/"},{"title":"2018Hdu暑期多校3 L Visual Cube","text":"描述:打印一个长方体。 思路:有意思的模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;char m[85][85];int main()&#123; int t,a,b,c,tem; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); int A=2*a+1+2*b; int B=2*b+2*c+1; for(int i=1; i&lt;=2*b; i++) for(int j=1; j&lt;=2*b-i+1; j++) m[i][j]=&apos;.&apos;; int k=A; for(int i=2*c+2; i&lt;=B; i++) &#123; for(int j=k; j&lt;=A; j++) &#123; m[i][j]=&apos;.&apos;; &#125; k--; &#125; for(int i=2*b+1; i&lt;=B; i+=2) for(int j=1; j&lt;=2*a+1; j++) &#123; if(j%2==1) m[i][j]=&apos;+&apos;; else m[i][j]=&apos;-&apos;; &#125; for(int i=2*b+2; i&lt;=B-1; i+=2) for(int j=1; j&lt;=2*a+1; j++) &#123; if(j%2==1) m[i][j]=&apos;|&apos;; else m[i][j]=&apos;.&apos;; &#125; for(int i=1; i&lt;=2*b; i++) for(int j=2*b-i+2; j&lt;=2*b-i+2+2*a+1; j++) &#123; if(i%2==1&amp;&amp;j%2==1) m[i][j]=&apos;+&apos;; else if(i%2==1&amp;&amp;j%2==0) m[i][j]=&apos;-&apos;; else if(i%2==0&amp;&amp;j%2==1) m[i][j]=&apos;.&apos;; else m[i][j]=&apos;/&apos;; &#125; tem=B; for(int i=2*a+1; i&lt;=A; i++) &#123; for(int j=2*b+1+tem-B; j&lt;=tem; j++) &#123; if(i%2==1&amp;&amp;j%2==1) m[j][i]=&apos;+&apos;; else if(i%2==1&amp;&amp;j%2==0) m[j][i]=&apos;|&apos;; else if(i%2==0&amp;&amp;j%2==0)m[j][i]=&apos;/&apos;; else m[j][i]=&apos;.&apos;; &#125; tem--; &#125; for(int i=1; i&lt;=B; i++) &#123; for(int j=1; j&lt;=A; j++) &#123; cout&lt;&lt;m[i][j]; &#125; cout&lt;&lt;endl; &#125; &#125;&#125;","path":"2019/02/04/2018Hdu暑期多校3-L-Visual-Cube/"},{"title":"Poj1679 The Unique MST","text":"描述:判断最小生成树是否唯一。 思路:求次小生成树和最小生成树比较。 对边按照边权排序，边权相同按照边的序号升序排列，然后求最小生成树的边的集合。之后在边权相同时按照边的序号降序排列，又可以得到一组生成树中边的序号集合。如果集合不同说明生成树不唯一。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define M 107#define inf 0x3f3f3fusing namespace std;int g[M][M],path[M][M];int dist[M],pre[M],vis[M];bool used[M][M];int n,m,mst;void init()&#123; for(int i=0; i&lt;=n; i++) for(int j=i+1; j&lt;=n; j++) g[i][j]=g[j][i]=inf;&#125;int prime()&#123; int mst=0; memset(path,0,sizeof(path)); memset(vis,0,sizeof(vis)); memset(used,0,sizeof(used)); vis[1]=1; for(int i=1; i&lt;=n; i++) &#123; dist[i]=g[1][i]; pre[i]=1; &#125; for(int i=1; i&lt;n; i++) &#123; int u=-1; for(int j=1; j&lt;=n; j++) &#123; if(!vis[j]) if(u==-1||dist[j]&lt;dist[u]) u=j; &#125; used[u][pre[u]]=used[pre[u]][u]=true; mst+=g[pre[u]][u]; vis[u]=1; for(int j=1; j&lt;=n; j++) &#123; if(vis[j]&amp;&amp;j!=u) path[j][u]=path[u][j]=max(path[j][pre[u]],dist[u]); if(!vis[j]) if(dist[j]&gt;g[u][j]) &#123; dist[j]=g[u][j]; pre[j]=u; &#125; &#125; &#125; return mst;&#125;int second_tree()&#123; int res=inf; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) if(i!=j&amp;&amp;!used[i][j]) res=min(res,mst-path[i][j]+g[i][j]); return res;&#125;int main()&#123; int t,a,b,c; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); init(); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); g[a][b]=g[b][a]=c; &#125; mst=prime(); int second_mst=second_tree(); if(mst!=second_mst) cout&lt;&lt;mst&lt;&lt;endl; else cout&lt;&lt;&quot;Not Unique!&quot;&lt;&lt;endl; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int ans;const int N=10000+1;struct edge&#123;int u,v,w,id;&#125;g[N];int f[N];//记得初始化int find(int a) &#123; return a == f[a]?a:f[a] = find(f[a]);&#125; //对边集排序后，对所有边调用join函数就可以得到最小生成树bool join(const edge &amp;e)&#123; if(find(e.u) !=find(e.v))&#123; f[find(e.u)] = find(e.v); ans+=e.w; return true;//ans =max(ans,e.w)，cnt++; &#125; return false;&#125;bool cmp1(edge a,edge b)&#123; if(a.w!=b.w)return a.w&lt;b.w; else return a.id&lt;b.id;&#125;bool cmp2(edge a,edge b)&#123; if(a.w!=b.w)return a.w&lt;b.w; else return a.id&gt;b.id;&#125;int main()&#123; int t; while(cin&gt;&gt;t)while(t--)&#123; int n,m,u,v,w; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;g[i].u&gt;&gt;g[i].v&gt;&gt;g[i].w; g[i].id=i; &#125; string state1,state2; ans=0; sort(g,g+n,cmp1); for(int i=0;i&lt;=n;i++)f[i]=i; for(int i=0;i&lt;m;i++)if(join(g[i]))state1.push_back(g[i].id); ans=0; sort(g,g+n,cmp2); for(int i=0;i&lt;=n;i++)f[i]=i; for(int i=0;i&lt;m;i++)if(join(g[i]))state2.push_back(g[i].id); if(state1!=state2)cout&lt;&lt;&quot;Not Unique!&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Poj1679-The-Unique-MST/"},{"title":"Poj 2299","text":"描述:求一段序列的逆序数对的个数。 思路:和归并排序思路类似,使用树状数组时注意稳定排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=5e5+5;typedef long long ll;int a[maxn];int c[maxn];ll ans;inline void solve(int l,int r)&#123; if(l==r) return; int mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid+1,r); int i=l,j=mid+1,k=l; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; if(a[i]&lt;=a[j]) c[k++]=a[i++]; else c[k++]=a[j++],ans+=mid-i+1; &#125; while(i&lt;=mid) c[k++]=a[i++]; while(j&lt;=r) c[k++]=a[j++]; for(int i=l; i&lt;=r; i++) a[i]=c[i];&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n&gt;0) &#123; ans=0; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); solve(1,n); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/Poj-2299/"},{"title":"Zoj3261 Connections in Galaxy War","text":"描述:$给n个点和m个边，点带权。然后给若干个操作，操作一是删边, \\\\操作二是询问这个点所在连通分量的代表点的编号。所以一个连 \\\\通分量里的代表点，它的权必须是最大的。$ 思路:$ 权最大的是代表点，所以在合并连通分量时以权大的为父亲, \\\\然后我们离线处理每个询问,用map维护。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;int p[10005],a[10005];struct query&#123; char str[10]; int p1,p2;////有2个参数&#125; tem;struct edge&#123; int u,v; bool operator &lt; (const edge &amp;a)const &#123; if(u==a.u) return v&lt;a.v; else return u&lt;a.u; &#125;&#125; e[20005],teme;int findset(int x)&#123; return x==p[x]?p[x]:p[x]=findset(p[x]);&#125;void join(int x,int y)&#123; int px=findset(x),py=findset(y); if(px!=py&amp;&amp;a[px]&gt;=a[py]) p[py]=px; if(px!=py&amp;&amp;a[px]&lt;a[py]) p[px]=py;&#125;int main()&#123; int n,m,aa,bb,q; bool flag=false; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(flag) cout&lt;&lt;endl; flag=true; stack&lt;int&gt;ans; stack&lt;query&gt;st; map&lt;edge,bool&gt;mp; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); p[i]=i; &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=0; i&lt;m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;aa,&amp;bb); e[i].u=min(aa,bb); e[i].v=max(aa,bb); mp[e[i]]=true; &#125; scanf(&quot;%d&quot;,&amp;q); for(int i=0; i&lt;q; i++) &#123; scanf(&quot;%s%d&quot;,&amp;tem.str,&amp;tem.p1); if(tem.str[0]==&apos;d&apos;) &#123; scanf(&quot;%d&quot;,&amp;tem.p2); teme.u=min(tem.p1,tem.p2),teme.v=max(tem.p1,tem.p2); mp[teme]=false; st.push(tem); &#125; else tem.p2=-1,st.push(tem); &#125; map&lt;edge, bool&gt;::iterator iter=mp.begin(); while(iter!=mp.end()) &#123; if(iter-&gt;second) &#123; join(iter-&gt;first.u,iter-&gt;first.v); &#125; iter++; &#125; while(!st.empty()) &#123; tem=st.top(); st.pop(); if(tem.str[0]==&apos;q&apos;) &#123; if(a[findset(tem.p1)]==a[tem.p1]) ans.push(-1); else ans.push(findset(tem.p1)); &#125; else join(tem.p1,tem.p2); &#125; while(!ans.empty()) &#123; printf(&quot;%d\\n&quot;,ans.top()); ans.pop(); &#125; &#125; return 0;&#125;","path":"2019/02/04/Zoj3261-Connections-in-Galaxy-War/"},{"title":"Poj 3522 Slim Span","text":"描述:找一棵生成树，且生成树中边权最大差值尽可能小。 思路:$把边权从小到大排序，然后依次枚举生成树中的最小权重，更新差值, \\\\找到答案，算法复杂度为E*log(V)*E。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;int p[105];int Find(int x)&#123; return p[x]==x?x:p[x]=Find(p[x]);&#125;void join(int x,int y)&#123; int px=Find(x),py=Find(y); if(px!=py) p[px]=py;&#125;struct node&#123; int u,v,w;&#125; e[6000];bool cmp(node x,node y)&#123; return x.w&lt;y.w;&#125;int main()&#123; int n,m,t; bool flag; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;(n+m)) &#123; for(int i=1; i&lt;=m; i++) &#123; cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w; &#125; sort(e+1,e+m+1,cmp); flag=false; int ans=1e7; for(int i=1; i&lt;=m; i++) &#123; t=0; int tem; for(int k=0; k&lt;105; k++) p[k]=k; for(int j=i; j&lt;=m&amp;&amp;t&lt;n-1; j++) &#123; int x=Find(e[j].u); int y=Find(e[j].v); if(x!=y) &#123; p[x]=y; t++; tem=j; &#125; &#125; if(t==n-1) &#123; flag=true; ans=min(ans,e[tem].w-e[i].w); &#125; &#125; if(flag) cout&lt;&lt;ans&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Poj-3522-Slim-Span/"},{"title":"Poj 2186 Popular Cows","text":"描述:$有若干cows，如果a崇拜b，b崇拜c那么a崇拜c，求有多少cows \\\\被其他的所有cows崇拜。$ 思路:$建立有向图，然后缩点，需要找的点就是出度为0的点。 \\\\证明:若有一点a出度不为0且a到b有一条边，由于是DAG \\\\可知不存在从b到a的路径，所以a不是所求点，又发现若 \\\\出度为0的点数量大于1时必然不满足题意,这些点之间不 \\\\存在有向边。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=20005;const int maxm=50005;struct Edge&#123; int to,next;&#125; edge[maxm];int head[maxn],tot;int index,top;int Low[maxn],Dfn[maxn],Stack[maxn],Belong[maxn];int mark[maxn];int scc;bool Instack[maxn];int num[maxn];int n,m,x,y;void addedge(int u,int v)&#123; edge[tot].to=v; edge[tot].next=head[u]; head[u]=tot++;&#125;void Tarjan(int u)&#123; int v; Low[u]=Dfn[u]=++index; Stack[top++]=u; Instack[u]=true; for(int i=head[u]; i!=-1; i=edge[i].next) &#123; v=edge[i].to; if(!Dfn[v]) &#123; Tarjan(v); if(Low[u]&gt;Low[v]) Low[u]=Low[v]; &#125; else if(Instack[v]&amp;&amp;Low[u]&gt;Dfn[v]) Low[u]=Dfn[v]; &#125; if(Low[u]==Dfn[u]) &#123; scc++; do &#123; v=Stack[--top]; Instack[v]=false; Belong[v]=scc; num[scc]++; &#125; while(v!=u); &#125;&#125;void solve(int n)&#123; memset(Dfn,0,sizeof(Dfn)); memset(Low,0,sizeof(Low)); memset(Instack,false,sizeof(Instack)); memset(num,0,sizeof(num)); memset(mark,0,sizeof(mark)); index=scc=top=0; for(int i=1; i&lt;=n; i++) if(!Dfn[i]) Tarjan(i); for(int i=1; i&lt;=n; i++) for(int j=head[i]; j!=-1; j=edge[j].next) &#123; if(Belong[i]!=Belong[edge[j].to]) mark[Belong[i]]=true; &#125; int pos=0,lab=0; for(int i=1; i&lt;=scc; i++) if(!mark[i]) &#123; lab++; pos=i; &#125; if(lab&gt;1)printf(&quot;0\\n&quot;); else printf(&quot;%d\\n&quot;,num[pos]);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); tot=0; memset(head,-1,sizeof(head)); for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); addedge(x,y); &#125; solve(n);&#125;","path":"2019/02/04/Poj-2186-Popular-Cows/"},{"title":"Hdu 6447 YJJ Salesman","text":"描述:有一个矩阵，某些点有宝物，宝物有权重，某人从左下角出发，只能向右，上，右上走，求取到的物品权重之和最大值。 思路:$首先离散化地图,然后推出朴素的转移方程 \\\\dp[i][j]=max\\{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+w\\}, \\\\N^{2}复杂度对(10)^{5}数据会T。考虑加速dp。先把有宝物 \\\\的地点排序,按照从左向右，从上到下的顺序排序。考虑在 \\\\(x,y)处获得的最大收益，其实就是要求在(x-1,y-1)这个 \\\\矩形内的最大收益加上w(x,y)。这是一个区间最值问题, \\\\还涉及到点修改，可以用树状数组维护。$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;int t,n,tree[maxn],yy[maxn];struct Node&#123; int x,y,z;&#125; node[maxn];bool cmp(Node a,Node b)&#123; if(a.x==b.x) return a.y&gt;b.y; return a.x&lt;b.x;&#125;int lowbit(int x)&#123; return x&amp;(-x);&#125;void uppdate(int x,int tem)&#123; for(int i=x; i&lt;=maxn; i+=lowbit(i)) &#123; tree[i]=max(tree[i],tem); &#125;&#125;int query(int x)&#123; int ret=0; for(int i=x; i&gt;=1; i-=lowbit(i)) &#123; ret=max(ret,tree[i]); &#125; return ret;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); memset(tree,0,sizeof(tree)); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;node[i].x,&amp;node[i].y,&amp;node[i].z); yy[i]=node[i].y; &#125; sort(yy+1,yy+n+1); int Size=unique(yy+1,yy+n+1)-yy-1; for(int i=1; i&lt;=n; i++) node[i].y=lower_bound(yy+1,yy+1+Size,node[i].y)-yy; sort(node+1,node+n+1,cmp); int ans=0; for(int i=1; i&lt;=n; i++) &#123; int val=query(node[i].y-1)+node[i].z; ans=max(ans,val); uppdate(node[i].y,val); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu-6447-YJJ-Salesman/"},{"title":"Hdu6434 Count","text":"描述:$求\\sum _{i=1}^n \\sum _{j=1}^{i-1} [gcd(i+j,i-j)=1] $ 思路:$先做变量代换，令a=i-j,先枚举i,再枚举a,然后对等式变形, \\\\题意转化为对于每个i，求有多少个小于它的a满足gcd(i,a)=1 \\\\且a是奇数,当i是奇数时,答案为\\varphi(i)/2,当i是偶数时, \\\\答案是 \\varphi(i),注意特判i=1时,答案为0。$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;typedef long long ll;const int maxn=2e7+5;int phi[maxn];ll sum[maxn];void phi_table()&#123; memset(phi,0,sizeof(phi)); phi[1]=1; for(int i=2; i&lt;maxn; i++)if(!phi[i]) for(int j=i; j&lt;maxn; j+=i) &#123; if(!phi[j]) phi[j]=j; phi[j]=phi[j]/i*(i-1); &#125;&#125;int main()&#123; phi_table(); sum[1]=0; sum[2]=phi[2]; for(int i=3; i&lt;maxn; i++) if(i%2==1) sum[i]=sum[i-1]+phi[i]/2; else sum[i]=sum[i-1]+phi[i]; int t,n; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;sum[n]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu6434-Count/"},{"title":"Hdu6432 Cyclic","text":"描述:$1-n的n个数组成一个环,要求i后面不能放i+1，n后面不能放1 \\\\经旋转能得到的2种视为同一种方案,求所有本质不同的方案数。$ 思路:容斥计数。 1234567891011121314151617181920212223242526272829303132#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;typedef long long ll;const int mod=998244353;const int maxn=1e5+5;ll ans[maxn];int main()&#123; int t,n; cin&gt;&gt;t; ans[0]=1; ans[1]=0; ans[2]=0; ans[3]=1; ans[4]=1; for(int i=5; i&lt;maxn; i++) &#123; ans[i]=((i-3)*ans[i-1]%mod+(i-2)*(2*ans[i-2]+ans[i-3])%mod)%mod; &#125; while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;ans[n]&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu6432-Cyclic/"},{"title":"Hdu6060 RXD and dividing","text":"描述:$把树上2-n的结点分成k个集合且不能相交,然后每次取出一个集合 \\\\所有点与1号结点形成连通分量把连通分量里的所有边权相加后加 \\\\到ans上，求最大的ans。$ 思路:$一条边对于ans的贡献值应该是min\\{k,k的子孙的数量\\}*边权, \\\\然后又是经典的统计子树了。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;const int maxn=1e6+5;struct node&#123; int next,w;&#125;;vector&lt;node&gt;vec[maxn];node tem;int son[maxn],p[maxn];void dfs(int v,int u)&#123; son[v]=1; int len=vec[v].size(); for(int i=0; i&lt;len; i++) &#123; int t=vec[v][i].next; p[t]=vec[v][i].w; dfs(t,v); son[v]+=son[t]; &#125;&#125;int main()&#123; int n,k,u,v,value; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;k)) &#123; for(int i=1; i&lt;=n; i++) &#123; vec[i].clear(); son[i]=0; p[i]=0; &#125; for(int i=1; i&lt;=n-1; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;value); tem.next=v; tem.w=value; vec[u].push_back(tem); &#125; dfs(1,0); ll ans=0; for(int i=2;i&lt;=n;i++) &#123; ans+=(ll)p[i]*min(son[i],k); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/Hdu6060-RXD-and-dividing/"},{"title":"Hdu5901","text":"描述:$求n以内素数个数,n最大(10)^{11}$。 思路: 论文题,套模板就好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cmath&gt;#define LL long longusing namespace std;const int N = 5e6 + 5;const int M = 7;const int PM = 2 * 3 * 5 * 7 * 11 * 13 * 17;int np[N];int prime[N], pi[N];int phi[PM+1][M+1], sz[M+1];int getprime()&#123; int cnt = 0; np[0] = np[1] = 1; pi[0] = pi[1] = 0; for(int i = 2; i &lt; N; ++i) &#123; if(!np[i]) prime[++cnt] = i; pi[i] = cnt; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++j) &#123; np[i * prime[j]] = 1; if(i % prime[j] == 0) break; &#125; &#125; return cnt;&#125;void init()&#123; getprime(); sz[0] = 1; for(int i = 0; i &lt;= PM; ++i) phi[i][0] = i; for(int i = 1; i &lt;= M; ++i) &#123; sz[i] = prime[i] * sz[i-1]; for(int j = 1; j &lt;= PM; ++j) phi[j][i] = phi[j][i-1] - phi[j/prime[i]][i-1]; &#125;&#125;int sqrt2(LL x)&#123; LL r = (LL)sqrt(x - 0.1); while(r*r &lt;= x) ++r; return (int)(r-1);&#125;int sqrt3(LL x)&#123; LL r = (LL)cbrt(x - 0.1); //cbrt(x): x的立方根 while(r*r*r &lt;= x) ++r; return (int)(r-1);&#125;LL getphi(LL x, int s)&#123; if(s == 0) return x; if(s &lt;= M) return phi[x%sz[s]][s] + (x/sz[s]) * phi[sz[s]][s]; if(x &lt;= prime[s]*prime[s]) return pi[x] - s + 1; if(x &lt;= prime[s]*prime[s]*prime[s] &amp;&amp; x &lt; N) &#123; int s2x = pi[sqrt2(x)]; LL ans = pi[x] - (s2x+s-2)*(s2x-s+1)/2; for(int i = s+1; i &lt;= s2x; ++i) ans += pi[x/prime[i]]; return ans; &#125; return getphi(x, s-1) - getphi(x/prime[s], s-1);&#125;LL getpi(LL x)&#123; if(x &lt; N) return pi[x]; LL ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1; for(int i = pi[sqrt3(x)]+1, ed = pi[sqrt2(x)]; i &lt;= ed; ++i) ans -= getpi(x/prime[i]) - i + 1; return ans;&#125;LL lehmer_pi(LL x)&#123; if(x &lt; N) return pi[x]; int a = (int)lehmer_pi(sqrt2(sqrt2(x))); int b = (int)lehmer_pi(sqrt2(x)); int c = (int)lehmer_pi(sqrt3(x)); LL sum = getphi(x, a) + (LL)(b+a-2) * (b-a+1)/2; for (int i = a+1; i &lt;= b; ++i) &#123; LL w = x/prime[i]; sum -= lehmer_pi(w); if(i &gt; c) continue; LL lim = lehmer_pi(sqrt2(w)); for(int j = i; j &lt;= lim; ++j) sum -= lehmer_pi(w/prime[j]) - (j-1); &#125; return sum;&#125;int main()&#123; LL n; init(); while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; printf(&quot;%lld\\n&quot;, lehmer_pi(n)); &#125; return 0;&#125;","path":"2019/02/04/Hdu5901/"},{"title":"Hdu 1695","text":"描述:$求i \\in [1,m],j \\in [1,n],gcd(i,j)=k的pair数。$ 思路:莫比乌斯反演入门题,套个容斥去重。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;bool check[maxn];ll prime[maxn];ll mu[maxn];void mobius()&#123; memset(check,false,sizeof(check)); mu[1]=1; int tot=0; for(int i=2; i&lt;maxn; i++) &#123; if(!check[i]) &#123; prime[tot++]=i; mu[i]=-1; &#125; for(int j=0; j&lt;tot; j++) &#123; if(i*prime[j]&gt;=maxn) break; check[i*prime[j]]=true; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0; break; &#125; else mu[i*prime[j]]=-mu[i]; &#125; &#125;&#125;ll t,a,b,c,d,k;__int64 ans,ans2;int main()&#123; mobius(); cin&gt;&gt;t; for(int i=1; i&lt;=t; i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k; if(!k) &#123; cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;0&lt;&lt;endl; continue; &#125; ans=0; ans2=0; int minn=min(b/k,d/k); for(int i=1; i&lt;=minn; i++) &#123; ans+=mu[i]*(b/k/i)*(d/k/i); &#125; for(int i=1;i&lt;=minn;i++) &#123; ans2+=mu[i]*(minn/i)*(minn/i); &#125; printf(&quot;Case %d: %I64d\\n&quot;,i,ans-ans2/2); //cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;ans-ans2/2&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/Hdu-1695/"},{"title":"2018ICPC徐州网络赛 Maze Designer 最大生成树+LCA","text":"描述:要求删除一些边以后使剩下一棵生成树,并且使得删除的边权和最小,然后询问树上2点的最短距离。 思路:$ 先求原图的最大生成树，然后求LCA。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N=250005;struct node&#123; int v,dis,next;&#125;edges[N&lt;&lt;1];int head[N],e;int id[N]; //节点第一次被遍历的顺序int dis[N]; //节点到根节点的距离int RMQ[N*3][20];int curID;//F[i]表示第i个遍历的节点//B[i]表示F[i]在树中的深度int F[N*3],B[N*3];int root;void init()&#123; e = 0; curID = 0; memset(head,-1,sizeof(head));&#125;void Add (int u,int v,int dis)&#123; edges[e].v=v; edges[e].dis=dis; edges[e].next=head[u]; head[u]=e++;&#125;void DFS (int u,int p,int Dep,int d)&#123; int i,v; curID++; F[curID]=u; B[curID]=Dep; id[u]=curID; dis[u]=d; for (i=head[u];i!=-1;i=edges[i].next)&#123; v=edges[i].v; if (v==p) continue; DFS(v,u,Dep+1,d+1); curID++; F[curID]=u; B[curID]=Dep; &#125;&#125;void initRMQ ()&#123; int i,j,x,y; for (i=1;i&lt;=curID;i++) RMQ[i][0]=i; for (j=1;(1&lt;&lt;j)&lt;=curID;j++) for (i=1;i+(1&lt;&lt;j)-1&lt;=curID;i++)&#123; x=RMQ[i][j-1]; y=RMQ[i+(1&lt;&lt;(j-1))][j-1]; RMQ[i][j]=B[x]&lt;B[y]?x:y; &#125;&#125;int getLCA (int a,int b)&#123; int k,x,y; a=id[a];b=id[b]; if (a&gt;b) k=a,a=b,b=k; k=log(1.0+b-a)/log(2.0); x=RMQ[a][k]; y=RMQ[b-(1&lt;&lt;k)+1][k]; return B[x]&lt;B[y]?F[x]:F[y];&#125;int dist(int x,int y)&#123; return dis[x] +dis[y] - 2*dis[getLCA(x,y)];&#125;struct Edg&#123; int u,v; LL dist; bool operator&lt;(const Edg &amp;rhs)const&#123;return dist&gt;rhs.dist;&#125;&#125;;struct Kruskal&#123; int n,m; Edg edges[N&lt;&lt;1]; int fa[N]; int findset(int x)&#123; return fa[x]==-1?x:fa[x]=findset(fa[x]); &#125; void init(int n)&#123; this-&gt;n=n; m=0; memset(fa,-1,sizeof(fa)); &#125; void AddEdge(int u,int v,LL dist)&#123; edges[m++] = (Edg)&#123;u,v,dist&#125;; &#125; void kruskal()&#123; LL sum=0; int cnt=0; sort(edges,edges+m); for(int i=0;i&lt;m;i++)&#123; int u=edges[i].u, v=edges[i].v; if(findset(u) != findset(v))&#123; Add(u,v,1); Add(v,u,1); sum +=edges[i].dist; fa[findset(u)] = findset(v); if(++cnt&gt;=n-1) return ; &#125; &#125; return ; &#125;&#125;G;int main()&#123; int n,m; char c1,c2; LL w1,w2; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; init(); G.init(n*m+1); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; scanf(&quot;\\n%c %lld %c %lld&quot;,&amp;c1,&amp;w1,&amp;c2,&amp;w2); if(c1==&apos;D&apos;)&#123; G.AddEdge((i-1)*m+j,i*m+j,w1); &#125; if(c2 == &apos;R&apos;)&#123; G.AddEdge((i-1)*m+j,(i-1)*m+j+1,w2); &#125; &#125; &#125; G.kruskal(); root=1; DFS(root,0,0,0); initRMQ(); int Q; scanf(&quot;%d&quot;,&amp;Q); int x1,y1,x2,y2; while(Q--)&#123; scanf(&quot;%d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); int u = (x1-1)*m+y1, v = (x2-1)*m+y2; printf(&quot;%d\\n&quot;,dist(u,v)); &#125; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC徐州网络赛-Maze-Designer-最大生成树-LCA/"},{"title":"2018牛客国庆训练营 day6","text":"C&amp;H签到。 G:对方格染色，使得在所有操作后，每种颜色的sum都相同。 12345678910111213141516171819202122232425262728293031323334include&lt;bits/stdc++.h&gt;using namespace std;int a[1005][1005];int color[1005][1005];int n,ans,tem,sum;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; scanf(&quot;%d&quot;,&amp;a[i][j]); color[i][j]=(i+j)%n; if(a[i][j]==-1) tem=color[i][j]; &#125; &#125; int _color,_sum=0; if(tem==n-1) _color=n-2; else _color=n-1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(color[i][j]==_color) _sum+=a[i][j]; if(color[i][j]==tem&amp;&amp;a[i][j]!=-1) sum+=a[i][j]; &#125; &#125; printf(&quot;%d\\n&quot;,_sum-sum);&#125; A:$拆点以后跑费用流,每个区域拆成n个点，一个蛋糕和第i层连边，其 \\\\费用是i*i-(i-1)*(i-1)。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;const int maxn=5005;const int maxm=50005;int s,t;int num=-1,tot,sum;int dis[maxn],b[maxn],xb[maxn],flow[maxn],fa[maxn];int head[maxm];struct Edge&#123; int from,to,dis,nxt,w;&#125; edge[maxm*2];void add_edge(int from,int to,int w,int dis)&#123; edge[++num].nxt=head[from]; edge[num].from=from; edge[num].to=to; edge[num].w=w; edge[num].dis=dis; head[from]=num;&#125;bool spfa()&#123; for(int i=0; i&lt;=maxn; i++) dis[i]=inf; memset(b,0,sizeof(b)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); memset(fa,-1,sizeof(fa)); b[s]=1; dis[s]=0; fa[s]=0; flow[s]=inf; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); b[u]=0; for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(edge[i].w&gt;0&amp;&amp;dis[v]&gt;dis[u]+edge[i].dis) &#123; dis[v]=dis[u]+edge[i].dis; fa[v]=u; xb[v]=i; flow[v]=min(flow[u],edge[i].w); if(!b[v]) &#123; b[v]=1; que.push(v); &#125; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;void max_flow()&#123; while(spfa()) &#123; int k=t; while(k!=s) &#123; edge[xb[k]].w-=flow[t]; edge[xb[k]^1].w+=flow[t]; k=fa[k]; &#125; tot+=flow[t]; sum+=flow[t]*dis[t]; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; for(int j=1; j&lt;=n; j++) &#123; add_edge(i,n+(j-1)*m+a,1,2*j-1); add_edge(n+(j-1)*m+a,i,0,1-2*j); add_edge(i,n+(j-1)*m+b,1,2*j-1); add_edge(n+(j-1)*m+b,i,0,1-2*j); &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; add_edge(0,i,1,0); add_edge(i,0,0,0); &#125; for(int i=n+1; i&lt;=n+n*m; i++) &#123; add_edge(i,n+n*m+1,1,0); add_edge(n+n*m+1,i,0,0); &#125; s=0; t=n+n*m+1; max_flow(); cout&lt;&lt;sum&lt;&lt;endl;&#125;","path":"2019/02/04/2018牛客国庆训练营-day6/"},{"title":"2018牛客国庆集训派对 day3","text":"D:签到。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;double a[1050];int b[1050];bool cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; int cnt=0; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; if(b[i]) cnt++; &#125; sort(a,a+n,cmp); double ans=0; cnt=min(cnt,m); for(int i=0;i&lt;cnt;i++) &#123; ans+=a[i]/2; &#125; for(int i=cnt;i&lt;n;i++) ans+=a[i]; printf(&quot;%.1f\\n&quot;,ans); &#125;&#125; H:发现和树的结构没有关系，只要考虑如何把树上的结点分成几部分，推完发现是个组合数取模，预处理阶乘，用乘法逆元即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+5;const int mod=1e9+7;ll fac[maxn];void init_fac()&#123; fac[0]=fac[1]=1; for(int i=2;i&lt;maxn;i++) fac[i]=i*fac[i-1]%mod;&#125; ll quickpow(ll a,ll n)&#123; ll ret=1; while(n) &#123; if(n&amp;1) ret=ret*a%mod; a=a*a%mod; n&gt;&gt;=1; &#125; return ret;&#125;ll C(ll a,ll b)&#123; return fac[a]*quickpow(fac[b],mod-2)%mod*quickpow(fac[a-b],mod-2)%mod;&#125; int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); init_fac(); while(t--) &#123; int n,m; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;n;i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); &#125; ll ans=C(n-1,m-1)*fac[m]%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125; A:马走日问题，因为棋盘太大，可以大范围贪心+小范围暴搜。题解是找规律。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x, y, ans; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;x&gt;&gt;y; x=abs(x); y=abs(y); if(x&gt;y)swap(x, y); if(y==x*2) &#123; printf(&quot;%d\\n&quot;, (x+y)/3); continue; &#125; if(y&lt;=2*x) &#123; if(x==1&amp;&amp;y==1) ans = 2; else if(x==2&amp;&amp;y==2) ans = 4; else ans = (x+y)/3+(x+y)%3; &#125; else &#123; ans=x; int c=(y-2*x)%4; ans+=c; ans+=(y-2*x-c)/2; if(y==1&amp;&amp;x==0) ans=3; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125;","path":"2019/02/04/2018牛客国庆集训派对-day3/"},{"title":"2018牛客国庆集训派对day1 J Princess Principal","text":"描述:给出一个括号序列，然后给出多组询问，每次判断一个区间里的括号是否是匹配的。 思路:$对于一个括号序列，如果想让所有的括号尽可能多的匹配，每个单 \\\\括号应该只对应唯一的另一个单括号与它匹配。那么就可以比较加入 \\\\a_l之前栈里留下的括号的状态和加入a_r以后栈里留下的括号的状态, \\\\如果一样，相当于这段区间的括号消掉了。$ $思路二，已知括号序列的匹配方式是唯一的，如果在区间里任意取出 \\\\一个单括号,与它匹配的单括号也必须在这个区间里。所以先预处理与 \\\\每一个位置单括号匹配的另一个单括号的编号x_i。 但是这时查询一个 \\\\区间的复杂度仍然是线性的。 但其实只需要查询这个区间里x_i的最大值 \\\\和最小值即可，最大值是右端点，最小值是左端点说明这个区间匹配。$ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,m,q;int a[maxn],x[maxn];stack&lt;int&gt;s;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); while(!s.empty()) s.pop(); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=n;i++) &#123; if(s.empty()||!(a[i]&amp;1)) s.push(i); else if(a[s.top()]+1==a[i]) s.pop(); else s.push(i); if(s.empty()) x[i]=0; else x[i]=s.top(); &#125; while(q--) &#123; int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); if(x[l-1]==x[r]) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;int n,m,q;int a[maxn],b[maxn],x[maxn&lt;&lt;2],y[maxn&lt;&lt;2];stack&lt;int&gt;s;void build(int R,int l,int r)&#123; if(l==r) &#123; x[R]=b[l]; y[R]=b[l]; return; &#125; int mid=l+r&gt;&gt;1; build(R&lt;&lt;1,l,mid); build(R&lt;&lt;1|1,mid+1,r); x[R]=min(x[R&lt;&lt;1],x[R&lt;&lt;1|1]); y[R]=max(y[R&lt;&lt;1],y[R&lt;&lt;1|1]);&#125;void ask(int R,int l,int r,int ql,int qr,int &amp;u,int &amp;v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) &#123; u=min(u,x[R]); v=max(v,y[R]); return ; &#125; int mid=l+r&gt;&gt;1; if(ql&lt;=mid) ask(R&lt;&lt;1,l,mid,ql,qr,u,v); if(qr&gt;mid) ask(R&lt;&lt;1|1,mid+1,r,ql,qr,u,v);&#125;int main()&#123; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,a+i); b[i]=-1; if(s.empty()||!(a[i]&amp;1)) s.push(i); else if (a[s.top()]+1==a[i]) b[i]=s.top(),b[s.top()]=i,s.pop(); else s.push(i); &#125; build(1,1,n); while(q--) &#123; int ql,qr; scanf(&quot;%d %d&quot;,&amp;ql,&amp;qr); int _1=1e9,_2=-2; ask(1,1,n,ql,qr,_1,_2); if(_1==ql&amp;&amp;_2==qr) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;","path":"2019/02/04/2018牛客国庆集训派对day1-J-Princess-Principal/"},{"title":"2018牛客暑期多校训练四 A gpa 01分数规划","text":"描述:$给一个数列a和一个数列b，然后从这两个数列中中最多删除k个项, \\\\即同时删除a_i和b_i，求剩下来的\\sum (a_i*b_i)/\\sum a_i最大值。$ 思路:$设\\sum (a_i*b_i)/ \\sum a_i \\ge D $ $变形\\sum (a_i*b_i) \\ge (\\sum a_i)*D$ $变形\\sum (a_i*(b_i-D)) \\ge 0$ $然后二分D 把s_i排个序，至多删除k项，就把就k小的项都删除，判断 \\\\剩下来的项的和，把和与0比较进行二分。$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;iomanip&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;typedef long double ld;const double eps=1e-6;struct node&#123; double s,c;&#125; p[100005];double d[100005];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;p[i].s; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i].c; &#125; memset(d,0,sizeof(d)); double r=1000; double l=0; double mid; while(r-l&gt;eps) &#123; double sum=0; mid=(r+l)/2; for(int i=0; i&lt;n; i++) d[i]=p[i].s*p[i].c-p[i].s*mid; sort(d,d+n); for(int i=k; i&lt;n; i++) sum+=d[i]; if(sum&gt;=0) l=mid; else r=mid; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l&lt;&lt;endl;&#125;","path":"2019/02/04/2018牛客暑期多校训练四-A-gpa-01分数规划/"},{"title":"2018ICPC南京网络赛 分层图最短路","text":"描述:$考虑边带权的图，已知源点和终点，如果可以使的图里的k条边\\\\边权变成0，最短路是多少。$ 思路:$把图分成k层，每层仍然是n个点，每层的连边方式仍然和原图相同。\\\\除此以外，层与层之间该如何连边?假设现在在第i层，点u和点v之间\\\\有一条权值w的边，对于下一层，即i+1层，u’与v’之间仍是有一条\\\\权为w的边，且对于u与v’之间应该加上一条边权为0的边。$ $拆点以后在新图上跑最短路。另外此题卡SPFA，\\\\用优化后的dijkstra即可。$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF=1e18;const int maxn=1200000;const int maxm=4500000;int t,n,m,k,a,b,c,cnt;bool done[maxn];ll d[maxn];struct Edge&#123; int u,v,nex; ll w;&#125; edge;Edge g[maxm];int head[maxn];void add(int u,int v,ll w)&#123; g[cnt].u=u; g[cnt].v=v; g[cnt].w=w; g[cnt].nex=head[u]; head[u]=cnt++;&#125;struct HeapNode&#123; int d,u; bool operator &lt; (const HeapNode&amp; rhs)const &#123; return d&gt;rhs.d; &#125;&#125; node;inline void dijkstra(int s)&#123; priority_queue&lt;HeapNode&gt;Q; memset(d,0x3f,sizeof(d)); d[s]=0; memset(done,false,sizeof(done)); Q.push(HeapNode&#123;0,s&#125;); while(!Q.empty()) &#123; HeapNode x=Q.top(); Q.pop(); int u=x.u; if(done[u]) continue; done[u]=true; for(int i=head[u]; i+1; i=g[i].nex) &#123; if(d[g[i].v]&gt;d[u]+g[i].w) &#123; d[g[i].v]=d[u]+g[i].w; Q.push(HeapNode&#123;d[g[i].v],g[i].v&#125;); &#125; &#125; &#125;&#125;inline int read()&#123; char c=getchar(); int x=0,f=1; while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;) &#123; if(c==&apos;-&apos;)f=-1; c=getchar(); &#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) &#123; x=x*10+c-&apos;0&apos;; c=getchar(); &#125; return x*f;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;t)) &#123; while(t--) &#123; //scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); n=read(); m=read(); k=read(); cnt=0; memset(head,-1,sizeof(head)); for(int i=1; i&lt;=m; i++) &#123; //scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); a=read(); b=read(); c=read(); add(a,b,c); for(int j=1; j&lt;=k; j++) &#123; add(j*n+a,j*n+b,c); add((j-1)*n+a,j*n+b,0); &#125; &#125; dijkstra(1); ll ans=INF; for(int i=1; i&lt;=k+1; i++) &#123; ans=min(ans,d[i*n]); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC南京网络赛-分层图最短路/"},{"title":"2018ICPC南京网络赛 AC Challenge 状压dp","text":"描述:$n个题，做每个题之前必须把限制的某几个题做完。\\\\做第i个题的得分是a*w_i+b,w_i是第i题权重，a,b$都是常数，问能得到的最高分。 思路:考虑到$n$最大只有20，且每个题只有做和不做两种状态，所以可以状压dp。 对于每个状态的枚举时，首先判断这种状态是否符合条件。如果这种状态是符合条件的，那考虑这种状态中所有已经做了的题，分别把它们状态设为没做，这样就找到所有能转移到目前状态的前驱状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;int t;struct Node&#123; int a,b,s;&#125; node[25];vector&lt;int&gt;vec[25];int dp[(1&lt;&lt;20)+1];int main()&#123; while(cin&gt;&gt;t) &#123; for(int i=1; i&lt;=t; i++) &#123; cin&gt;&gt;node[i].a&gt;&gt;node[i].b&gt;&gt;node[i].s; int tem; for(int j=1; j&lt;=node[i].s; j++) &#123; cin&gt;&gt;tem; vec[i].push_back(tem); &#125; &#125; memset(dp,0,sizeof(dp)); int ans=0; for(int i=0; i&lt;(1&lt;&lt;t); i++) &#123; bool ok=true; for(int j=1; j&lt;=t; j++) &#123; if(!(i&amp;(1&lt;&lt;(j-1)))) continue; for(int k=0;k&lt;vec[j].size();k++) &#123; int tmp=vec[j][k]; if(!(i&amp;(1&lt;&lt;(tmp-1)))) &#123; ok=false; break; &#125; &#125; if(!ok) break; &#125; if(!ok) continue;//如果不满足大条件 就丢掉 for(int j=1;j&lt;=t;j++) &#123; if(!(i&amp;(1&lt;&lt;(j-1)))) continue;//这题做过的才能继续这个算法 int s=i,cnt=0;//统计i的二进制里有几个1，也就是有几题做过 while(s) &#123; if(s&amp;1) cnt++; s/=2; &#125; dp[i]=max(dp[i],dp[i^(1&lt;&lt;(j-1))]+cnt*node[j].a+node[j].b);//让做过的这题没做就是前一个状态 &#125; ans=max(ans,dp[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC南京网络赛-AC-Challenge-状压dp/"},{"title":"2018ICPC北京网络赛D 80days 尺取法","text":"描述:传送门 思路:有环，易想到复制一份在后面，然后考虑枚举起点，尺取法双指针扫描即可，复杂度为线性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e6+5;int t;int n,k;int a[maxn],b[maxn],c[maxn&lt;&lt;1];int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) &#123; c[i]=a[i]-b[i]; c[n+i]=a[i]-b[i]; &#125; int l=1,r=1; ll tem=0; bool ok=true; while(l&lt;=n&amp;&amp;r-l+1&lt;=n) &#123; if(!ok) break; if(tem+c[r]+k&gt;=0) &#123; tem+=c[r]; r++; &#125; else &#123; tem+=c[r]; r++; while(tem+k&lt;0) &#123; tem-=c[l]; l++; if(l&gt;r) &#123; ok=false; break; &#125; &#125; &#125; &#125; if(!ok||l&gt;n) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;l&lt;&lt;endl; &#125; return 0;&#125;","path":"2019/02/04/2018ICPC北京网络赛D-80days-尺取法/"},{"title":"2018Hdu 多校训练一 Time Zone","text":"描述:模拟时区，时区可以是小数。 思路:大力模拟。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int p,a,b,zs,xs;////直接从字符串里提取小数会有误差，所以这里分两部分提取出来char str[15];int main()&#123; scanf(&quot;%d&quot;,&amp;p); while(p--) &#123; scanf(&quot;%d%d%s&quot;,&amp;a,&amp;b,&amp;str); if(str[5]==&apos;.&apos;)zs=str[4]-&apos;0&apos;,xs=str[6]-&apos;0&apos;; else if(str[6]==&apos;.&apos;) zs=(str[4]-&apos;0&apos;)*10+str[5]-&apos;0&apos;,xs=str[7]-&apos;0&apos;; else if(str[5]==&apos;\\0&apos;) zs=str[4]-&apos;0&apos;,xs=0; else if(str[6]==&apos;\\0&apos;) zs=(str[4]-&apos;0&apos;)*10+str[5]-&apos;0&apos;,xs=0; if(str[3]==&apos;-&apos;) zs=-zs,xs=-xs; if(zs&gt;=8) &#123; if(xs*6+b&gt;=60) &#123; b=(xs*6+b)%60; a=(a+1+zs-8+24)%24; &#125; else b=xs*6+b,a=(a+zs-8+24)%24; if(a&gt;=10&amp;&amp;b&gt;=10) printf(&quot;%d:%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&lt;10) printf(&quot;0%d:0%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&gt;=10) printf(&quot;0%d:%d\\n&quot;,a,b); else if(a&gt;=10&amp;&amp;b&lt;10) printf(&quot;%d:0%d\\n&quot;,a,b); &#125; else if(zs&lt;8) &#123; int h=(80-(zs*10+xs))*6/60; int m=(80-(zs*10+xs))*6-h*60; if(m&gt;b) &#123; b=b+60-m; a=(a-1-h+24)%24; &#125; else b=b-m,a=(a-h+24)%24; if(a&gt;=10&amp;&amp;b&gt;=10) printf(&quot;%d:%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&lt;10) printf(&quot;0%d:0%d\\n&quot;,a,b); else if(a&lt;10&amp;&amp;b&gt;=10) printf(&quot;0%d:%d\\n&quot;,a,b); else if(a&gt;=10&amp;&amp;b&lt;10) printf(&quot;%d:0%d\\n&quot;,a,b); &#125; &#125;&#125;","path":"2019/02/04/2018Hdu-多校训练一-Time-Zone/"},{"title":"牛客练习赛22-C简单瞎搞题 bitset+dp","text":"描述:给出$n$个区间，然后分别给出区间的左右边界，可以在每个区间中选择一个整数，问这$n$个整数的平方和有多少种不同的取值。 思路:$ f_i $表示一个bitset，bitset里有几个1，就表示这i个区间所能得到的平方和的取值种数。 转移方程为 f[i]=f[i] | f[i-1]&lt;&lt;k^k (k from l to r) 状态转移的复杂度是n，每次操作对应的复杂度是l-r。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stdio.h&gt;#include&lt;bitset&gt;using namespace std;bitset&lt;1000000+10&gt;f[105];int main()&#123; int n,l,r; cin&gt;&gt;n; f[0][0]=1; for (int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;,&amp;l, &amp;r); for(int j=l; j&lt;=r; j++) &#123; f[i]=f[i]|f[i-1]&lt;&lt;j*j; &#125; &#125; printf(&quot;%d\\n&quot;, f[n].count()); return 0;&#125;","path":"2019/02/04/牛客练习赛22-C简单瞎搞题-bitset-dp/"},{"title":"Poj 3281 Dining 最大流","text":"描述:有一些牛，食物，饮料，每头牛都有一个喜欢吃的食物和饮料集合，要求你找出一个最大匹配，能满足所有牛的需求。 思路:拆点以后跑最大流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500;const int maxm=210000;const int inf=1e9;int cnt=-1,f,d,n,s,t;int head[maxn],dep[maxn],cur[maxn];struct Edge&#123; int nxt; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; edge[++cnt].nxt=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=f+2*n+d+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; for(int i=0; i&lt;maxm*2; i++) edge[i].nxt=-1; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;f,&amp;d); s=f+2*n+d+1; t=f+2*n+d+2; for(int i=1; i&lt;=n; i++) &#123; int a,b,tem; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); for(int j=1;j&lt;=a;j++) &#123; scanf(&quot;%d&quot;,&amp;tem); add_edge(tem,f+i,1); add_edge(f+i,tem,0); &#125; for(int j=1;j&lt;=b;j++) &#123; scanf(&quot;%d&quot;,&amp;tem); add_edge(f+n+i,f+2*n+tem,1); add_edge(f+2*n+tem,f+n+i,0); &#125; add_edge(f+i,f+n+i,1); add_edge(f+n+i,f+i,0); &#125; for(int i=1;i&lt;=f;i++) &#123; add_edge(s,i,1); add_edge(i,s,0); &#125; for(int i=1;i&lt;=d;i++) &#123; add_edge(f+2*n+i,t,1); add_edge(t,f+2*n+i,0); &#125; printf(&quot;%d\\n&quot;,Dinic());&#125;","path":"2019/02/04/Poj-3281-Dining-最大流/"},{"title":"Poj 3041 Asteroids 最小点覆盖","text":"描述:有一个500*500的网格图，格点上有一些点，每次可以消除一行或者一列上所有的点，问消除所有的点最少需要几次。 思路:因为要消除一个点,只有2种方式，并且一行或者一列多次消除是没有意义的。可以考虑构建一个二分图，左边是所有的行，右边是所有的列，把待消除的点作为边，一个点会唯一连一条边，那么题意转化为了，选择二分图上的点，把与这个点连的边加入一个集合，这个集合应该包含了所有边，最少选择的点的个数，问题转化为了最小点覆盖。 二分图里最小点覆盖等于最大匹配，跑一遍最大流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1100;const int maxm=260000;const int inf=1e9;int cnt=-1,n,k,s,t;int head[maxn],dep[maxn],cur[maxn];struct Edge&#123; int nxt; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; edge[++cnt].nxt=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=2*n+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; //建图 左边点1-N(行) 右边点N+1， 2N 源点2N+1,汇点2N+2; for(int i=0;i&lt;maxm*2;i++) edge[i].nxt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;k); memset(head,-1,sizeof(head)); cnt=-1; for(int i=1;i&lt;=k;i++) &#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); add_edge(x,y+n,1); add_edge(y+n,x,0); &#125; for(int i=1;i&lt;=n;i++) &#123; add_edge(2*n+1,i,1); add_edge(i,2*n+1,0); add_edge(i+n,2*n+2,1); add_edge(2*n+2,i+n,0); &#125; s=2*n+1; t=2*n+2; printf(&quot;%d\\n&quot;,Dinic());&#125;","path":"2019/02/04/Poj-3041-Asteroids-最小点覆盖/"},{"title":"Poj 2135 Farm Tour 费用流","text":"描述:给出起点和终点，要求从起点走到终点，再从终点回来，走的路最短，且来回走的路中不能有相同的边。 思路:不要考虑来回，其实本质就是选择两条路，边权和最小，所以我们可以跑一个最大流是2的费用流。(选n条路就跑最大流是n的费用流) 本题所有边都是无向边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;//#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9;const int maxn=2000;const int maxm=11000;int n,m,s,t;int cnt=-1,tot,sum;int dis[maxn],b[maxn],xb[maxn],flow[maxn],fa[maxn];int head[maxm];struct Edge&#123; int from,to,dis,nxt,w;&#125;edge[maxm*4];void add_edge(int from,int to,int w,int dis)&#123; edge[++cnt].nxt=head[from]; edge[cnt].from=from; edge[cnt].to=to; edge[cnt].w=w; edge[cnt].dis=dis; head[from]=cnt;&#125;bool spfa()&#123; for(int i=0;i&lt;=maxn;i++) dis[i]=inf; memset(b,0,sizeof(b)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); memset(fa,-1,sizeof(fa)); b[s]=1; dis[s]=0; fa[s]=0; flow[s]=inf; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); b[u]=0; for(int i=head[u];i!=-1;i=edge[i].nxt) &#123; int v=edge[i].to; if(edge[i].w&amp;&amp;dis[v]&gt;dis[u]+edge[i].dis) &#123; dis[v]=dis[u]+edge[i].dis; fa[v]=u; xb[v]=i; flow[v]=min(flow[u],edge[i].w); if(!b[v]) &#123; b[v]=1; que.push(v); &#125; &#125; &#125; &#125; return dis[t]&lt;inf;&#125;void max_flow()&#123; while(spfa()) &#123; int k=t; while(k!=s) &#123; edge[xb[k]].w-=flow[t]; edge[xb[k]^1].w+=flow[t]; k=fa[k]; &#125; tot+=flow[t]; sum+=flow[t]*dis[t]; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); cnt=-1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); s=n+1; t=n+2; for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,1,c); add_edge(b,a,0,-c); add_edge(b,a,1,c); add_edge(a,b,0,-c); &#125; add_edge(s,1,2,0); add_edge(1,s,0,0); add_edge(n,t,2,0); add_edge(t,n,0,0); max_flow(); printf(&quot;%d\\n&quot;,sum);&#125;","path":"2019/02/04/Poj-2135-Farm-Tour-费用流/"},{"title":"Hdu1569 洛谷P2774方格取数 状压dp or 最小割","text":"描述:给一个$n*m$的方格，每个格子里有个正数，要求选择若干数，这些数所在方格不能有相邻的边，要求选择的数的和最大。 思路:状压dp玄学爆过去了,然而复杂度算下来不对。 正解是网络流。对方格染色，把方格变成二分图，把所有点的权相加，去掉最小割就是我们所要的答案了，所以具体的建图方式为：源点与黑色点连，汇点与白色点连，容量都是点权。然后又因为选了一个点以后会影响它相邻的点，这些边是不会出现在割集中的，所以把这些边的容量置inf。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=15000;const int maxm=50000;const int inf=1e9;int cnt=-1,n,m,s,t,sum;int head[maxn],dep[maxn],cur[maxn];struct P&#123; int id,w;&#125;;vector&lt;P&gt;_1,_2;struct Edge&#123; int next=-1; int to,w;&#125; edge[maxm*2];void add_edge(int u,int v,int w)&#123; //cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;endl; edge[++cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool bfs()&#123; queue&lt;int&gt;que; while(!que.empty())que.pop(); memset(dep,0,sizeof(dep)); dep[s]=1; que.push(s); while(!que.empty()) &#123; int u=que.front(); que.pop(); for(int i=head[u]; i!=-1; i=edge[i].next) &#123; int v=edge[i].to; if(!dep[v]&amp;&amp;edge[i].w) &#123; dep[v]=dep[u]+1; que.push(v); &#125; &#125; &#125; if(dep[t]&gt;0) return 1; return 0;&#125;int dfs(int u,int flow)&#123; if(u==t) return flow; for(int &amp;i=cur[u]; i!=-1; i=edge[i].next) &#123; int v=edge[i].to; if((dep[v]==dep[u]+1)&amp;&amp;edge[i].w) &#123; int d=dfs(v,min(flow,edge[i].w)); if(d&gt;0) &#123; edge[i].w-=d; edge[i^1].w+=d; return d; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int ans=0; while(bfs()) &#123; for(int i=1; i&lt;=n*m+2; i++) cur[i]=head[i]; while(int d=dfs(s,inf)) &#123; ans+=d; &#125; &#125; return ans;&#125;int main()&#123; //1-n*n n*n+1,n*n+2m while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; _1.clear(); _2.clear(); sum=0; memset(head,-1,sizeof(head)); cnt=-1; s=n*m+1; t=n*m+2; int _cnt=0; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; P tem; scanf(&quot;%d&quot;,&amp;tem.w); sum+=tem.w; _cnt++; tem.id=_cnt; if((i+j)&amp;1) _1.push_back(tem); else _2.push_back(tem); &#125; &#125; for(int i=0; i&lt;_1.size(); i++) &#123; add_edge(s,_1[i].id,_1[i].w); add_edge(_1[i].id,s,0); &#125; for(int i=0; i&lt;_2.size(); i++) &#123; add_edge(_2[i].id,t,_2[i].w); add_edge(t,_2[i].id,0); &#125; for(int i=0; i&lt;_1.size(); i++) &#123; if(_1[i].id%m!=0) add_edge(_1[i].id,_1[i].id+1,inf),add_edge(_1[i].id+1,_1[i].id,0); if(_1[i].id%m!=1) add_edge(_1[i].id,_1[i].id-1,inf),add_edge(_1[i].id-1,_1[i].id,0); if(_1[i].id+m&lt;=n*m) add_edge(_1[i].id,_1[i].id+m,inf),add_edge(_1[i].id+m,_1[i].id,0); if(_1[i].id-m&gt;=1) add_edge(_1[i].id,_1[i].id-m,inf),add_edge(_1[i].id-m,_1[i].id,0); &#125; printf(&quot;%d\\n&quot;,sum-Dinic()); &#125;&#125;","path":"2019/02/04/Hdu1569-洛谷P2774方格取数-状压dp-or-最小割/"},{"title":"Hdu 1116 Play on Words 并查集+有向图的欧拉路","text":"描述:类似于成语接龙，给若干个单词，问能否组成一个排列，使得一个单词的尾字母和后面一个单词的首字母相同。例如acm，malform，mouse这三个单词就满足题意。 思路:把每个单词看成一条边，取首字母和尾字母，作为起点和终点。建图，图上有26个点，每输入一个单词，就在对应的两点间建立一条有向边。要判断输入的单词是否满足题意，其实就是判断图中是否存在一条欧拉路径。如果这个图不只包含一个连通分量，那么一定不满足题意。连通分量用并查集维护。 下面的问题就是判断有向图的欧拉路径。如果不是回路，那么图中只有一个点的出度比入度大1（起点），一个点的出度比入度小1（终点），其它点出度等于入度。如果是欧拉回路，则所有的点出度等于入度。并且如果存在出度入度的差值大于1的点也一定不能形成欧拉路。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int p[30];int Find(int x)&#123; if(x!=p[x]) p[x]=Find(p[x]); return p[x];&#125;void join(int a,int b)&#123; if(Find(a)!=Find(b)) p[Find(a)]=Find(b);&#125;int main()&#123; //freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); int t,num,num1,num2; cin&gt;&gt;t; int indeg[30],outdeg[30]; bool vis[30],flag; while(t--) &#123; num=num1=num2=0; flag=true; int n; cin&gt;&gt;n; char str[1000]; for(int i=0; i&lt;26; i++) &#123; p[i]=i; vis[i]=false; outdeg[i]=indeg[i]=0; &#125; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;str; join(str[0]-&apos;a&apos;,str[strlen(str)-1]-&apos;a&apos;); indeg[str[0]-&apos;a&apos;]++; outdeg[str[strlen(str)-1]-&apos;a&apos;]++; vis[str[0]-&apos;a&apos;]=true; vis[str[strlen(str)-1]-&apos;a&apos;]=true; &#125; for(int i=0; i&lt;26; i++) &#123; if(p[i]==i&amp;&amp;vis[i]) num++; if(indeg[i]-outdeg[i]==1) num1++; if(outdeg[i]-indeg[i]==1) num2++; if(indeg[i]-outdeg[i]&gt;1||outdeg[i]-indeg[i]&gt;1) flag=false; &#125; if(flag==true&amp;&amp;num==1&amp;&amp;(num1==num2==0||num1==num2==1)) &#123; cout&lt;&lt;&quot;Ordering is possible.&quot;&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;The door cannot be opened.&quot;&lt;&lt;endl; &#125;&#125;","path":"2019/02/04/Hdu-1116-Play-on-Words-并查集-有向图的欧拉路/"},{"title":"bzoj 1036 树的统计 树链剖分","text":"描述:三种操作，一是修改树上某结点的权，二是询问结点x到y路径上的最大点的权，三是询问结点x到y路径上所有点的权值和。 思路:先对树进行重链剖分，然后用线段树维护连续区间的最大值和区间和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=30005;const int maxm=60005;const int inf=1e9;int cnt,tot,n,q;int head[maxn],siz[maxn],dep[maxn],pre[maxn],fa[maxn],wson[maxn],dfn[maxn],top[maxn];int value[maxn];struct Tree&#123; int l,r,sum,mx;&#125; tree[4*maxn];struct Edge&#123; int nex,to;&#125; edge[maxm];void add_edge(int u,int v)&#123; edge[++cnt].to=v; edge[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs1(int u,int f)&#123; siz[u]=1; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v==fa[u]) continue; dep[v]=dep[u]+1; fa[v]=u; dfs1(v,u); siz[u]+=siz[v]; if(siz[wson[u]]&lt;siz[v]) wson[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++tot; pre[tot]=u; top[u]=tp; if(wson[u]) dfs2(wson[u],tp); for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(v!=fa[u]&amp;&amp;v!=wson[u]) dfs2(v,v); &#125;&#125;void build(int k,int l,int r)&#123; tree[k].l=l,tree[k].r=r; if(l==r) return ; int mid=l+r&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r);&#125;void change(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==r) &#123; tree[k].sum=tree[k].mx=y; return ; &#125; if(x&lt;=mid) change(k&lt;&lt;1,x,y); else change(k&lt;&lt;1|1,x,y); tree[k].sum=tree[k&lt;&lt;1].sum+tree[k&lt;&lt;1|1].sum; tree[k].mx=max(tree[k&lt;&lt;1].mx,tree[k&lt;&lt;1|1].mx);&#125;int querysum(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].sum; if(y&lt;=mid) return querysum(k&lt;&lt;1,x,y); else if(x&gt;mid) return querysum(k&lt;&lt;1|1,x,y); else return querysum(k&lt;&lt;1,x,mid)+querysum(k&lt;&lt;1|1,mid+1,y);&#125;int querymax(int k,int x,int y)&#123; int l=tree[k].l,r=tree[k].r,mid=l+r&gt;&gt;1; if(l==x&amp;&amp;r==y) return tree[k].mx; if(y&lt;=mid) return querymax(k&lt;&lt;1,x,y); else if(x&gt;mid) return querymax(k&lt;&lt;1|1,x,y); else return max(querymax(k&lt;&lt;1,x,mid),querymax(k&lt;&lt;1|1,mid+1,y));&#125;int solvesum(int x,int y)&#123; int sum=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); sum+=querysum(1,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); sum+=querysum(1,dfn[x],dfn[y]); return sum;&#125;int solvemax(int x,int y)&#123; int mx=-inf; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); mx=max(mx,querymax(1,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; if(dfn[x]&gt;dfn[y]) swap(x,y); mx=max(mx,querymax(1,dfn[x],dfn[y])); return mx;&#125;void solve()&#123; build(1,1,n); for(int i=1; i&lt;=n; i++) change(1,dfn[i],value[i]); scanf(&quot;%d&quot;,&amp;q); char ch[10]; for(int i=1; i&lt;=q; i++) &#123; int x,y; scanf(&quot;%s%d%d&quot;,ch,&amp;x,&amp;y); if(ch[0]==&apos;C&apos;) &#123; value[x]=y; change(1,dfn[x],y); &#125; else &#123; if(ch[1]==&apos;M&apos;) printf(&quot;%d\\n&quot;,solvemax(x,y)); else printf(&quot;%d\\n&quot;,solvesum(x,y)); &#125; &#125;&#125;int main()&#123; cnt=-1; tot=0; memset(head,-1,sizeof(head)); scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;n; i++) &#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); add_edge(a,b); add_edge(b,a); &#125; for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;value[i]); dfs1(1,0); dfs2(1,1); solve(); return 0;&#125;","path":"2019/02/04/bzoj-1036-树的统计-树链剖分/"},{"title":"bzoj 1008 越狱","text":"描述:有n个人排成一列，一共有m种势力，每个人可能属于一个势力，相邻的人势力相同则不合法，一共有多少种可能的不合法状态。 思路:所有的状态是$m^{n}$,正面很难求不合法的状态，所以想到先求合法状态，第一个人有$m$种选择，剩下的人都只有$m-1$种选择，所以答案就是$m^{n}-m*(m-1)^{n-1}$。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=100003;ll m,n;ll quick_pow(ll a,ll b)&#123; ll res=1; while(b) &#123; if(b&amp;1) res=(res*a)%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; while(~scanf(&quot;%lld %lld&quot;,&amp;m,&amp;n)) &#123; ll ans=(quick_pow(m,n)-(m*quick_pow(m-1,n-1))%mod+mod)%mod; printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","path":"2019/02/04/bzoj-1008-越狱/"},{"title":"bzoj1003 预处理最短路+区间dp","text":"描述:给一个图，让你跑n次最短路，第i次最短路有若干点是不能使用的，并且更改一次路线就又需要加k的额外花费，问跑完n次以后最小花费。 思路:想到把n次最短路分割成多个区间最短路的和，一个区间内最短路是不变的，对于每种最短路，我们可以预处理，因为只有n方的区间，n最大100，点最多只有20个，先跑n方的spfa。设dp[i][j]表示第i次到第j次最短路的所有花费的最小值。那么答案就是dp[1][n]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200;const int maxm=1000;int cnt=-1,n,m,k,e;int head[maxn],use[110][110],dist[maxn],dp[110][110];bool inq[maxn];struct Edge&#123; int nex; int to,w;&#125; edge[maxm];void add_edge(int u,int v,int w)&#123; edge[++cnt].nex=head[u]; edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;bool check(int x,int s,int t)&#123; for(int i=s; i&lt;=t; i++) if(!use[x][i]) return false; return true;&#125;int spfa(int s,int t)&#123; memset(dist,0x3f,sizeof(dist)); memset(inq,false,sizeof(inq)); queue&lt;int&gt;que; while(!que.empty()) que.pop(); que.push(1); dist[1]=0; inq[1]=true; while(!que.empty()) &#123; int u=que.front(); que.pop(); inq[u]=false; for(int i=head[u]; i!=-1; i=edge[i].nex) &#123; int v=edge[i].to; if(check(v,s,t)&amp;&amp;dist[v]&gt;dist[u]+edge[i].w) &#123; dist[v]=dist[u]+edge[i].w; if(!inq[v]) inq[v]=true,que.push(v); &#125; &#125; &#125; return dist[m]==0x3f3f3f3f ? 0x3f3f3f3f:dist[m]*(t-s+1);&#125;void solve()&#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=i; j&lt;=n; j++) dp[i][j]=spfa(i,j); &#125; int e; for(int len=2; len&lt;=n; len++) for(int s=1; (e=s+len-1)&lt;=n; s++) for(int p=s; p&lt;s+len-1; p++) &#123; dp[s][e]=min(dp[s][e],dp[s][p]+dp[p+1][e]+k); &#125; printf(&quot;%d\\n&quot;,dp[1][n]);&#125;int main()&#123; while(~scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;k,&amp;e)) &#123; memset(head,-1,sizeof(head)); cnt=-1; for(int i=1; i&lt;maxm; i++) edge[i].nex=-1; for(int i=1; i&lt;=e; i++) &#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); add_edge(a,b,c); add_edge(b,a,c); &#125; memset(use,1,sizeof(use)); int tem; scanf(&quot;%d&quot;,&amp;tem); for(int i=1; i&lt;=tem; i++) &#123; int p,a,b; scanf(&quot;%d %d %d&quot;,&amp;p,&amp;a,&amp;b); for(int j=a; j&lt;=b; j++) use[p][j]=0; &#125; solve(); &#125;&#125;","path":"2019/02/04/bzoj1003-预处理最短路-区间dp/"}]}